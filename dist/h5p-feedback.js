/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 10);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

// this module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  scopeId,
  cssModules
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  // inject cssModules
  if (cssModules) {
    var computed = Object.create(options.computed || null)
    Object.keys(cssModules).forEach(function (key) {
      var module = cssModules[key]
      computed[key] = function () { return module }
    })
    options.computed = computed
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vue = __webpack_require__(8);

var _vue2 = _interopRequireDefault(_vue);

var _vueRouter = __webpack_require__(7);

var _vueRouter2 = _interopRequireDefault(_vueRouter);

var _ScoreInput = __webpack_require__(12);

var _ScoreInput2 = _interopRequireDefault(_ScoreInput);

var _TextInput = __webpack_require__(13);

var _TextInput2 = _interopRequireDefault(_TextInput);

var _Final = __webpack_require__(11);

var _Final2 = _interopRequireDefault(_Final);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

_vue2.default.use(_vueRouter2.default);

var Feedback = function (_H5P$EventDispatcher) {
  _inherits(Feedback, _H5P$EventDispatcher);

  /**
   * @constructor
   *
   * @param {object} config
   * @param {string} contentId
   * @param {object} contentData
   */
  function Feedback(config, contentId) {
    var contentData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, Feedback);

    var _this = _possibleConstructorReturn(this, (Feedback.__proto__ || Object.getPrototypeOf(Feedback)).call(this));

    _this.contentId = contentId;

    var alternatives = [{
      title: 'Very Satisfied',
      cls: 'feedback-score-4',
      score: '4'
    }, {
      title: 'Satisfied',
      cls: 'feedback-score-3',
      score: '3'
    }, {
      title: 'Neutral',
      cls: 'feedback-score-2',
      score: '2'
    }, {
      title: 'Unsatisfied',
      cls: 'feedback-score-1',
      score: '1'
    }];

    // set data on score input view
    _ScoreInput2.default.data = function () {
      return {
        message: config.title,
        score: '0',
        alternatives: alternatives
      };
    };

    // set data on text input view
    _TextInput2.default.data = function () {
      return {
        alternatives: alternatives
      };
    };

    // crate router
    var router = new _vueRouter2.default({
      mode: 'abstract',
      routes: [{ path: '/score-input', component: _ScoreInput2.default }, { path: '/text-input/:score', component: _TextInput2.default, props: true }, { path: '/final', component: _Final2.default }]
    });

    // create view model
    _this.viewModel = new _vue2.default({ router: router });

    /**
     * Attach library to wrapper
     *
     * @param {jQuery} $wrapper
     * @public
     */
    _this.attach = function ($wrapper) {
      // create root element
      var element = document.createElement('div');
      element.id = 'h5p-feedback-content-' + _this.contentId;
      element.className = 'h5p-feedback';
      element.innerHTML = '<router-view></router-view>';

      // add root element to wrapper
      $wrapper.get(0).appendChild(element);

      // mount root view
      _this.viewModel.$mount('#' + element.id);

      // navigate to score
      router.push('score-input');
    };
    return _this;
  }

  return Feedback;
}(H5P.EventDispatcher);

exports.default = Feedback;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//

exports.default = {
  name: 'final-view'
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'score-input-view',

  methods: {
    sendScore: function sendScore(alternative) {
      this.score = alternative.score;

      this.$router.push('text-input/' + alternative.score);
    }
  }
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'text-input-view',
  props: ['score'],
  watch: {
    '$route': 'updateAlternative'
  },

  created: function created() {
    this.updateAlternative();
  },


  methods: {
    updateAlternative: function updateAlternative() {
      var _this = this;

      this.alternative = this.alternatives.filter(function (alternative) {
        return alternative.score === _this.score;
      })[0];
    },


    sendText: function sendText() {
      // TODO Fire xAPI
      this.$router.push('/final');
    }
  }
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
  * vue-router v2.2.1
  * (c) 2017 Evan You
  * @license MIT
  */
/*  */

function assert(condition, message) {
  if (!condition) {
    throw new Error("[vue-router] " + message);
  }
}

function warn(condition, message) {
  if (!condition) {
    typeof console !== 'undefined' && console.warn("[vue-router] " + message);
  }
}

var View = {
  name: 'router-view',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render(h, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;

    data.routerView = true;

    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {});

    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    var depth = 0;
    var inactive = false;
    while (parent) {
      if (parent.$vnode && parent.$vnode.data.routerView) {
        depth++;
      }
      if (parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      return h(cache[name], data, children);
    }

    var matched = route.matched[depth];
    // render empty node if no matched route
    if (!matched) {
      cache[name] = null;
      return h();
    }

    var component = cache[name] = matched.components[name];

    // inject instance registration hooks
    var hooks = data.hook || (data.hook = {});
    hooks.init = function (vnode) {
      matched.instances[name] = vnode.child;
    };
    hooks.prepatch = function (oldVnode, vnode) {
      matched.instances[name] = vnode.child;
    };
    hooks.destroy = function (vnode) {
      if (matched.instances[name] === vnode.child) {
        matched.instances[name] = undefined;
      }
    };

    // resolve props
    data.props = resolveProps(route, matched.props && matched.props[name]);

    return h(component, data, children);
  }
};

function resolveProps(route, config) {
  switch (typeof config === "undefined" ? "undefined" : _typeof(config)) {
    case 'undefined':
      return;
    case 'object':
      return config;
    case 'function':
      return config(route);
    case 'boolean':
      return config ? route.params : undefined;
    default:
      warn(false, "props in \"" + route.path + "\" is a " + (typeof config === "undefined" ? "undefined" : _typeof(config)) + ", expecting an object, function or boolean.");
  }
}

/*  */

var encodeReserveRE = /[!'()*]/g;
var encodeReserveReplacer = function encodeReserveReplacer(c) {
  return '%' + c.charCodeAt(0).toString(16);
};
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more comformant to RFC3986:
// - escapes [!'()*]
// - preserve commas
var encode = function encode(str) {
  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');
};

var decode = decodeURIComponent;

function resolveQuery(query, extraQuery) {
  if (extraQuery === void 0) extraQuery = {};

  if (query) {
    var parsedQuery;
    try {
      parsedQuery = parseQuery(query);
    } catch (e) {
      process.env.NODE_ENV !== 'production' && warn(false, e.message);
      parsedQuery = {};
    }
    for (var key in extraQuery) {
      parsedQuery[key] = extraQuery[key];
    }
    return parsedQuery;
  } else {
    return extraQuery;
  }
}

function parseQuery(query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res;
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0 ? decode(parts.join('=')) : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });

  return res;
}

function stringifyQuery(obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return '';
    }

    if (val === null) {
      return encode(key);
    }

    if (Array.isArray(val)) {
      var result = [];
      val.slice().forEach(function (val2) {
        if (val2 === undefined) {
          return;
        }
        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&');
    }

    return encode(key) + '=' + encode(val);
  }).filter(function (x) {
    return x.length > 0;
  }).join('&') : null;
  return res ? "?" + res : '';
}

/*  */

var trailingSlashRE = /\/?$/;

function createRoute(record, location, redirectedFrom) {
  var route = {
    name: location.name || record && record.name,
    meta: record && record.meta || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: location.query || {},
    params: location.params || {},
    fullPath: getFullPath(location),
    matched: record ? formatMatch(record) : []
  };
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom);
  }
  return Object.freeze(route);
}

// the starting route that represents the initial state
var START = createRoute(null, {
  path: '/'
});

function formatMatch(record) {
  var res = [];
  while (record) {
    res.unshift(record);
    record = record.parent;
  }
  return res;
}

function getFullPath(ref) {
  var path = ref.path;
  var query = ref.query;if (query === void 0) query = {};
  var hash = ref.hash;if (hash === void 0) hash = '';

  return (path || '/') + stringifyQuery(query) + hash;
}

function isSameRoute(a, b) {
  if (b === START) {
    return a === b;
  } else if (!b) {
    return false;
  } else if (a.path && b.path) {
    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);
  } else if (a.name && b.name) {
    return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);
  } else {
    return false;
  }
}

function isObjectEqual(a, b) {
  if (a === void 0) a = {};
  if (b === void 0) b = {};

  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false;
  }
  return aKeys.every(function (key) {
    return String(a[key]) === String(b[key]);
  });
}

function isIncludedRoute(current, target) {
  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);
}

function queryIncludes(current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false;
    }
  }
  return true;
}

/*  */

// work around weird flow bug
var toTypes = [String, Object];
var eventTypes = [String, Array];

var Link = {
  name: 'router-link',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render(h) {
    var this$1 = this;

    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;
    var classes = {};
    var activeClass = this.activeClass || router.options.linkActiveClass || 'router-link-active';
    var compareTarget = location.path ? createRoute(null, location) : route;
    classes[activeClass] = this.exact ? isSameRoute(current, compareTarget) : isIncludedRoute(current, compareTarget);

    var handler = function handler(e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location);
        } else {
          router.push(location);
        }
      }
    };

    var on = { click: guardEvent };
    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) {
        on[e] = handler;
      });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = { href: href };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);
      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var extend = _Vue.util.extend;
        var aData = a.data = extend({}, a.data);
        aData.on = on;
        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default);
  }
};

function guardEvent(e) {
  // don't redirect with control keys
  if (e.metaKey || e.ctrlKey || e.shiftKey) {
    return;
  }
  // don't redirect when preventDefault called
  if (e.defaultPrevented) {
    return;
  }
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) {
    return;
  }
  // don't redirect if `target="_blank"`
  if (e.target && e.target.getAttribute) {
    var target = e.target.getAttribute('target');
    if (/\b_blank\b/i.test(target)) {
      return;
    }
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault();
  }
  return true;
}

function findAnchor(children) {
  if (children) {
    var child;
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      if (child.tag === 'a') {
        return child;
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child;
      }
    }
  }
}

var _Vue;

function install(Vue) {
  if (install.installed) {
    return;
  }
  install.installed = true;

  _Vue = Vue;

  Object.defineProperty(Vue.prototype, '$router', {
    get: function get() {
      return this.$root._router;
    }
  });

  Object.defineProperty(Vue.prototype, '$route', {
    get: function get() {
      return this.$root._route;
    }
  });

  Vue.mixin({
    beforeCreate: function beforeCreate() {
      if (this.$options.router) {
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, '_route', this._router.history.current);
      }
    }
  });

  Vue.component('router-view', View);
  Vue.component('router-link', Link);

  var strats = Vue.config.optionMergeStrategies;
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created;
}

/*  */

var inBrowser = typeof window !== 'undefined';

/*  */

function resolvePath(relative, base, append) {
  if (relative.charAt(0) === '/') {
    return relative;
  }

  if (relative.charAt(0) === '?' || relative.charAt(0) === '#') {
    return base + relative;
  }

  var stack = base.split('/');

  // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  }

  // resolve relative path
  var segments = relative.replace(/^\//, '').split('/');
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment === '.') {
      continue;
    } else if (segment === '..') {
      stack.pop();
    } else {
      stack.push(segment);
    }
  }

  // ensure leading slash
  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/');
}

function parsePath(path) {
  var hash = '';
  var query = '';

  var hashIndex = path.indexOf('#');
  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');
  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  };
}

function cleanPath(path) {
  return path.replace(/\/\//g, '/');
}

/*  */

function createRouteMap(routes, oldPathMap, oldNameMap) {
  var pathMap = oldPathMap || Object.create(null);
  var nameMap = oldNameMap || Object.create(null);

  routes.forEach(function (route) {
    addRouteRecord(pathMap, nameMap, route);
  });

  return {
    pathMap: pathMap,
    nameMap: nameMap
  };
}

function addRouteRecord(pathMap, nameMap, route, parent, matchAs) {
  var path = route.path;
  var name = route.name;
  if (process.env.NODE_ENV !== 'production') {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(typeof route.component !== 'string', "route config \"component\" for path: " + String(path || name) + " cannot be a " + "string id. Use an actual component instead.");
  }

  var record = {
    path: normalizePath(path, parent),
    components: route.components || { default: route.component },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null ? {} : route.components ? route.props : { default: route.props }
  };

  if (route.children) {
    // Warn if route is named and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (process.env.NODE_ENV !== 'production') {
      if (route.name && route.children.some(function (child) {
        return (/^\/?$/.test(child.path)
        );
      })) {
        warn(false, "Named Route '" + route.name + "' has a default child route. " + "When navigating to this named route (:to=\"{name: '" + route.name + "'\"), " + "the default child route will not be rendered. Remove the name from " + "this route and use the name of the default child route for named " + "links instead.");
      }
    }
    route.children.forEach(function (child) {
      var childMatchAs = matchAs ? cleanPath(matchAs + "/" + child.path) : undefined;
      addRouteRecord(pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (route.alias !== undefined) {
    if (Array.isArray(route.alias)) {
      route.alias.forEach(function (alias) {
        var aliasRoute = {
          path: alias,
          children: route.children
        };
        addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);
      });
    } else {
      var aliasRoute = {
        path: route.alias,
        children: route.children
      };
      addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);
    }
  }

  if (!pathMap[record.path]) {
    pathMap[record.path] = record;
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {
      warn(false, "Duplicate named routes definition: " + "{ name: \"" + name + "\", path: \"" + record.path + "\" }");
    }
  }
}

function normalizePath(path, parent) {
  path = path.replace(/\/$/, '');
  if (path[0] === '/') {
    return path;
  }
  if (parent == null) {
    return path;
  }
  return cleanPath(parent.path + "/" + path);
}

var index$1 = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

var isarray = index$1;

/**
 * Expose `pathToRegexp`.
 */
var index = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)',
// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens;
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile(str, options) {
  return tokensToFunction(parse(str, options));
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (_typeof(tokens[i]) === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags(options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys);
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp(path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */keys);
  }

  if (isarray(path)) {
    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);
  }

  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);
}

index.parse = parse_1;
index.compile = compile_1;
index.tokensToFunction = tokensToFunction_1;
index.tokensToRegExp = tokensToRegExp_1;

/*  */

var regexpCache = Object.create(null);

function getRouteRegex(path) {
  var hit = regexpCache[path];
  var keys, regexp;

  if (hit) {
    keys = hit.keys;
    regexp = hit.regexp;
  } else {
    keys = [];
    regexp = index(path, keys);
    regexpCache[path] = { keys: keys, regexp: regexp };
  }

  return { keys: keys, regexp: regexp };
}

var regexpCompileCache = Object.create(null);

function fillParams(path, params, routeMsg) {
  try {
    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = index.compile(path));
    return filler(params || {}, { pretty: true });
  } catch (e) {
    if (process.env.NODE_ENV !== 'production') {
      warn(false, "missing param for " + routeMsg + ": " + e.message);
    }
    return '';
  }
}

/*  */

function normalizeLocation(raw, current, append) {
  var next = typeof raw === 'string' ? { path: raw } : raw;
  // named target
  if (next.name || next._normalized) {
    return next;
  }

  // relative params
  if (!next.path && next.params && current) {
    next = assign({}, next);
    next._normalized = true;
    var params = assign(assign({}, current.params), next.params);
    if (current.name) {
      next.name = current.name;
      next.params = params;
    } else if (current.matched) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params, "path " + current.path);
    } else if (process.env.NODE_ENV !== 'production') {
      warn(false, "relative params navigation requires a current route.");
    }
    return next;
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = current && current.path || '/';
  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : current && current.path || '/';
  var query = resolveQuery(parsedPath.query, next.query);
  var hash = next.hash || parsedPath.hash;
  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  };
}

function assign(a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a;
}

/*  */

function createMatcher(routes) {
  var ref = createRouteMap(routes);
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes(routes) {
    createRouteMap(routes, pathMap, nameMap);
  }

  function match(raw, currentRoute, redirectedFrom) {
    var location = normalizeLocation(raw, currentRoute);
    var name = location.name;

    if (name) {
      var record = nameMap[name];
      if (process.env.NODE_ENV !== 'production') {
        warn(record, "Route with name '" + name + "' does not exist");
      }
      var paramNames = getRouteRegex(record.path).keys.filter(function (key) {
        return !key.optional;
      }).map(function (key) {
        return key.name;
      });

      if (_typeof(location.params) !== 'object') {
        location.params = {};
      }

      if (currentRoute && _typeof(currentRoute.params) === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, "named route \"" + name + "\"");
        return _createRoute(record, location, redirectedFrom);
      }
    } else if (location.path) {
      location.params = {};
      for (var path in pathMap) {
        if (matchRoute(path, location.params, location.path)) {
          return _createRoute(pathMap[path], location, redirectedFrom);
        }
      }
    }
    // no match
    return _createRoute(null, location);
  }

  function redirect(record, location) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location)) : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = { path: redirect };
    }

    if (!redirect || (typeof redirect === "undefined" ? "undefined" : _typeof(redirect)) !== 'object') {
      process.env.NODE_ENV !== 'production' && warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      return _createRoute(null, location);
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];
      if (process.env.NODE_ENV !== 'production') {
        assert(targetRecord, "redirect failed: named route \"" + name + "\" not found.");
      }
      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location);
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record);
      // 2. resolve params
      var resolvedPath = fillParams(rawPath, params, "redirect route with path \"" + rawPath + "\"");
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location);
    } else {
      warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      return _createRoute(null, location);
    }
  }

  function alias(record, location, matchAs) {
    var aliasedPath = fillParams(matchAs, location.params, "aliased route with path \"" + matchAs + "\"");
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });
    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location);
    }
    return _createRoute(null, location);
  }

  function _createRoute(record, location, redirectedFrom) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location);
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs);
    }
    return createRoute(record, location, redirectedFrom);
  }

  return {
    match: match,
    addRoutes: addRoutes
  };
}

function matchRoute(path, params, pathname) {
  var ref = getRouteRegex(path);
  var regexp = ref.regexp;
  var keys = ref.keys;
  var m = pathname.match(regexp);

  if (!m) {
    return false;
  } else if (!params) {
    return true;
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
    if (key) {
      params[key.name] = val;
    }
  }

  return true;
}

function resolveRecordPath(path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true);
}

/*  */

var positionStore = Object.create(null);

function setupScroll() {
  window.addEventListener('popstate', function (e) {
    saveScrollPosition();
    if (e.state && e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll(router, to, from, isPop) {
  if (!router.app) {
    return;
  }

  var behavior = router.options.scrollBehavior;
  if (!behavior) {
    return;
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  }

  // wait until re-render finishes before scrolling
  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior(to, from, isPop ? position : null);
    if (!shouldScroll) {
      return;
    }
    var isObject = (typeof shouldScroll === "undefined" ? "undefined" : _typeof(shouldScroll)) === 'object';
    if (isObject && typeof shouldScroll.selector === 'string') {
      var el = document.querySelector(shouldScroll.selector);
      if (el) {
        position = getElementPosition(el);
      } else if (isValidPosition(shouldScroll)) {
        position = normalizePosition(shouldScroll);
      }
    } else if (isObject && isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }

    if (position) {
      window.scrollTo(position.x, position.y);
    }
  });
}

function saveScrollPosition() {
  var key = getStateKey();
  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition() {
  var key = getStateKey();
  if (key) {
    return positionStore[key];
  }
}

function getElementPosition(el) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left,
    y: elRect.top - docRect.top
  };
}

function isValidPosition(obj) {
  return isNumber(obj.x) || isNumber(obj.y);
}

function normalizePosition(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  };
}

function isNumber(v) {
  return typeof v === 'number';
}

/*  */

var supportsPushState = inBrowser && function () {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
    return false;
  }

  return window.history && 'pushState' in window.history;
}();

// use User Timing api (if present) for more accurate key precision
var Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;

var _key = genKey();

function genKey() {
  return Time.now().toFixed(3);
}

function getStateKey() {
  return _key;
}

function setStateKey(key) {
  _key = key;
}

function pushState(url, replace) {
  saveScrollPosition();
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  var history = window.history;
  try {
    if (replace) {
      history.replaceState({ key: _key }, '', url);
    } else {
      _key = genKey();
      history.pushState({ key: _key }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState(url) {
  pushState(url, true);
}

/*  */

function runQueue(queue, fn, cb) {
  var step = function step(index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/*  */

var History = function History(router, base) {
  this.router = router;
  this.base = normalizeBase(base);
  // start with a route object that stands for "nowhere"
  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
};

History.prototype.listen = function listen(cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady(cb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);
  }
};

History.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {
  var this$1 = this;

  var route = this.router.match(location, this.current);
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete && onComplete(route);
    this$1.ensureURL();

    // fire ready cbs once
    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) {
        cb(route);
      });
    }
  }, onAbort);
};

History.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {
  var this$1 = this;

  var current = this.current;
  var abort = function abort() {
    onAbort && onAbort();
  };
  if (isSameRoute(route, current) &&
  // in the case the route map has been dynamically appended to
  route.matched.length === current.matched.length) {
    this.ensureURL();
    return abort();
  }

  var ref = resolveQueue(this.current.matched, route.matched);
  var updated = ref.updated;
  var deactivated = ref.deactivated;
  var activated = ref.activated;

  var queue = [].concat(
  // in-component leave guards
  extractLeaveGuards(deactivated),
  // global before hooks
  this.router.beforeHooks,
  // in-component update hooks
  extractUpdateHooks(updated),
  // in-config enter guards
  activated.map(function (m) {
    return m.beforeEnter;
  }),
  // async components
  resolveAsyncComponents(activated));

  this.pending = route;
  var iterator = function iterator(hook, next) {
    if (this$1.pending !== route) {
      return abort();
    }
    hook(route, current, function (to) {
      if (to === false) {
        // next(false) -> abort navigation, ensure current URL
        this$1.ensureURL(true);
        abort();
      } else if (typeof to === 'string' || (typeof to === "undefined" ? "undefined" : _typeof(to)) === 'object') {
        // next('/') or next({ path: '/' }) -> redirect
        (typeof to === "undefined" ? "undefined" : _typeof(to)) === 'object' && to.replace ? this$1.replace(to) : this$1.push(to);
        abort();
      } else {
        // confirm transition and pass on the value
        next(to);
      }
    });
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];
    var isValid = function isValid() {
      return this$1.current === route;
    };
    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    // wait until async components are resolved before
    // extracting in-component enter guards
    runQueue(enterGuards, iterator, function () {
      if (this$1.pending !== route) {
        return abort();
      }
      this$1.pending = null;
      onComplete(route);
      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) {
            return cb();
          });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute(route) {
  var prev = this.current;
  this.current = route;
  this.cb && this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook && hook(route, prev);
  });
};

function normalizeBase(base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = baseEl && baseEl.getAttribute('href') || '/';
    } else {
      base = '/';
    }
  }
  // make sure there's the starting slash
  if (base.charAt(0) !== '/') {
    base = '/' + base;
  }
  // remove trailing slash
  return base.replace(/\/$/, '');
}

function resolveQueue(current, next) {
  var i;
  var max = Math.max(current.length, next.length);
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break;
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  };
}

function extractGuards(records, name, bind, reverse) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);
    if (guard) {
      return Array.isArray(guard) ? guard.map(function (guard) {
        return bind(guard, instance, match, key);
      }) : bind(guard, instance, match, key);
    }
  });
  return flatten(reverse ? guards.reverse() : guards);
}

function extractGuard(def, key) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }
  return def.options[key];
}

function extractLeaveGuards(deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);
}

function extractUpdateHooks(updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard);
}

function bindGuard(guard, instance) {
  return function boundRouteGuard() {
    return guard.apply(instance, arguments);
  };
}

function extractEnterGuards(activated, cbs, isValid) {
  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key, cbs, isValid);
  });
}

function bindEnterGuard(guard, match, key, cbs, isValid) {
  return function routeEnterGuard(to, from, next) {
    return guard(to, from, function (cb) {
      next(cb);
      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
    });
  };
}

function poll(cb, // somehow flow cannot infer this is a function
instances, key, isValid) {
  if (instances[key]) {
    cb(instances[key]);
  } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}

function resolveAsyncComponents(matched) {
  return flatMapComponents(matched, function (def, _, match, key) {
    // if it's a function and doesn't have Vue options attached,
    // assume it's an async component resolve function.
    // we are not using Vue's default async resolving mechanism because
    // we want to halt the navigation until the incoming component has been
    // resolved.
    if (typeof def === 'function' && !def.options) {
      return function (to, from, next) {
        var resolve = once(function (resolvedDef) {
          match.components[key] = resolvedDef;
          next();
        });

        var reject = once(function (reason) {
          warn(false, "Failed to resolve async component " + key + ": " + reason);
          next(false);
        });

        var res = def(resolve, reject);
        if (res && typeof res.then === 'function') {
          res.then(resolve, reject);
        }
      };
    }
  });
}

function flatMapComponents(matched, fn) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return fn(m.components[key], m.instances[key], m, key);
    });
  }));
}

function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}

// in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.
function once(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    return fn.apply(this, arguments);
  };
}

/*  */

var HTML5History = function (History$$1) {
  function HTML5History(router, base) {
    var this$1 = this;

    History$$1.call(this, router, base);

    var expectScroll = router.options.scrollBehavior;

    if (expectScroll) {
      setupScroll();
    }

    window.addEventListener('popstate', function (e) {
      this$1.transitionTo(getLocation(this$1.base), function (route) {
        if (expectScroll) {
          handleScroll(router, route, this$1.current, true);
        }
      });
    });
  }

  if (History$$1) HTML5History.__proto__ = History$$1;
  HTML5History.prototype = Object.create(History$$1 && History$$1.prototype);
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go(n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, this$1.current, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, this$1.current, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL(push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {
    return getLocation(this.base);
  };

  return HTML5History;
}(History);

function getLocation(base) {
  var path = window.location.pathname;
  if (base && path.indexOf(base) === 0) {
    path = path.slice(base.length);
  }
  return (path || '/') + window.location.search + window.location.hash;
}

/*  */

var HashHistory = function (History$$1) {
  function HashHistory(router, base, fallback) {
    History$$1.call(this, router, base);
    // check history fallback deeplinking
    if (fallback && checkFallback(this.base)) {
      return;
    }
    ensureSlash();
  }

  if (History$$1) HashHistory.__proto__ = History$$1;
  HashHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  HashHistory.prototype.constructor = HashHistory;

  // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early
  HashHistory.prototype.setupListeners = function setupListeners() {
    var this$1 = this;

    window.addEventListener('hashchange', function () {
      if (!ensureSlash()) {
        return;
      }
      this$1.transitionTo(getHash(), function (route) {
        replaceHash(route.fullPath);
      });
    });
  };

  HashHistory.prototype.push = function push(location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go(n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL(push) {
    var current = this.current.fullPath;
    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    return getHash();
  };

  return HashHistory;
}(History);

function checkFallback(base) {
  var location = getLocation(base);
  if (!/^\/#/.test(location)) {
    window.location.replace(cleanPath(base + '/#' + location));
    return true;
  }
}

function ensureSlash() {
  var path = getHash();
  if (path.charAt(0) === '/') {
    return true;
  }
  replaceHash('/' + path);
  return false;
}

function getHash() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : href.slice(index + 1);
}

function pushHash(path) {
  window.location.hash = path;
}

function replaceHash(path) {
  var i = window.location.href.indexOf('#');
  window.location.replace(window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path);
}

/*  */

var AbstractHistory = function (History$$1) {
  function AbstractHistory(router, base) {
    History$$1.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if (History$$1) AbstractHistory.__proto__ = History$$1;
  AbstractHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go(n) {
    var this$1 = this;

    var targetIndex = this.index + n;
    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return;
    }
    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      this$1.index = targetIndex;
      this$1.updateRoute(route);
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/';
  };

  AbstractHistory.prototype.ensureURL = function ensureURL() {
    // noop
  };

  return AbstractHistory;
}(History);

/*  */

var VueRouter = function VueRouter(options) {
  if (options === void 0) options = {};

  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || []);

  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState;
  if (this.fallback) {
    mode = 'hash';
  }
  if (!inBrowser) {
    mode = 'abstract';
  }
  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break;
    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break;
    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break;
    default:
      if (process.env.NODE_ENV !== 'production') {
        assert(false, "invalid mode: " + mode);
      }
  }
};

var prototypeAccessors = { currentRoute: {} };

VueRouter.prototype.match = function match(raw, current, redirectedFrom) {
  return this.matcher.match(raw, current, redirectedFrom);
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current;
};

VueRouter.prototype.init = function init(app /* Vue component instance */) {
  var this$1 = this;

  process.env.NODE_ENV !== 'production' && assert(install.installed, "not installed. Make sure to call `Vue.use(VueRouter)` " + "before creating root instance.");

  this.apps.push(app);

  // main app already initialized.
  if (this.app) {
    return;
  }

  this.app = app;

  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function setupHashListener() {
      history.setupListeners();
    };
    history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach(fn) {
  this.beforeHooks.push(fn);
};

VueRouter.prototype.afterEach = function afterEach(fn) {
  this.afterHooks.push(fn);
};

VueRouter.prototype.onReady = function onReady(cb) {
  this.history.onReady(cb);
};

VueRouter.prototype.push = function push(location, onComplete, onAbort) {
  this.history.push(location, onComplete, onAbort);
};

VueRouter.prototype.replace = function replace(location, onComplete, onAbort) {
  this.history.replace(location, onComplete, onAbort);
};

VueRouter.prototype.go = function go(n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back() {
  this.go(-1);
};

VueRouter.prototype.forward = function forward() {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {
  var route = to ? this.resolve(to).route : this.currentRoute;
  if (!route) {
    return [];
  }
  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key];
    });
  }));
};

VueRouter.prototype.resolve = function resolve(to, current, append) {
  var location = normalizeLocation(to, current || this.history.current, append);
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  };
};

VueRouter.prototype.addRoutes = function addRoutes(routes) {
  this.matcher.addRoutes(routes);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties(VueRouter.prototype, prototypeAccessors);

function createHref(base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path;
}

VueRouter.install = install;
VueRouter.version = '2.2.1';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

exports.default = VueRouter;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Vue.js v2.2.4
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
/*  */

/**
 * Convert a value to a string that is actually rendered.
 */
function _toString(val) {
  return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Remove an item from an array
 */
function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

/**
 * Check if value is primitive
 */
function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number';
}

/**
 * Create a cached version of a pure function.
 */
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /([^-])([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();
});

/**
 * Simple bind, faster than native
 */
function bind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn;
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret;
}

/**
 * Mix properties into target object.
 */
function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject(obj) {
  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
var toString = Object.prototype.toString;
var OBJECT_STRING = '[object Object]';
function isPlainObject(obj) {
  return toString.call(obj) === OBJECT_STRING;
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}

/**
 * Perform no operation.
 */
function noop() {}

/**
 * Always return false.
 */
var no = function no() {
  return false;
};

/**
 * Return same value
 */
var identity = function identity(_) {
  return _;
};

/**
 * Generate a static keys string from compiler modules.
 */
function genStaticKeys(modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || []);
  }, []).join(',');
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual(a, b) {
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      return JSON.stringify(a) === JSON.stringify(b);
    } catch (e) {
      // possible circular reference
      return a === b;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}

function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }
  return -1;
}

/**
 * Ensure a function is called only once.
 */
function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn();
    }
  };
}

/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: process.env.NODE_ENV !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: process.env.NODE_ENV !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * List of asset types that a component can own.
   */
  _assetTypes: ['component', 'directive', 'filter'],

  /**
   * List of lifecycle hooks.
   */
  _lifecycleHooks: ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'],

  /**
   * Max circular updates allowed in a scheduler flush cycle.
   */
  _maxUpdateCount: 100
};

/*  */

var emptyObject = Object.freeze({});

/**
 * Check if a string starts with $ or _
 */
function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}

/**
 * Define a property.
 */
function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }
      obj = obj[segments[i]];
    }
    return obj;
  };
}

/*  */
/* globals MutationObserver */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function isServerRendering() {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer;
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative(Ctor) {
  return (/native code/.test(Ctor.toString())
  );
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

/**
 * Defer a task to execute it asynchronously.
 */
var nextTick = function () {
  var callbacks = [];
  var pending = false;
  var timerFunc;

  function nextTickHandler() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // the nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore if */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    var logError = function logError(err) {
      console.error(err);
    };
    timerFunc = function timerFunc() {
      p.then(nextTickHandler).catch(logError);
      // in problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) {
        setTimeout(noop);
      }
    };
  } else if (typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]')) {
    // use MutationObserver where native Promise is not available,
    // e.g. PhantomJS IE11, iOS7, Android 4.4
    var counter = 1;
    var observer = new MutationObserver(nextTickHandler);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function timerFunc() {
      counter = (counter + 1) % 2;
      textNode.data = String(counter);
    };
  } else {
    // fallback to setTimeout
    /* istanbul ignore next */
    timerFunc = function timerFunc() {
      setTimeout(nextTickHandler, 0);
    };
  }

  return function queueNextTick(cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        cb.call(ctx);
      }
      if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      timerFunc();
    }
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve) {
        _resolve = resolve;
      });
    }
  };
}();

var _Set;
/* istanbul ignore if */
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = function () {
    function Set() {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };
    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}

var warn = noop;
var tip = noop;
var formatComponentName;

if (process.env.NODE_ENV !== 'production') {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function classify(str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function warn(msg, vm) {
    if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + " " + (vm ? formatLocation(formatComponentName(vm)) : ''));
    }
  };

  tip = function tip(msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + " " + (vm ? formatLocation(formatComponentName(vm)) : ''));
    }
  };

  formatComponentName = function formatComponentName(vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }
    var name = typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;

    var file = vm._isVue && vm.$options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var formatLocation = function formatLocation(str) {
    if (str === "<Anonymous>") {
      str += " - use the \"name\" option for better debugging messages.";
    }
    return "\n(found in " + str + ")";
  };
}

/*  */

var uid$1 = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep() {
  this.id = uid$1++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget(_target) {
  if (Dep.target) {
    targetStack.push(Dep.target);
  }
  Dep.target = _target;
}

function popTarget() {
  Dep.target = targetStack.pop();
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var arguments$1 = arguments;

    // avoid leaking arguments:
    // http://jsperf.com/closure-with-arguments
    var i = arguments.length;
    var args = new Array(i);
    while (i--) {
      args[i] = arguments$1[i];
    }
    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
        inserted = args;
        break;
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    if (inserted) {
      ob.observeArray(inserted);
    }
    // notify change
    ob.dep.notify();
    return result;
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true,
  isSettingProps: false
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto ? protoAugment : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe(value, asRootData) {
  if (!isObject(value)) {
    return;
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob;
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1(obj, key, val, customSetter) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return;
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
        }
        if (Array.isArray(value)) {
          dependArray(value);
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set(target, key, val) {
  if (Array.isArray(target)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  if (hasOwn(target, key)) {
    target[key] = val;
    return val;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    process.env.NODE_ENV !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }
  if (!ob) {
    target[key] = val;
    return val;
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}

/**
 * Delete a property and trigger change if necessary.
 */
function del(target, key) {
  if (Array.isArray(target)) {
    target.splice(key, 1);
    return;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    process.env.NODE_ENV !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }
  if (!hasOwn(target, key)) {
    return;
  }
  delete target[key];
  if (!ob) {
    return;
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (process.env.NODE_ENV !== 'production') {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }
    return defaultStrat(parent, child);
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData(to, from) {
  if (!from) {
    return to;
  }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to;
}

/**
 * Data
 */
strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }
    if (typeof childVal !== 'function') {
      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
      return parentVal;
    }
    if (!parentVal) {
      return childVal;
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn() {
      return mergeData(childVal.call(this), parentVal.call(this));
    };
  } else if (parentVal || childVal) {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook(parentVal, childVal) {
  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
}

config._lifecycleHooks.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets(parentVal, childVal) {
  var res = Object.create(parentVal || null);
  return childVal ? extend(res, childVal) : res;
}

config._assetTypes.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal) {
  /* istanbul ignore if */
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = {};
  extend(ret, parentVal);
  for (var key in childVal) {
    var parent = ret[key];
    var child = childVal[key];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key] = parent ? parent.concat(child) : [child];
  }
  return ret;
};

/**
 * Other object hashes.
 */
strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = Object.create(null);
  extend(ret, parentVal);
  extend(ret, childVal);
  return ret;
};

/**
 * Default strategy.
 */
var defaultStrat = function defaultStrat(parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};

/**
 * Validate component names
 */
function checkComponents(options) {
  for (var key in options.components) {
    var lower = key.toLowerCase();
    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
    }
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps(options) {
  var props = options.props;
  if (!props) {
    return;
  }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (process.env.NODE_ENV !== 'production') {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : { type: val };
    }
  }
  options.props = res;
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives(options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions(parent, child, vm) {
  if (process.env.NODE_ENV !== 'production') {
    checkComponents(child);
  }
  normalizeProps(child);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = typeof extendsFrom === 'function' ? mergeOptions(parent, extendsFrom.options, vm) : mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      var mixin = child.mixins[i];
      if (mixin.prototype instanceof Vue$3) {
        mixin = mixin.options;
      }
      parent = mergeOptions(parent, mixin, vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options;
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) {
    return assets[id];
  }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }
  return res;
}

/*  */

function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  if (process.env.NODE_ENV !== 'production') {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}

/**
 * Assert whether a prop is valid.
 */
function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn('Invalid prop: type check failed for prop "' + name + '".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);
    return;
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

/**
 * Assert the type of a value
 */
function assertType(value, type) {
  var valid;
  var expectedType = getType(type);
  if (expectedType === 'String') {
    valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === (expectedType = 'string');
  } else if (expectedType === 'Number') {
    valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === (expectedType = 'number');
  } else if (expectedType === 'Boolean') {
    valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === (expectedType = 'boolean');
  } else if (expectedType === 'Function') {
    valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === (expectedType = 'function');
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  };
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match && match[1];
}

function isType(type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type);
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true;
    }
  }
  /* istanbul ignore next */
  return false;
}

function handleError(err, vm, info) {
  if (config.errorHandler) {
    config.errorHandler.call(null, err, vm, info);
  } else {
    if (process.env.NODE_ENV !== 'production') {
      warn("Error in " + info + ":", vm);
    }
    /* istanbul ignore else */
    if (inBrowser && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err;
    }
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (process.env.NODE_ENV !== 'production') {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function warnNonPresent(target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + "referenced during render. Make sure to declare reactive data " + "properties in the data option.", target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed;
    }
  };

  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

var mark;
var measure;

if (process.env.NODE_ENV !== 'production') {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function mark(tag) {
      return perf.mark(tag);
    };
    measure = function measure(name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/*  */

var VNode = function VNode(tag, data, children, text, elm, context, componentOptions) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.functionalContext = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
};

var prototypeAccessors = { child: {} };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function createEmptyVNode() {
  var node = new VNode();
  node.text = '';
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isCloned = true;
  return cloned;
}

function cloneVNodes(vnodes) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i]);
  }
  return res;
}

/*  */

var normalizeEvent = cached(function (name) {
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture
  };
});

function createFnInvoker(fns) {
  function invoker() {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      for (var i = 0; i < fns.length; i++) {
        fns[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments);
    }
  }
  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, vm) {
  var name, cur, old, event;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (!cur) {
      process.env.NODE_ENV !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (!old) {
      if (!cur.fns) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (!on[name]) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook(def, hookKey, hook) {
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (!oldHook) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (oldHook.fns && oldHook.merged) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }
  return children;
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (c == null || typeof c === 'boolean') {
      continue;
    }
    last = res[res.length - 1];
    //  nested
    if (Array.isArray(c)) {
      res.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + "_" + i));
    } else if (isPrimitive(c)) {
      if (last && last.text) {
        last.text += String(c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (c.text && last && last.text) {
        res[res.length - 1] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (c.tag && c.key == null && nestedIndex != null) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res;
}

/*  */

function getFirstComponentChild(children) {
  return children && children.filter(function (c) {
    return c && c.componentOptions;
  })[0];
}

/*  */

function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn, once$$1) {
  if (once$$1) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        this$1.$off(event[i$1], fn);
      }
      return vm;
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm;
    }
    if (arguments.length === 1) {
      vm._events[event] = null;
      return vm;
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }
    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        cbs[i].apply(vm, args);
      }
    }
    return vm;
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots(children, context) {
  var slots = {};
  if (!children) {
    return slots;
  }
  var defaultSlot = [];
  var name, child;
  for (var i = 0, l = children.length; i < l; i++) {
    child = children[i];
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.functionalContext === context) && child.data && (name = child.data.slot)) {
      var slot = slots[name] || (slots[name] = []);
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children);
      } else {
        slot.push(child);
      }
    } else {
      defaultSlot.push(child);
    }
  }
  // ignore whitespace
  if (!defaultSlot.every(isWhitespace)) {
    slots.default = defaultSlot;
  }
  return slots;
}

function isWhitespace(node) {
  return node.isComment || node.text === ' ';
}

function resolveScopedSlots(fns) {
  var res = {};
  for (var i = 0; i < fns.length; i++) {
    res[fns[i][0]] = fns[i][1];
  }
  return res;
}

/*  */

var activeInstance = null;

function initLifecycle(vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
      , vm.$options._parentElm, vm.$options._refElm);
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return;
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (process.env.NODE_ENV !== 'production') {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = function updateComponent() {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(name + " render", startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function updateComponent() {
      vm._update(vm._render(), hydrating);
    };
  }

  vm._watcher = new Watcher(vm, updateComponent, noop);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  parentVnode.data.scopedSlots || // has new scoped slots
  vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render
  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    if (process.env.NODE_ENV !== 'production') {
      observerState.isSettingProps = true;
    }
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    if (process.env.NODE_ENV !== 'production') {
      observerState.isSettingProps = false;
    }
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }
  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }
  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }
  if (vm._inactive || vm._inactive == null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return;
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, hook + " hook");
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */

var queue = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState() {
  queue.length = 0;
  has = {};
  if (process.env.NODE_ENV !== 'production') {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue() {
  flushing = true;
  var watcher, id, vm;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) {
    return a.id - b.id;
  });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > config._maxUpdateCount) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  }

  // call updated hooks
  index = queue.length;
  while (index--) {
    watcher = queue[index];
    vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }

  resetSchedulerState();
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher(watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i >= 0 && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(Math.max(i, index) + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher(vm, expOrFn, cb, options) {
  this.vm = vm;
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      process.env.NODE_ENV !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }
  this.value = this.lazy ? undefined : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;
  if (this.user) {
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    }
  } else {
    value = this.getter.call(vm, vm);
  }
  // "touch" every property so they are all tracked as
  // dependencies for deep watching
  if (this.deep) {
    traverse(value);
  }
  popTarget();
  this.cleanupDeps();
  return value;
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();
    if (value !== this.value ||
    // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown() {
  var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
var seenObjects = new _Set();
function traverse(val) {
  seenObjects.clear();
  _traverse(val, seenObjects);
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if (!isA && !isObject(val) || !Object.isExtensible(val)) {
    return;
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return;
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) {
    initProps(vm, opts.props);
  }
  if (opts.methods) {
    initMethods(vm, opts.methods);
  }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) {
    initComputed(vm, opts.computed);
  }
  if (opts.watch) {
    initWatch(vm, opts.watch);
  }
}

var isReservedProp = { key: 1, ref: 1, slot: 1 };

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function loop(key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      if (isReservedProp[key]) {
        warn("\"" + key + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }
      defineReactive$$1(props, key, value, function () {
        if (vm.$parent && !observerState.isSettingProps) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {
      defineReactive$$1(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) {
    loop(key);
  }observerState.shouldConvert = true;
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? data.call(vm) : data || {};
  if (!isPlainObject(data)) {
    data = {};
    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var i = keys.length;
  while (i--) {
    if (props && hasOwn(props, keys[i])) {
      process.env.NODE_ENV !== 'production' && warn("The data property \"" + keys[i] + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(keys[i])) {
      proxy(vm, "_data", keys[i]);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

var computedWatcherOptions = { lazy: true };

function initComputed(vm, computed) {
  var watchers = vm._computedWatchers = Object.create(null);

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    // create internal watcher for the computed property.
    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    }
  }
}

function defineComputed(target, key, userDef) {
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = createComputedGetter(key);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value;
    }
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
    if (process.env.NODE_ENV !== 'production') {
      if (methods[key] == null) {
        warn("method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
      }
      if (props && hasOwn(props, key)) {
        warn("method \"" + key + "\" has already been defined as a prop.", vm);
      }
    }
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, key, handler) {
  var options;
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  vm.$watch(key, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () {
    return this._data;
  };
  var propsDef = {};
  propsDef.get = function () {
    return this._props;
  };
  if (process.env.NODE_ENV !== 'production') {
    dataDef.set = function (newData) {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn() {
      watcher.teardown();
    };
  };
}

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init(vnode, hydrating, parentElm, refElm) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },

  insert: function insert(vnode) {
    if (!vnode.componentInstance._isMounted) {
      vnode.componentInstance._isMounted = true;
      callHook(vnode.componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      activateChildComponent(vnode.componentInstance, true /* direct */);
    }
  },

  destroy: function destroy(vnode) {
    if (!vnode.componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        vnode.componentInstance.$destroy();
      } else {
        deactivateChildComponent(vnode.componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (!Ctor) {
    return;
  }

  var baseCtor = context.$options._base;
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  if (typeof Ctor !== 'function') {
    if (process.env.NODE_ENV !== 'production') {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  }

  // async component
  if (!Ctor.cid) {
    if (Ctor.resolved) {
      Ctor = Ctor.resolved;
    } else {
      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {
        // it's ok to queue this on every render because
        // $forceUpdate is buffered by the scheduler.
        context.$forceUpdate();
      });
      if (!Ctor) {
        // return nothing if this is indeed an async component
        // wait for the callback to trigger parent update.
        return;
      }
    }
  }

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  data = data || {};

  // transform component v-model data into props & events
  if (data.model) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractProps(data, Ctor);

  // functional component
  if (Ctor.options.functional) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  data.on = data.nativeOn;

  if (Ctor.options.abstract) {
    // abstract components do not keep anything
    // other than props & listeners
    data = {};
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children });
  return vnode;
}

function createFunctionalComponent(Ctor, propsData, data, context, children) {
  var props = {};
  var propOptions = Ctor.options.props;
  if (propOptions) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData);
    }
  }
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var _context = Object.create(context);
  var h = function h(a, b, c, d) {
    return createElement(_context, a, b, c, d, true);
  };
  var vnode = Ctor.options.render.call(null, h, {
    props: props,
    data: data,
    parent: context,
    children: children,
    slots: function slots() {
      return resolveSlots(children, context);
    }
  });
  if (vnode instanceof VNode) {
    vnode.functionalContext = context;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent, // activeInstance in lifecycle state
parentElm, refElm) {
  var vnodeComponentOptions = vnode.componentOptions;
  var options = {
    _isComponent: true,
    parent: parent,
    propsData: vnodeComponentOptions.propsData,
    _componentTag: vnodeComponentOptions.tag,
    _parentVnode: vnode,
    _parentListeners: vnodeComponentOptions.listeners,
    _renderChildren: vnodeComponentOptions.children,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (inlineTemplate) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnodeComponentOptions.Ctor(options);
}

function resolveAsyncComponent(factory, baseCtor, cb) {
  if (factory.requested) {
    // pool callbacks
    factory.pendingCallbacks.push(cb);
  } else {
    factory.requested = true;
    var cbs = factory.pendingCallbacks = [cb];
    var sync = true;

    var resolve = function resolve(res) {
      if (isObject(res)) {
        res = baseCtor.extend(res);
      }
      // cache resolved
      factory.resolved = res;
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        for (var i = 0, l = cbs.length; i < l; i++) {
          cbs[i](res);
        }
      }
    };

    var reject = function reject(reason) {
      process.env.NODE_ENV !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
    };

    var res = factory(resolve, reject);

    // handle promise
    if (res && typeof res.then === 'function' && !factory.resolved) {
      res.then(resolve, reject);
    }

    sync = false;
    // return in case resolved synchronously
    return factory.resolved;
  }
}

function extractProps(data, Ctor) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (!propOptions) {
    return;
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  var domProps = data.domProps;
  if (attrs || props || domProps) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (process.env.NODE_ENV !== 'production') {
        var keyInLowerCase = key.toLowerCase();
        if (key !== keyInLowerCase && attrs && attrs.hasOwnProperty(keyInLowerCase)) {
          warn("Prop \"" + keyInLowerCase + "\" is not declared in component " + formatComponentName(Ctor) + ". Note that HTML attributes are " + "case-insensitive and camelCased props need to use their kebab-case " + "equivalents when using in-DOM templates. You should probably use " + "\"" + altKey + "\" instead of \"" + key + "\".");
        }
      }
      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey) || checkProp(res, domProps, key, altKey);
    }
  }
  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (hash) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true;
    }
  }
  return false;
}

function mergeHooks(data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1(one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  };
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (on[event]) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (alwaysNormalize) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (data && data.__ob__) {
    process.env.NODE_ENV !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if (Ctor = resolveAsset(context.$options, 'components', tag)) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (vnode) {
    if (ns) {
      applyNS(vnode, ns);
    }
    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    return;
  }
  if (vnode.children) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (child.tag && !child.ns) {
        applyNS(child, ns);
      }
    }
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList(val, render) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  return ret;
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  if (scopedSlotFn) {
    // scoped slot
    props = props || {};
    if (bindObject) {
      extend(props, bindObject);
    }
    return scopedSlotFn(props) || fallback;
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes && process.env.NODE_ENV !== 'production') {
      slotNodes._rendered && warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
      slotNodes._rendered = true;
    }
    return slotNodes || fallback;
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 */
function checkKeyCodes(eventKeyCode, key, builtInAlias) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (Array.isArray(keyCodes)) {
    return keyCodes.indexOf(eventKeyCode) === -1;
  } else {
    return keyCodes !== eventKeyCode;
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps(data, tag, value, asProp) {
  if (value) {
    if (!isObject(value)) {
      process.env.NODE_ENV !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      for (var key in value) {
        if (key === 'class' || key === 'style') {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];
        }
      }
    }
  }
  return data;
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic(index, isInFor) {
  var tree = this._staticTrees[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);
  }
  // otherwise, render a fresh tree.
  tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
  markStatic(tree, "__static__" + index, false);
  return tree;
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function initRender(vm) {
  vm.$vnode = null; // the placeholder node in parent tree
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null;
  var parentVnode = vm.$options._parentVnode;
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  };
}

function renderMixin(Vue) {
  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var staticRenderFns = ref.staticRenderFns;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // clone slot nodes on re-renders
      for (var key in vm.$slots) {
        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
      }
    }

    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;

    if (staticRenderFns && !vm._staticTrees) {
      vm._staticTrees = [];
    }
    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render function");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        vnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode;
  };

  // internal render helpers.
  // these are exposed on the instance prototype to reduce generated render
  // code size.
  Vue.prototype._o = markOnce;
  Vue.prototype._n = toNumber;
  Vue.prototype._s = _toString;
  Vue.prototype._l = renderList;
  Vue.prototype._t = renderSlot;
  Vue.prototype._q = looseEqual;
  Vue.prototype._i = looseIndexOf;
  Vue.prototype._m = renderStatic;
  Vue.prototype._f = resolveFilter;
  Vue.prototype._k = checkKeyCodes;
  Vue.prototype._b = bindObjectProps;
  Vue.prototype._v = createTextVNode;
  Vue.prototype._e = createEmptyVNode;
  Vue.prototype._u = resolveScopedSlots;
}

/*  */

function initProvide(vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var inject = vm.$options.inject;
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    // isArray here
    var isArray = Array.isArray(inject);
    var keys = isArray ? inject : hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = isArray ? key : inject[key];
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          vm[key] = source._provided[provideKey];
          break;
        }
        source = source.$parent;
      }
    }
  }
}

/*  */

var uid = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      mark('vue-perf-init');
    }

    var vm = this;
    // a uid
    vm._uid = uid++;
    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark('vue-perf-init-end');
      measure(vm._name + " init", 'vue-perf-init', 'vue-perf-init-end');
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  opts.parent = options.parent;
  opts.propsData = options.propsData;
  opts._parentVnode = options._parentVnode;
  opts._parentListeners = options._parentListeners;
  opts._renderChildren = options._renderChildren;
  opts._componentTag = options._componentTag;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }
      modified[key] = dedupe(latest[key], sealed[key]);
    }
  }
  return modified;
}

function dedupe(latest, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    for (var i = 0; i < latest.length; i++) {
      if (sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res;
  } else {
    return latest;
  }
}

function Vue$3(options) {
  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue$3)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    /* istanbul ignore if */
    if (plugin.installed) {
      return;
    }
    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    plugin.installed = true;
    return this;
  };
}

/*  */

function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
  };
}

/*  */

function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;
    if (process.env.NODE_ENV !== 'production') {
      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
      }
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    config._assetTypes.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  config._assetTypes.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production') {
          if (type === 'component' && config.isReservedTag(id)) {
            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
          }
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}

/*  */

var patternTypes = [String, RegExp];

function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (pattern instanceof RegExp) {
    return pattern.test(name);
  }
  /* istanbul ignore next */
  return false;
}

function pruneCache(cache, filter) {
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cachedNode);
        cache[key] = null;
      }
    }
  }
}

function pruneCacheEntry(vnode) {
  if (vnode) {
    if (!vnode.componentInstance._inactive) {
      callHook(vnode.componentInstance, 'deactivated');
    }
    vnode.componentInstance.$destroy();
  }
}

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes
  },

  created: function created() {
    this.cache = Object.create(null);
  },

  destroyed: function destroyed() {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache[key]);
    }
  },

  watch: {
    include: function include(val) {
      pruneCache(this.cache, function (name) {
        return matches(val, name);
      });
    },
    exclude: function exclude(val) {
      pruneCache(this.cache, function (name) {
        return !matches(val, name);
      });
    }
  },

  render: function render() {
    var vnode = getFirstComponentChild(this.$slots.default);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      if (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {
        return vnode;
      }
      var key = vnode.key == null
      // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
      if (this.cache[key]) {
        vnode.componentInstance = this.cache[key].componentInstance;
      } else {
        this.cache[key] = vnode;
      }
      vnode.data.keepAlive = true;
    }
    return vnode;
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};
  configDef.get = function () {
    return config;
  };
  if (process.env.NODE_ENV !== 'production') {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  config._assetTypes.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Vue$3.version = '2.2.4';

/*  */

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select');
var mustUseProp = function mustUseProp(tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function isXlink(name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function getXlinkProp(name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function isFalsyAttrValue(val) {
  return val == null || val === false;
};

/*  */

function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (childNode.componentInstance) {
    childNode = childNode.componentInstance._vnode;
    if (childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (parentNode = parentNode.parent) {
    if (parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return genClassFromData(data);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: child.class ? [child.class, parent.class] : parent.class
  };
}

function genClassFromData(data) {
  var dynamicClass = data.class;
  var staticClass = data.staticClass;
  if (staticClass || dynamicClass) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */
  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  var res = '';
  if (!value) {
    return res;
  }
  if (typeof value === 'string') {
    return value;
  }
  if (Array.isArray(value)) {
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
      if (value[i]) {
        if (stringified = stringifyClass(value[i])) {
          res += stringified + ' ';
        }
      }
    }
    return res.slice(0, -1);
  }
  if (isObject(value)) {
    for (var key in value) {
      if (value[key]) {
        res += key + ' ';
      }
    }
    return res.slice(0, -1);
  }
  /* istanbul ignore next */
  return res;
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template');

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isPreTag = function isPreTag(tag) {
  return tag === 'pre';
};

var isReservedTag = function isReservedTag(tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }
  if (isReservedTag(tag)) {
    return false;
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);
      return document.createElement('div');
    }
    return selected;
  } else {
    return el;
  }
}

/*  */

function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm;
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setAttribute(node, key, val) {
  node.setAttribute(key, val);
}

var nodeOps = Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {
        refs[key].push(ref);
      } else {
        refs[key] = [ref];
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *

/*
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function isUndef(s) {
  return s == null;
}

function isDef(s) {
  return s != null;
}

function sameVnode(vnode1, vnode2) {
  return vnode1.key === vnode2.key && vnode1.tag === vnode2.tag && vnode1.isComment === vnode2.isComment && !vnode1.data === !vnode2.data;
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) {
      map[key] = i;
    }
  }
  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (modules[j][hooks[i]] !== undefined) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (parent) {
      nodeOps.removeChild(parent, el);
    }
  }

  var inPre = 0;
  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (process.env.NODE_ENV !== 'production') {
        if (data && data.pre) {
          inPre++;
        }
        if (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }
      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
        inPre--;
      }
    } else if (vnode.isComment) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isReactivated) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (vnode.data.pendingInsert) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break;
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref) {
    if (parent) {
      if (ref) {
        nodeOps.insertBefore(parent, elm, ref);
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (i.create) {
        i.create(emptyNode, vnode);
      }
      if (i.insert) {
        insertedVnodeQueue.push(vnode);
      }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope(vnode) {
    var i;
    var ancestor = vnode;
    while (ancestor) {
      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
        nodeOps.setAttribute(vnode.elm, i, '');
      }
      ancestor = ancestor.parent;
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }
      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (rm || isDef(vnode.data)) {
      var listeners = cbs.remove.length + 1;
      if (!rm) {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      } else {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, elmToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          elmToMove = oldCh[idxInOld];
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !elmToMove) {
            warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');
          }
          if (sameVnode(elmToMove, newStartVnode)) {
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          }
        }
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }
    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (vnode.isStatic && oldVnode.isStatic && vnode.key === oldVnode.key && (vnode.isCloned || vnode.isOnce)) {
      vnode.elm = oldVnode.elm;
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }
    var i;
    var data = vnode.data;
    var hasData = isDef(data);
    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }
    var elm = vnode.elm = oldVnode.elm;
    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (hasData && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }
      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (hasData) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (initial && vnode.parent) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var bailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate(elm, vnode, insertedVnodeQueue) {
    if (process.env.NODE_ENV !== 'production') {
      if (!assertNodeMatch(elm, vnode)) {
        return false;
      }
    }
    vnode.elm = elm;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true /* hydrating */);
      }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          var childrenMatch = true;
          var childNode = elm.firstChild;
          for (var i$1 = 0; i$1 < children.length; i$1++) {
            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
              childrenMatch = false;
              break;
            }
            childNode = childNode.nextSibling;
          }
          // if childNode is not null, it means the actual childNodes list is
          // longer than the virtual children list.
          if (!childrenMatch || childNode) {
            if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !bailed) {
              bailed = true;
              console.warn('Parent: ', elm);
              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
            }
            return false;
          }
        }
      }
      if (isDef(data)) {
        for (var key in data) {
          if (!isRenderedModule(key)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true;
  }

  function assertNodeMatch(node, vnode) {
    if (vnode.tag) {
      return vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (!vnode) {
      if (oldVnode) {
        invokeDestroyHook(oldVnode);
      }
      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (!oldVnode) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
            oldVnode.removeAttribute('server-rendered');
            hydrating = true;
          }
          if (hydrating) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (process.env.NODE_ENV !== 'production') {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }
        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);
        createElm(vnode, insertedVnodeQueue,
        // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));

        if (vnode.parent) {
          // component root element replaced.
          // update parent placeholder node element, recursively
          var ancestor = vnode.parent;
          while (ancestor) {
            ancestor.elm = vnode.elm;
            ancestor = ancestor.parent;
          }
          if (isPatchable(vnode)) {
            for (var i = 0; i < cbs.create.length; ++i) {
              cbs.create[i](emptyNode, vnode.parent);
            }
          }
        }

        if (parentElm$1 !== null) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function callInsert() {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);
  if (!dirs) {
    return res;
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
  }
}

var baseModules = [ref, directives];

/*  */

function updateAttrs(oldVnode, vnode) {
  if (!oldVnode.data.attrs && !vnode.data.attrs) {
    return;
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (attrs.__ob__) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  /* istanbul ignore if */
  if (isIE9 && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (attrs[key] == null) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, key);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, value);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (!data.staticClass && !data.class && (!oldData || !oldData.staticClass && !oldData.class)) {
    return;
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (transitionClass) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters(exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) {
        inSingle = false;
      }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) {
        inDouble = false;
      }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) {
        inTemplateString = false;
      }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) {
        inRegex = false;
      }
    } else if (c === 0x7C && // pipe
    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;break; // "
        case 0x27:
          inSingle = true;break; // '
        case 0x60:
          inTemplateString = true;break; // `
        case 0x28:
          paren++;break; // (
        case 0x29:
          paren--;break; // )
        case 0x5B:
          square++;break; // [
        case 0x5D:
          square--;break; // ]
        case 0x7B:
          curly++;break; // {
        case 0x7D:
          curly--;break; // }
      }
      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0;
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') {
            break;
          }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression;
}

function wrapFilter(exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return "_f(\"" + filter + "\")(" + exp + ")";
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return "_f(\"" + name + "\")(" + exp + "," + args;
  }
}

/*  */

function baseWarn(msg) {
  console.error("[Vue compiler]: " + msg);
}

function pluckModuleFunction(modules, key) {
  return modules ? modules.map(function (m) {
    return m[key];
  }).filter(function (_) {
    return _;
  }) : [];
}

function addProp(el, name, value) {
  (el.props || (el.props = [])).push({ name: name, value: value });
}

function addAttr(el, name, value) {
  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
}

function addDirective(el, name, rawName, value, arg, modifiers) {
  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
}

function addHandler(el, name, value, modifiers, important) {
  // check capture modifier
  if (modifiers && modifiers.capture) {
    delete modifiers.capture;
    name = '!' + name; // mark the event as captured
  }
  if (modifiers && modifiers.once) {
    delete modifiers.once;
    name = '~' + name; // mark the event as once
  }
  var events;
  if (modifiers && modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }
  var newHandler = { value: value, modifiers: modifiers };
  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }
}

function getBindingAttr(el, name, getStatic) {
  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue);
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue);
    }
  }
}

function getAndRemoveAttr(el, name) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break;
      }
    }
  }
  return val;
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel(el, value, modifiers) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: "(" + value + ")",
    expression: "\"" + value + "\"",
    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode(value, assignment) {
  var modelRs = parseModel(value);
  if (modelRs.idx === null) {
    return value + "=" + assignment;
  } else {
    return "var $$exp = " + modelRs.exp + ", $$idx = " + modelRs.idx + ";" + "if (!Array.isArray($$exp)){" + value + "=" + assignment + "}" + "else{$$exp.splice($$idx, 1, " + assignment + ")}";
  }
}

/**
 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
 *
 * for loop possible cases:
 *
 * - test
 * - test[idx]
 * - test[test1[idx]]
 * - test["a"][idx]
 * - xxx.test[a[a].test1[idx]]
 * - test.xxx.a["asa"][test1[idx]]
 *
 */

var len;
var str;
var chr;
var index$1;
var expressionPos;
var expressionEndPos;

function parseModel(val) {
  str = val;
  len = str.length;
  index$1 = expressionPos = expressionEndPos = 0;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    return {
      exp: val,
      idx: null
    };
  }

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.substring(0, expressionPos),
    idx: val.substring(expressionPos + 1, expressionEndPos)
  };
}

function next() {
  return str.charCodeAt(++index$1);
}

function eof() {
  return index$1 >= len;
}

function isStringStart(chr) {
  return chr === 0x22 || chr === 0x27;
}

function parseBracket(chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue;
    }
    if (chr === 0x5B) {
      inBracket++;
    }
    if (chr === 0x5D) {
      inBracket--;
    }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break;
    }
  }
}

function parseString(chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break;
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model(el, dir, _warn) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (process.env.NODE_ENV !== 'production') {
    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
    if (tag === 'input' && dynamicType) {
      warn$1("<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" + "v-model does not support dynamic input types. Use v-if branches instead.");
    }
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.");
    }
  }

  if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false;
  } else if (process.env.NODE_ENV !== 'production') {
    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');
  }

  // ensure runtime directive metadata
  return true;
}

function genCheckboxModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
  addHandler(el, CHECKBOX_RADIO_TOKEN, "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$c){$$i<0&&(" + value + "=$$a.concat($$v))}" + "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" + "}else{" + value + "=$$c}", null, true);
}

function genRadioModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);
}

function genSelect(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + genAssignmentCode(value, assignment);
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel(el, value, modifiers) {
  var type = el.attrsMap.type;
  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', "(" + value + ")");
  addHandler(el, event, code, null, true);
  if (trim || number || type === 'number') {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents(on) {
  var event;
  /* istanbul ignore if */
  if (on[RANGE_TOKEN]) {
    // IE input[type=range] only supports `change` event
    event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  if (on[CHECKBOX_RADIO_TOKEN]) {
    // Chrome fires microtasks in between click/change, leads to #4521
    event = isChrome ? 'click' : 'change';
    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function add$1(event, _handler, once, capture) {
  if (once) {
    var oldHandler = _handler;
    var _target = target$1; // save current target element in closure
    _handler = function handler(ev) {
      var res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, _handler, capture, _target);
      }
    };
  }
  target$1.addEventListener(event, _handler, capture);
}

function remove$2(event, handler, capture, _target) {
  (_target || target$1).removeEventListener(event, handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (!oldVnode.data.on && !vnode.data.on) {
    return;
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

function updateDOMProps(oldVnode, vnode) {
  if (!oldVnode.data.domProps && !vnode.data.domProps) {
    return;
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (props.__ob__) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (props[key] == null) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }
      if (cur === oldProps[key]) {
        continue;
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = cur == null ? '' : String(cur);
      if (shouldUpdateValue(elm, vnode, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, vnode, checkVal) {
  return !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));
}

function isDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value
  return document.activeElement !== elm && elm.value !== checkVal;
}

function isInputChanged(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (modifiers && modifiers.number || elm.type === 'number') {
    return toNumber(value) !== toNumber(newVal);
  }
  if (modifiers && modifiers.trim) {
    return value.trim() !== newVal.trim();
  }
  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle ? extend(data.staticStyle, style) : style;
}

// normalize possible array / string values into Object
function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }
  return bindingStyle;
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res;
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function setProp(el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    el.style[normalize(name)] = val;
  }
};

var prefixes = ['Webkit', 'Moz', 'ms'];

var testEl;
var normalize = cached(function (prop) {
  testEl = testEl || document.createElement('div');
  prop = camelize(prop);
  if (prop !== 'filter' && prop in testEl.style) {
    return prop;
  }
  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < prefixes.length; i++) {
    var prefixed = prefixes[i] + upper;
    if (prefixed in testEl.style) {
      return prefixed;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (!data.staticStyle && !data.style && !oldData.staticStyle && !oldData.style) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldVnode.data.staticStyle;
  var oldStyleBinding = oldVnode.data.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  vnode.data.style = style.__ob__ ? extend({}, style) : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (newStyle[name] == null) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    el.setAttribute('class', cur.trim());
  }
}

/*  */

function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */
  if ((typeof def$$1 === 'undefined' ? 'undefined' : _typeof(def$$1)) === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  (el._transitionClasses || (el._transitionClasses = [])).push(cls);
  addClass(el, cls);
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) {
    return cb();
  }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function end() {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function onEnd(e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
}

function toMs(s) {
  return Number(s.slice(0, -1)) * 1000;
}

/*  */

function enter(vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (el._leaveCb) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (!data) {
    return;
  }

  /* istanbul ignore if */
  if (el._enterCb || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;

  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;

  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      addTransitionClass(el, toClass);
      removeTransitionClass(el, startClass);
      if (!cb.cancelled && !userWantsControl) {
        if (isValidDuration(explicitEnterDuration)) {
          setTimeout(cb, explicitEnterDuration);
        } else {
          whenTransitionEnds(el, type, cb);
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (el._enterCb) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (!data) {
    return rm();
  }

  /* istanbul ignore if */
  if (el._leaveCb || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if (process.env.NODE_ENV !== 'production' && explicitLeaveDuration != null) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        addTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitLeaveDuration)) {
            setTimeout(cb, explicitLeaveDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength(fn) {
  if (!fn) {
    return false;
  }
  var invokerFns = fn.fns;
  if (invokerFns) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (!vnode.data.show) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (!vnode.data.show) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [attrs, klass, events, domProps, style, transition];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var model$1 = {
  inserted: function inserted(el, binding, vnode) {
    if (vnode.tag === 'select') {
      var cb = function cb() {
        setSelected(el, binding, vnode.context);
      };
      cb();
      /* istanbul ignore if */
      if (isIE || isEdge) {
        setTimeout(cb, 0);
      }
    } else if (vnode.tag === 'textarea' || el.type === 'text') {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        if (!isAndroid) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
        }
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var needReset = el.multiple ? binding.value.some(function (v) {
        return hasNoMatchingOption(v, el.options);
      }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
      if (needReset) {
        trigger(el, 'change');
      }
    }
  }
};

function setSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    process.env.NODE_ENV !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return;
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  for (var i = 0, l = options.length; i < l; i++) {
    if (looseEqual(getValue(options[i]), value)) {
      return false;
    }
  }
  return true;
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
    if (value && transition && !isIE9) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (value === oldValue) {
      return;
    }
    vnode = locateNode(vnode);
    var transition = vnode.data && vnode.data.transition;
    if (transition && !isIE9) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: model$1,
  show: show
};

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data;
}

function placeholder(h, rawChild) {
  return (/\d-keep-alive$/.test(rawChild.tag) ? h('keep-alive') : null
  );
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render(h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return;
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) {
      return c.tag;
    });
    /* istanbul ignore if */
    if (!children.length) {
      return;
    }

    // warn multiple elements
    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode;

    // warn invalid mode
    if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) {
      return d.name === 'show';
    })) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        var delayedLeave;
        var performLeave = function performLeave() {
          delayedLeave();
        };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
        } else if (process.env.NODE_ENV !== 'production') {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },

  beforeUpdate: function beforeUpdate() {
    // force removing pass
    this.__patch__(this._vnode, this.kept, false, // hydrating
    true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    var body = document.body;
    var f = body.offsetHeight; // eslint-disable-line

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      if (this._hasMove != null) {
        return this._hasMove;
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue$3.options.directives, platformDirectives);
extend(Vue$3.options.components, platformComponents);

// install platform patch function
Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue$3.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
};

// devtools global hook
/* istanbul ignore next */
setTimeout(function () {
  if (config.devtools) {
    if (devtools) {
      devtools.emit('init', Vue$3);
    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
    }
  }
  if (process.env.NODE_ENV !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {
    console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
  }
}, 0);

/*  */

// check whether current browser encodes a char inside attribute values
function shouldDecode(content, encoded) {
  var div = document.createElement('div');
  div.innerHTML = "<div a=\"" + content + "\">";
  return div.innerHTML.indexOf(encoded) > 0;
}

// #3663
// IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;

/*  */

var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');

/*  */

var decoder;

function decode(html) {
  decoder = decoder || document.createElement('div');
  decoder.innerHTML = html;
  return decoder.textContent;
}

/**
 * Not type-checking this file because it's mostly vendor code.
 */

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */

// Regular Expressions for parsing tags and attributes
var singleAttrIdentifier = /([^\s"'<>/=]+)/;
var singleAttrAssign = /(?:=)/;
var singleAttrValues = [
// attr value double quotes
/"([^"]*)"+/.source,
// attr value, single quotes
/'([^']*)'+/.source,
// attr value, no quotes
/([^\s"'=<>`]+)/.source];
var attribute = new RegExp('^\\s*' + singleAttrIdentifier.source + '(?:\\s*(' + singleAttrAssign.source + ')' + '\\s*(?:' + singleAttrValues.join('|') + '))?');

// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
// but for Vue templates we can enforce a simple charset
var ncname = '[a-zA-Z_][\\w\\-\\.]*';
var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
var startTagOpen = new RegExp('^<' + qnameCapture);
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
var doctype = /^<!DOCTYPE [^>]+>/i;
var comment = /^<!--/;
var conditionalComment = /^<!\[/;

var IS_REGEX_CAPTURING_BROKEN = false;
'x'.replace(/x(.)?/g, function (m, g) {
  IS_REGEX_CAPTURING_BROKEN = g === '';
});

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n'
};
var encodedAttr = /&(?:lt|gt|quot|amp);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;

function decodeAttr(value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) {
    return decodingMap[match];
  });
}

function parseHTML(html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            advance(commentEnd + 3);
            continue;
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue;
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue;
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue;
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          continue;
        }
      }

      var text = void 0,
          rest$1 = void 0,
          next = void 0;
      if (textEnd >= 0) {
        rest$1 = html.slice(textEnd);
        while (!endTag.test(rest$1) && !startTagOpen.test(rest$1) && !comment.test(rest$1) && !conditionalComment.test(rest$1)) {
          // < in plain text, be forgiving and treat it as text
          next = rest$1.indexOf('<', 1);
          if (next < 0) {
            break;
          }
          textEnd += next;
          rest$1 = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
        advance(textEnd);
      }

      if (textEnd < 0) {
        text = html;
        html = '';
      }

      if (options.chars && text) {
        options.chars(text);
      }
    } else {
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var endTagLength = 0;
      var rest = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text.replace(/<!--([\s\S]*?)-->/g, '$1').replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (options.chars) {
          options.chars(text);
        }
        return '';
      });
      index += html.length - rest.length;
      html = rest;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {
        options.warn("Mal-formatted tag at end of template: \"" + html + "\"");
      }
      break;
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance(n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag() {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
        advance(attr[0].length);
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match;
      }
    }
  }

  function handleStartTag(match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
        if (args[3] === '') {
          delete args[3];
        }
        if (args[4] === '') {
          delete args[4];
        }
        if (args[5] === '') {
          delete args[5];
        }
      }
      var value = args[3] || args[4] || args[5] || '';
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, options.shouldDecodeNewlines)
      };
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag(tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) {
      start = index;
    }
    if (end == null) {
      end = index;
    }

    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
    }

    // Find the closest opened tag of the same type
    if (tagName) {
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break;
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if (process.env.NODE_ENV !== 'production' && (i > pos || !tagName) && options.warn) {
          options.warn("tag <" + stack[i].tag + "> has no matching end tag.");
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});

function parseText(text, delimiters) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return;
  }
  var tokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index;
  while (match = tagRE.exec(text)) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push("_s(" + exp + ")");
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    tokens.push(JSON.stringify(text.slice(lastIndex)));
  }
  return tokens.join('+');
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;

var argRE = /:(.*)$/;
var bindRE = /^:|^v-bind:/;
var modifierRE = /\.[^.]+/g;

var decodeHTMLCached = cached(decode);

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;

/**
 * Convert HTML string to AST.
 */
function parse(template, options) {
  warn$2 = options.warn || baseWarn;
  platformGetTagNamespace = options.getTagNamespace || no;
  platformMustUseProp = options.mustUseProp || no;
  platformIsPreTag = options.isPreTag || no;
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  transforms = pluckModuleFunction(options.modules, 'transformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce(msg) {
    if (!warned) {
      warned = true;
      warn$2(msg);
    }
  }

  function endPre(element) {
    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    start: function start(tag, attrs, unary) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = {
        type: 1,
        tag: tag,
        attrsList: attrs,
        attrsMap: makeAttrsMap(attrs),
        parent: currentParent,
        children: []
      };
      if (ns) {
        element.ns = ns;
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        process.env.NODE_ENV !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.');
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        preTransforms[i](element, options);
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else {
        processFor(element);
        processIf(element);
        processOnce(element);
        processKey(element);

        // determine whether this is a plain element after
        // removing structural attributes
        element.plain = !element.key && !attrs.length;

        processRef(element);
        processSlot(element);
        processComponent(element);
        for (var i$1 = 0; i$1 < transforms.length; i$1++) {
          transforms[i$1](element, options);
        }
        processAttrs(element);
      }

      function checkRootConstraints(el) {
        if (process.env.NODE_ENV !== 'production') {
          if (el.tag === 'slot' || el.tag === 'template') {
            warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.');
          }
          if (el.attrsMap.hasOwnProperty('v-for')) {
            warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');
          }
        }
      }

      // tree management
      if (!root) {
        root = element;
        checkRootConstraints(root);
      } else if (!stack.length) {
        // allow root elements with v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          checkRootConstraints(element);
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          });
        } else if (process.env.NODE_ENV !== 'production') {
          warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.");
        }
      }
      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent);
        } else if (element.slotScope) {
          // scoped slot
          currentParent.plain = false;
          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        } else {
          currentParent.children.push(element);
          element.parent = currentParent;
        }
      }
      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        endPre(element);
      }
      // apply post-transforms
      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
        postTransforms[i$2](element, options);
      }
    },

    end: function end() {
      // remove trailing whitespace
      var element = stack[stack.length - 1];
      var lastNode = element.children[element.children.length - 1];
      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
        element.children.pop();
      }
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      endPre(element);
    },

    chars: function chars(text) {
      if (!currentParent) {
        if (process.env.NODE_ENV !== 'production') {
          if (text === template) {
            warnOnce('Component template requires a root element, rather than just text.');
          } else if (text = text.trim()) {
            warnOnce("text \"" + text + "\" outside root element will be ignored.");
          }
        }
        return;
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
        return;
      }
      var children = currentParent.children;
      text = inPre || text.trim() ? decodeHTMLCached(text)
      // only preserve whitespace if its not right after a starting tag
      : preserveWhitespace && children.length ? ' ' : '';
      if (text) {
        var expression;
        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
          children.push({
            type: 2,
            expression: expression,
            text: text
          });
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          children.push({
            type: 3,
            text: text
          });
        }
      }
    }
  });
  return root;
}

function processPre(el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs(el) {
  var l = el.attrsList.length;
  if (l) {
    var attrs = el.attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      attrs[i] = {
        name: el.attrsList[i].name,
        value: JSON.stringify(el.attrsList[i].value)
      };
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processKey(el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {
      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
    }
    el.key = exp;
  }
}

function processRef(el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor(el) {
  var exp;
  if (exp = getAndRemoveAttr(el, 'v-for')) {
    var inMatch = exp.match(forAliasRE);
    if (!inMatch) {
      process.env.NODE_ENV !== 'production' && warn$2("Invalid v-for expression: " + exp);
      return;
    }
    el.for = inMatch[2].trim();
    var alias = inMatch[1].trim();
    var iteratorMatch = alias.match(forIteratorRE);
    if (iteratorMatch) {
      el.alias = iteratorMatch[1].trim();
      el.iterator1 = iteratorMatch[2].trim();
      if (iteratorMatch[3]) {
        el.iterator2 = iteratorMatch[3].trim();
      }
    } else {
      el.alias = alias;
    }
  }
}

function processIf(el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions(el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (process.env.NODE_ENV !== 'production') {
    warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.");
  }
}

function findPrevElement(children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i];
    } else {
      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {
        warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.");
      }
      children.pop();
    }
  }
}

function addIfCondition(el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce(el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

function processSlot(el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if (process.env.NODE_ENV !== 'production' && el.key) {
      warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.");
    }
  } else {
    var slotTarget = getBindingAttr(el, 'slot');
    if (slotTarget) {
      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    }
    if (el.tag === 'template') {
      el.slotScope = getAndRemoveAttr(el, 'scope');
    }
  }
}

function processComponent(el) {
  var binding;
  if (binding = getBindingAttr(el, 'is')) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs(el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, isProp;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name);
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) {
        // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isProp = false;
        if (modifiers) {
          if (modifiers.prop) {
            isProp = true;
            name = camelize(name);
            if (name === 'innerHtml') {
              name = 'innerHTML';
            }
          }
          if (modifiers.camel) {
            name = camelize(name);
          }
        }
        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, value);
        } else {
          addAttr(el, name, value);
        }
      } else if (onRE.test(name)) {
        // v-on
        name = name.replace(onRE, '');
        addHandler(el, name, value, modifiers);
      } else {
        // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
        }
        addDirective(el, name, rawName, value, arg, modifiers);
        if (process.env.NODE_ENV !== 'production' && name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (process.env.NODE_ENV !== 'production') {
        var expression = parseText(value, delimiters);
        if (expression) {
          warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.');
        }
      }
      addAttr(el, name, JSON.stringify(value));
    }
  }
}

function checkInFor(el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true;
    }
    parent = parent.parent;
  }
  return false;
}

function parseModifiers(name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) {
      ret[m.slice(1)] = true;
    });
    return ret;
  }
}

function makeAttrsMap(attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE) {
      warn$2('duplicate attribute: ' + attrs[i].name);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map;
}

function isForbiddenTag(el) {
  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug(attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res;
}

function checkForAliasModel(el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.");
    }
    _el = _el.parent;
  }
}

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize(root, options) {
  if (!root) {
    return;
  }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1(keys) {
  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));
}

function markStatic$1(node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
      return;
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
  }
}

function markStaticRoots(node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
      node.staticRoot = true;
      return;
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      walkThroughConditionsBlocks(node.ifConditions, isInFor);
    }
  }
}

function walkThroughConditionsBlocks(conditionBlocks, isInFor) {
  for (var i = 1, len = conditionBlocks.length; i < len; i++) {
    markStaticRoots(conditionBlocks[i].block, isInFor);
  }
}

function isStatic(node) {
  if (node.type === 2) {
    // expression
    return false;
  }
  if (node.type === 3) {
    // text
    return true;
  }
  return !!(node.pre || !node.hasBindings && // no dynamic bindings
  !node.if && !node.for && // not v-if or v-for or v-else
  !isBuiltInTag(node.tag) && // not a built-in
  isPlatformReservedTag(node.tag) && // not a component
  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
}

function isDirectChildOfTemplateFor(node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false;
    }
    if (node.for) {
      return true;
    }
  }
  return false;
}

/*  */

var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

// keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function genGuard(condition) {
  return "if(" + condition + ")return null;";
};

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers(events, native) {
  var res = native ? 'nativeOn:{' : 'on:{';
  for (var name in events) {
    res += "\"" + name + "\":" + genHandler(name, events[name]) + ",";
  }
  return res.slice(0, -1) + '}';
}

function genHandler(name, handler) {
  if (!handler) {
    return 'function(){}';
  }

  if (Array.isArray(handler)) {
    return "[" + handler.map(function (handler) {
      return genHandler(name, handler);
    }).join(',') + "]";
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);

  if (!handler.modifiers) {
    return isMethodPath || isFunctionExpression ? handler.value : "function($event){" + handler.value + "}"; // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? "(" + handler.value + ")($event)" : handler.value;
    return "function($event){" + code + handlerCode + "}";
  }
}

function genKeyFilter(keys) {
  return "if(!('button' in $event)&&" + keys.map(genFilterCode).join('&&') + ")return null;";
}

function genFilterCode(key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return "$event.keyCode!==" + keyVal;
  }
  var alias = keyCodes[key];
  return "_k($event.keyCode," + JSON.stringify(key) + (alias ? ',' + JSON.stringify(alias) : '') + ")";
}

/*  */

function bind$1(el, dir) {
  el.wrapData = function (code) {
    return "_b(" + code + ",'" + el.tag + "'," + dir.value + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + ")";
  };
}

/*  */

var baseDirectives = {
  bind: bind$1,
  cloak: noop
};

/*  */

// configurable state
var warn$3;
var transforms$1;
var dataGenFns;
var platformDirectives$1;
var isPlatformReservedTag$1;
var staticRenderFns;
var onceCount;
var currentOptions;

function generate(ast, options) {
  // save previous staticRenderFns so generate calls can be nested
  var prevStaticRenderFns = staticRenderFns;
  var currentStaticRenderFns = staticRenderFns = [];
  var prevOnceCount = onceCount;
  onceCount = 0;
  currentOptions = options;
  warn$3 = options.warn || baseWarn;
  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');
  dataGenFns = pluckModuleFunction(options.modules, 'genData');
  platformDirectives$1 = options.directives || {};
  isPlatformReservedTag$1 = options.isReservedTag || no;
  var code = ast ? genElement(ast) : '_c("div")';
  staticRenderFns = prevStaticRenderFns;
  onceCount = prevOnceCount;
  return {
    render: "with(this){return " + code + "}",
    staticRenderFns: currentStaticRenderFns
  };
}

function genElement(el) {
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el);
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el);
  } else if (el.for && !el.forProcessed) {
    return genFor(el);
  } else if (el.if && !el.ifProcessed) {
    return genIf(el);
  } else if (el.tag === 'template' && !el.slotTarget) {
    return genChildren(el) || 'void 0';
  } else if (el.tag === 'slot') {
    return genSlot(el);
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el);
    } else {
      var data = el.plain ? undefined : genData(el);

      var children = el.inlineTemplate ? null : genChildren(el, true);
      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
    }
    // module transforms
    for (var i = 0; i < transforms$1.length; i++) {
      code = transforms$1[i](el, code);
    }
    return code;
  }
}

// hoist static sub-trees out
function genStatic(el) {
  el.staticProcessed = true;
  staticRenderFns.push("with(this){return " + genElement(el) + "}");
  return "_m(" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
}

// v-once
function genOnce(el) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el);
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break;
      }
      parent = parent.parent;
    }
    if (!key) {
      process.env.NODE_ENV !== 'production' && warn$3("v-once can only be used inside v-for that is keyed. ");
      return genElement(el);
    }
    return "_o(" + genElement(el) + "," + onceCount++ + (key ? "," + key : "") + ")";
  } else {
    return genStatic(el);
  }
}

function genIf(el) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice());
}

function genIfConditions(conditions) {
  if (!conditions.length) {
    return '_e()';
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions);
  } else {
    return "" + genTernaryExp(condition.block);
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp(el) {
    return el.once ? genOnce(el) : genElement(el);
  }
}

function genFor(el) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

  if (process.env.NODE_ENV !== 'production' && maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
    warn$3("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return "_l((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + genElement(el) + '})';
}

function genData(el) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el);
  if (dirs) {
    data += dirs + ',';
  }

  // key
  if (el.key) {
    data += "key:" + el.key + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + el.ref + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + el.tag + "\",";
  }
  // module data generation functions
  for (var i = 0; i < dataGenFns.length; i++) {
    data += dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:{" + genProps(el.attrs) + "},";
  }
  // DOM props
  if (el.props) {
    data += "domProps:{" + genProps(el.props) + "},";
  }
  // event handlers
  if (el.events) {
    data += genHandlers(el.events) + ",";
  }
  if (el.nativeEvents) {
    data += genHandlers(el.nativeEvents, true) + ",";
  }
  // slot target
  if (el.slotTarget) {
    data += "slot:" + el.slotTarget + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += genScopedSlots(el.scopedSlots) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  return data;
}

function genDirectives(el) {
  var dirs = el.directives;
  if (!dirs) {
    return;
  }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, warn$3);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:\"" + dir.arg + "\"" : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']';
  }
}

function genInlineTemplate(el) {
  var ast = el.children[0];
  if (process.env.NODE_ENV !== 'production' && (el.children.length > 1 || ast.type !== 1)) {
    warn$3('Inline-template components must have exactly one child element.');
  }
  if (ast.type === 1) {
    var inlineRenderFns = generate(ast, currentOptions);
    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
      return "function(){" + code + "}";
    }).join(',') + "]}";
  }
}

function genScopedSlots(slots) {
  return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
    return genScopedSlot(key, slots[key]);
  }).join(',') + "])";
}

function genScopedSlot(key, el) {
  return "[" + key + ",function(" + String(el.attrsMap.scope) + "){" + "return " + (el.tag === 'template' ? genChildren(el) || 'void 0' : genElement(el)) + "}]";
}

function genChildren(el, checkSkip) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
      return genElement(el$1);
    }
    var normalizationType = checkSkip ? getNormalizationType(children) : 0;
    return "[" + children.map(genNode).join(',') + "]" + (normalizationType ? "," + normalizationType : '');
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType(children) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue;
    }
    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return needsNormalization(c.block);
    })) {
      res = 2;
      break;
    }
    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return maybeComponent(c.block);
    })) {
      res = 1;
    }
  }
  return res;
}

function needsNormalization(el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}

function maybeComponent(el) {
  return !isPlatformReservedTag$1(el.tag);
}

function genNode(node) {
  if (node.type === 1) {
    return genElement(node);
  } else {
    return genText(node);
  }
}

function genText(text) {
  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
}

function genSlot(el) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el);
  var res = "_t(" + slotName + (children ? "," + children : '');
  var attrs = el.attrs && "{" + el.attrs.map(function (a) {
    return camelize(a.name) + ":" + a.value;
  }).join(',') + "}";
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')';
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent(componentName, el) {
  var children = el.inlineTemplate ? null : genChildren(el, true);
  return "_c(" + componentName + "," + genData(el) + (children ? "," + children : '') + ")";
}

function genProps(props) {
  var res = '';
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    res += "\"" + prop.name + "\":" + transformSpecialNewlines(prop.value) + ",";
  }
  return res.slice(0, -1);
}

// #3895, #4268
function transformSpecialNewlines(text) {
  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}

/*  */

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// check valid identifier for v-for
var identRE = /[A-Za-z_$][\w$]*/;

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors(ast) {
  var errors = [];
  if (ast) {
    checkNode(ast, errors);
  }
  return errors;
}

function checkNode(node, errors) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          if (name === 'v-for') {
            checkFor(node, "v-for=\"" + value + "\"", errors);
          } else if (onRE.test(name)) {
            checkEvent(value, name + "=\"" + value + "\"", errors);
          } else {
            checkExpression(value, name + "=\"" + value + "\"", errors);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], errors);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, errors);
  }
}

function checkEvent(exp, text, errors) {
  var keywordMatch = exp.replace(stripStringRE, '').match(unaryOperatorsRE);
  if (keywordMatch) {
    errors.push("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
  }
  checkExpression(exp, text, errors);
}

function checkFor(node, text, errors) {
  checkExpression(node.for || '', text, errors);
  checkIdentifier(node.alias, 'v-for alias', text, errors);
  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
}

function checkIdentifier(ident, type, text, errors) {
  if (typeof ident === 'string' && !identRE.test(ident)) {
    errors.push("invalid " + type + " \"" + ident + "\" in expression: " + text.trim());
  }
}

function checkExpression(exp, text, errors) {
  try {
    new Function("return " + exp);
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      errors.push("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
    } else {
      errors.push("invalid expression: " + text.trim());
    }
  }
}

/*  */

function baseCompile(template, options) {
  var ast = parse(template.trim(), options);
  optimize(ast, options);
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  };
}

function makeFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop;
  }
}

function createCompiler(baseOptions) {
  var functionCompileCache = Object.create(null);

  function compile(template, options) {
    var finalOptions = Object.create(baseOptions);
    var errors = [];
    var tips = [];
    finalOptions.warn = function (msg, tip$$1) {
      (tip$$1 ? tips : errors).push(msg);
    };

    if (options) {
      // merge custom modules
      if (options.modules) {
        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
      }
      // merge custom directives
      if (options.directives) {
        finalOptions.directives = extend(Object.create(baseOptions.directives), options.directives);
      }
      // copy other options
      for (var key in options) {
        if (key !== 'modules' && key !== 'directives') {
          finalOptions[key] = options[key];
        }
      }
    }

    var compiled = baseCompile(template, finalOptions);
    if (process.env.NODE_ENV !== 'production') {
      errors.push.apply(errors, detectErrors(compiled.ast));
    }
    compiled.errors = errors;
    compiled.tips = tips;
    return compiled;
  }

  function compileToFunctions(template, options, vm) {
    options = options || {};

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
        }
      }
    }

    // check cache
    var key = options.delimiters ? String(options.delimiters) + template : template;
    if (functionCompileCache[key]) {
      return functionCompileCache[key];
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    if (process.env.NODE_ENV !== 'production') {
      if (compiled.errors && compiled.errors.length) {
        warn("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
          return "- " + e;
        }).join('\n') + '\n', vm);
      }
      if (compiled.tips && compiled.tips.length) {
        compiled.tips.forEach(function (msg) {
          return tip(msg, vm);
        });
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = makeFunction(compiled.render, fnGenErrors);
    var l = compiled.staticRenderFns.length;
    res.staticRenderFns = new Array(l);
    for (var i = 0; i < l; i++) {
      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);
    }

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
          var err = ref.err;
          var code = ref.code;

          return err.toString() + " in\n\n" + code + "\n";
        }).join('\n'), vm);
      }
    }

    return functionCompileCache[key] = res;
  }

  return {
    compile: compile,
    compileToFunctions: compileToFunctions
  };
}

/*  */

function transformNode(el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if (process.env.NODE_ENV !== 'production' && staticClass) {
    var expression = parseText(staticClass, options.delimiters);
    if (expression) {
      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.');
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData$1(el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + el.staticClass + ",";
  }
  if (el.classBinding) {
    data += "class:" + el.classBinding + ",";
  }
  return data;
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData$1
};

/*  */

function transformNode$1(el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      var expression = parseText(staticStyle, options.delimiters);
      if (expression) {
        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.');
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$2(el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + el.staticStyle + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + el.styleBinding + "),";
  }
  return data;
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$2
};

var modules$1 = [klass$1, style$1];

/*  */

function text(el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', "_s(" + dir.value + ")");
  }
}

/*  */

function html(el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', "_s(" + dir.value + ")");
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

var ref$1 = createCompiler(baseOptions);
var compileToFunctions = ref$1.compileToFunctions;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML;
});

var mount = Vue$3.prototype.$mount;
Vue$3.prototype.$mount = function (el, hydrating) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
    return this;
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn("Template element not found or is empty: " + options.template, this);
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this);
        }
        return this;
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        shouldDecodeNewlines: shouldDecodeNewlines,
        delimiters: options.delimiters
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end');
        measure(this._name + " compile", 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating);
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML(el) {
  if (el.outerHTML) {
    return el.outerHTML;
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML;
  }
}

Vue$3.compile = compileToFunctions;

exports.default = Vue$3;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(9)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(3);

// Load library
H5P.Feedback = __webpack_require__(2).default;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(0)(
  /* script */
  __webpack_require__(4),
  /* template */
  __webpack_require__(15),
  /* scopeId */
  null,
  /* cssModules */
  null
)
Component.options.__file = "/home/tomaj/code/joubel/content-types/h5p-feedback/src/scripts/views/Final.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key !== "__esModule"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] Final.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-5c2bb111", Component.options)
  } else {
    hotAPI.reload("data-v-5c2bb111", Component.options)
  }
})()}

module.exports = Component.exports


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(0)(
  /* script */
  __webpack_require__(5),
  /* template */
  __webpack_require__(14),
  /* scopeId */
  null,
  /* cssModules */
  null
)
Component.options.__file = "/home/tomaj/code/joubel/content-types/h5p-feedback/src/scripts/views/ScoreInput.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key !== "__esModule"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] ScoreInput.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4903dccd", Component.options)
  } else {
    hotAPI.reload("data-v-4903dccd", Component.options)
  }
})()}

module.exports = Component.exports


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(0)(
  /* script */
  __webpack_require__(6),
  /* template */
  __webpack_require__(16),
  /* scopeId */
  null,
  /* cssModules */
  null
)
Component.options.__file = "/home/tomaj/code/joubel/content-types/h5p-feedback/src/scripts/views/TextInput.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key !== "__esModule"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] TextInput.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-6315a138", Component.options)
  } else {
    hotAPI.reload("data-v-6315a138", Component.options)
  }
})()}

module.exports = Component.exports


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "h5p-feedback-score",
    attrs: {
      "role": "region"
    }
  }, [_c('h3', {
    staticClass: "feedback-title",
    domProps: {
      "innerHTML": _vm._s(_vm.message)
    }
  }), _c('ul', {
    staticClass: "feedback-score-input"
  }, _vm._l((_vm.alternatives), function(alternative) {
    return _c('li', [_c('div', {
      class: alternative.cls,
      attrs: {
        "role": "button"
      },
      on: {
        "click": function($event) {
          _vm.sendScore(alternative)
        }
      }
    }, [_c('div', {
      staticClass: "feedback-score-title"
    }, [_vm._v(_vm._s(alternative.title))])])])
  }))])
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-4903dccd", module.exports)
  }
}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _vm._m(0)
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "h5p-feedback-final",
    attrs: {
      "role": "region"
    }
  }, [_c('p', [_vm._v("We put a lot of effort into making H5P easy to use for all!")]), _c('h3', [_vm._v("Your feedback is highly appreciated!")])])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-5c2bb111", module.exports)
  }
}

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "h5p-feedback-text",
    attrs: {
      "role": "region"
    }
  }, [_c('div', {
    staticClass: "feedback-score",
    class: _vm.alternative.cls
  }), _c('p', [_vm._v(_vm._s(this.alternative.title))]), _c('router-link', {
    attrs: {
      "to": "/score-input"
    }
  }, [_vm._v("Change")]), _c('h3', [_vm._v("Thanks for the rating!")]), _vm._m(0), _c('textarea', {
    attrs: {
      "rows": "4",
      "placeholder": "Your Feedback"
    }
  }), _c('button', {
    on: {
      "click": function($event) {
        _vm.sendText()
      }
    }
  }, [_vm._v("Send")])], 1)
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('p', [_vm._v("Let us know how we can improve your experience with the "), _c('strong', [_vm._v("Drag Text")]), _vm._v(" authoring tool.")])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-6315a138", module.exports)
  }
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNjFhZmZiZmI5NmY5NzFjYzZkODkiLCJ3ZWJwYWNrOi8vLy4vfi92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9mZWVkYmFjay5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL21haW4uc2Nzcz8zN2ZjIiwid2VicGFjazovLy9GaW5hbC52dWUiLCJ3ZWJwYWNrOi8vL1Njb3JlSW5wdXQudnVlIiwid2VicGFjazovLy9UZXh0SW5wdXQudnVlIiwid2VicGFjazovLy8uL34vdnVlLXJvdXRlci9kaXN0L3Z1ZS1yb3V0ZXIuZXNtLmpzIiwid2VicGFjazovLy8uL34vdnVlL2Rpc3QvdnVlLmVzbS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL3NyYy9lbnRyaWVzL2Rpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvdmlld3MvRmluYWwudnVlIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3ZpZXdzL1Njb3JlSW5wdXQudnVlIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3ZpZXdzL1RleHRJbnB1dC52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvdmlld3MvU2NvcmVJbnB1dC52dWU/NTgxZiIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy92aWV3cy9GaW5hbC52dWU/MWU4MyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy92aWV3cy9UZXh0SW5wdXQudnVlPzVjNTciXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJlIiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImxlbmd0aCIsImNvbmNhdCIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwibGVuIiwicnVuIiwibmV4dFRpY2siLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJpIiwicHVzaCIsIkl0ZW0iLCJhcnJheSIsInByb3RvdHlwZSIsImFwcGx5IiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsImJpbmRpbmciLCJuYW1lIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayIsInVzZSIsIkZlZWRiYWNrIiwiY29uZmlnIiwiY29udGVudElkIiwiY29udGVudERhdGEiLCJhbHRlcm5hdGl2ZXMiLCJjbHMiLCJzY29yZSIsImRhdGEiLCJtZXNzYWdlIiwicm91dGVyIiwibW9kZSIsInJvdXRlcyIsInBhdGgiLCJjb21wb25lbnQiLCJwcm9wcyIsInZpZXdNb2RlbCIsImF0dGFjaCIsImVsZW1lbnQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpZCIsImNsYXNzTmFtZSIsImlubmVySFRNTCIsIiR3cmFwcGVyIiwiZ2V0IiwiYXBwZW5kQ2hpbGQiLCIkbW91bnQiLCJINVAiLCJFdmVudERpc3BhdGNoZXIiLCJhc3NlcnQiLCJjb25kaXRpb24iLCJ3YXJuIiwiY29uc29sZSIsIlZpZXciLCJmdW5jdGlvbmFsIiwidHlwZSIsIlN0cmluZyIsImRlZmF1bHQiLCJyZW5kZXIiLCJoIiwicmVmIiwiY2hpbGRyZW4iLCJwYXJlbnQiLCJyb3V0ZXJWaWV3Iiwicm91dGUiLCIkcm91dGUiLCJjYWNoZSIsIl9yb3V0ZXJWaWV3Q2FjaGUiLCJkZXB0aCIsImluYWN0aXZlIiwiJHZub2RlIiwiX2luYWN0aXZlIiwiJHBhcmVudCIsInJvdXRlclZpZXdEZXB0aCIsIm1hdGNoZWQiLCJjb21wb25lbnRzIiwiaG9va3MiLCJob29rIiwiaW5pdCIsInZub2RlIiwiaW5zdGFuY2VzIiwiY2hpbGQiLCJwcmVwYXRjaCIsIm9sZFZub2RlIiwiZGVzdHJveSIsInVuZGVmaW5lZCIsInJlc29sdmVQcm9wcyIsInBhcmFtcyIsImVuY29kZVJlc2VydmVSRSIsImVuY29kZVJlc2VydmVSZXBsYWNlciIsImMiLCJjaGFyQ29kZUF0IiwidG9TdHJpbmciLCJjb21tYVJFIiwiZW5jb2RlIiwic3RyIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVwbGFjZSIsImRlY29kZSIsImRlY29kZVVSSUNvbXBvbmVudCIsInJlc29sdmVRdWVyeSIsInF1ZXJ5IiwiZXh0cmFRdWVyeSIsInBhcnNlZFF1ZXJ5IiwicGFyc2VRdWVyeSIsIk5PREVfRU5WIiwia2V5IiwicmVzIiwidHJpbSIsInNwbGl0IiwiZm9yRWFjaCIsInBhcmFtIiwicGFydHMiLCJzaGlmdCIsInZhbCIsImpvaW4iLCJpc0FycmF5Iiwic3RyaW5naWZ5UXVlcnkiLCJvYmoiLCJPYmplY3QiLCJrZXlzIiwibWFwIiwicmVzdWx0Iiwic2xpY2UiLCJ2YWwyIiwiZmlsdGVyIiwieCIsInRyYWlsaW5nU2xhc2hSRSIsImNyZWF0ZVJvdXRlIiwicmVjb3JkIiwibG9jYXRpb24iLCJyZWRpcmVjdGVkRnJvbSIsIm1ldGEiLCJoYXNoIiwiZnVsbFBhdGgiLCJnZXRGdWxsUGF0aCIsImZvcm1hdE1hdGNoIiwiZnJlZXplIiwiU1RBUlQiLCJ1bnNoaWZ0IiwiaXNTYW1lUm91dGUiLCJhIiwiYiIsImlzT2JqZWN0RXF1YWwiLCJhS2V5cyIsImJLZXlzIiwiZXZlcnkiLCJpc0luY2x1ZGVkUm91dGUiLCJjdXJyZW50IiwidGFyZ2V0IiwiaW5kZXhPZiIsInF1ZXJ5SW5jbHVkZXMiLCJ0b1R5cGVzIiwiZXZlbnRUeXBlcyIsIkxpbmsiLCJ0byIsInJlcXVpcmVkIiwidGFnIiwiZXhhY3QiLCJCb29sZWFuIiwiYXBwZW5kIiwiYWN0aXZlQ2xhc3MiLCJldmVudCIsInRoaXMkMSIsIiRyb3V0ZXIiLCJyZXNvbHZlIiwiaHJlZiIsImNsYXNzZXMiLCJvcHRpb25zIiwibGlua0FjdGl2ZUNsYXNzIiwiY29tcGFyZVRhcmdldCIsImhhbmRsZXIiLCJndWFyZEV2ZW50IiwiY2xpY2siLCJjbGFzcyIsImF0dHJzIiwiZmluZEFuY2hvciIsIiRzbG90cyIsImlzU3RhdGljIiwiZXh0ZW5kIiwiX1Z1ZSIsInV0aWwiLCJhRGF0YSIsImFBdHRycyIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJkZWZhdWx0UHJldmVudGVkIiwiYnV0dG9uIiwiZ2V0QXR0cmlidXRlIiwidGVzdCIsInByZXZlbnREZWZhdWx0IiwiaW5zdGFsbCIsIlZ1ZSIsImluc3RhbGxlZCIsImRlZmluZVByb3BlcnR5IiwiJHJvb3QiLCJfcm91dGVyIiwiX3JvdXRlIiwibWl4aW4iLCJiZWZvcmVDcmVhdGUiLCIkb3B0aW9ucyIsImRlZmluZVJlYWN0aXZlIiwiaGlzdG9yeSIsInN0cmF0cyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsImJlZm9yZVJvdXRlRW50ZXIiLCJiZWZvcmVSb3V0ZUxlYXZlIiwiY3JlYXRlZCIsImluQnJvd3NlciIsIndpbmRvdyIsInJlc29sdmVQYXRoIiwicmVsYXRpdmUiLCJiYXNlIiwiY2hhckF0Iiwic3RhY2siLCJwb3AiLCJzZWdtZW50cyIsInNlZ21lbnQiLCJwYXJzZVBhdGgiLCJoYXNoSW5kZXgiLCJxdWVyeUluZGV4IiwiY2xlYW5QYXRoIiwiY3JlYXRlUm91dGVNYXAiLCJvbGRQYXRoTWFwIiwib2xkTmFtZU1hcCIsInBhdGhNYXAiLCJjcmVhdGUiLCJuYW1lTWFwIiwiYWRkUm91dGVSZWNvcmQiLCJtYXRjaEFzIiwibm9ybWFsaXplUGF0aCIsInJlZGlyZWN0IiwiYmVmb3JlRW50ZXIiLCJzb21lIiwiY2hpbGRNYXRjaEFzIiwiYWxpYXMiLCJhbGlhc1JvdXRlIiwiaW5kZXgkMSIsImFyciIsImlzYXJyYXkiLCJpbmRleCIsInBhdGhUb1JlZ2V4cCIsInBhcnNlXzEiLCJwYXJzZSIsImNvbXBpbGVfMSIsImNvbXBpbGUiLCJ0b2tlbnNUb0Z1bmN0aW9uXzEiLCJ0b2tlbnNUb0Z1bmN0aW9uIiwidG9rZW5zVG9SZWdFeHBfMSIsInRva2Vuc1RvUmVnRXhwIiwiUEFUSF9SRUdFWFAiLCJSZWdFeHAiLCJ0b2tlbnMiLCJkZWZhdWx0RGVsaW1pdGVyIiwiZGVsaW1pdGVyIiwiZXhlYyIsIm0iLCJlc2NhcGVkIiwib2Zmc2V0IiwibmV4dCIsInByZWZpeCIsImNhcHR1cmUiLCJncm91cCIsIm1vZGlmaWVyIiwiYXN0ZXJpc2siLCJwYXJ0aWFsIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJwYXR0ZXJuIiwiZXNjYXBlR3JvdXAiLCJlc2NhcGVTdHJpbmciLCJzdWJzdHIiLCJlbmNvZGVVUklDb21wb25lbnRQcmV0dHkiLCJlbmNvZGVVUkkiLCJ0b1VwcGVyQ2FzZSIsImVuY29kZUFzdGVyaXNrIiwibWF0Y2hlcyIsIm9wdHMiLCJwcmV0dHkiLCJ0b2tlbiIsInZhbHVlIiwiVHlwZUVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImoiLCJhdHRhY2hLZXlzIiwicmUiLCJmbGFncyIsInNlbnNpdGl2ZSIsInJlZ2V4cFRvUmVnZXhwIiwiZ3JvdXBzIiwic291cmNlIiwibWF0Y2giLCJhcnJheVRvUmVnZXhwIiwicmVnZXhwIiwic3RyaW5nVG9SZWdleHAiLCJzdHJpY3QiLCJlbmQiLCJlbmRzV2l0aERlbGltaXRlciIsInJlZ2V4cENhY2hlIiwiZ2V0Um91dGVSZWdleCIsImhpdCIsInJlZ2V4cENvbXBpbGVDYWNoZSIsImZpbGxQYXJhbXMiLCJyb3V0ZU1zZyIsImZpbGxlciIsIm5vcm1hbGl6ZUxvY2F0aW9uIiwicmF3IiwiX25vcm1hbGl6ZWQiLCJhc3NpZ24iLCJyYXdQYXRoIiwicGFyc2VkUGF0aCIsImJhc2VQYXRoIiwiY3JlYXRlTWF0Y2hlciIsImFkZFJvdXRlcyIsImN1cnJlbnRSb3V0ZSIsInBhcmFtTmFtZXMiLCJfY3JlYXRlUm91dGUiLCJtYXRjaFJvdXRlIiwib3JpZ2luYWxSZWRpcmVjdCIsImhhc093blByb3BlcnR5IiwidGFyZ2V0UmVjb3JkIiwicmVzb2x2ZVJlY29yZFBhdGgiLCJyZXNvbHZlZFBhdGgiLCJhbGlhc2VkUGF0aCIsImFsaWFzZWRNYXRjaCIsImFsaWFzZWRSZWNvcmQiLCJwYXRobmFtZSIsInBvc2l0aW9uU3RvcmUiLCJzZXR1cFNjcm9sbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJzYXZlU2Nyb2xsUG9zaXRpb24iLCJzdGF0ZSIsInNldFN0YXRlS2V5IiwiaGFuZGxlU2Nyb2xsIiwiZnJvbSIsImlzUG9wIiwiYXBwIiwiYmVoYXZpb3IiLCJzY3JvbGxCZWhhdmlvciIsIiRuZXh0VGljayIsInBvc2l0aW9uIiwiZ2V0U2Nyb2xsUG9zaXRpb24iLCJzaG91bGRTY3JvbGwiLCJpc09iamVjdCIsInNlbGVjdG9yIiwiZWwiLCJxdWVyeVNlbGVjdG9yIiwiZ2V0RWxlbWVudFBvc2l0aW9uIiwiaXNWYWxpZFBvc2l0aW9uIiwibm9ybWFsaXplUG9zaXRpb24iLCJzY3JvbGxUbyIsInkiLCJnZXRTdGF0ZUtleSIsInBhZ2VYT2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJkb2NFbCIsImRvY3VtZW50RWxlbWVudCIsImRvY1JlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJlbFJlY3QiLCJsZWZ0IiwidG9wIiwiaXNOdW1iZXIiLCJ2Iiwic3VwcG9ydHNQdXNoU3RhdGUiLCJ1YSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIlRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsIkRhdGUiLCJfa2V5IiwiZ2VuS2V5IiwidG9GaXhlZCIsInB1c2hTdGF0ZSIsInVybCIsInJlcGxhY2VTdGF0ZSIsInJ1blF1ZXVlIiwiZm4iLCJjYiIsInN0ZXAiLCJIaXN0b3J5Iiwibm9ybWFsaXplQmFzZSIsInBlbmRpbmciLCJyZWFkeSIsInJlYWR5Q2JzIiwibGlzdGVuIiwib25SZWFkeSIsInRyYW5zaXRpb25UbyIsIm9uQ29tcGxldGUiLCJvbkFib3J0IiwiY29uZmlybVRyYW5zaXRpb24iLCJ1cGRhdGVSb3V0ZSIsImVuc3VyZVVSTCIsImFib3J0IiwicmVzb2x2ZVF1ZXVlIiwidXBkYXRlZCIsImRlYWN0aXZhdGVkIiwiYWN0aXZhdGVkIiwiZXh0cmFjdExlYXZlR3VhcmRzIiwiYmVmb3JlSG9va3MiLCJleHRyYWN0VXBkYXRlSG9va3MiLCJyZXNvbHZlQXN5bmNDb21wb25lbnRzIiwiaXRlcmF0b3IiLCJwb3N0RW50ZXJDYnMiLCJpc1ZhbGlkIiwiZW50ZXJHdWFyZHMiLCJleHRyYWN0RW50ZXJHdWFyZHMiLCJwcmV2IiwiYWZ0ZXJIb29rcyIsImJhc2VFbCIsIm1heCIsIk1hdGgiLCJleHRyYWN0R3VhcmRzIiwicmVjb3JkcyIsImJpbmQiLCJyZXZlcnNlIiwiZ3VhcmRzIiwiZmxhdE1hcENvbXBvbmVudHMiLCJkZWYiLCJpbnN0YW5jZSIsImd1YXJkIiwiZXh0cmFjdEd1YXJkIiwiZmxhdHRlbiIsImJpbmRHdWFyZCIsImJvdW5kUm91dGVHdWFyZCIsImNicyIsIl8iLCJiaW5kRW50ZXJHdWFyZCIsInJvdXRlRW50ZXJHdWFyZCIsInBvbGwiLCJyZXNvbHZlZERlZiIsInJlamVjdCIsInJlYXNvbiIsInRoZW4iLCJjYWxsZWQiLCJIVE1MNUhpc3RvcnkiLCJIaXN0b3J5JCQxIiwiZXhwZWN0U2Nyb2xsIiwiZ2V0TG9jYXRpb24iLCJfX3Byb3RvX18iLCJjb25zdHJ1Y3RvciIsImdvIiwibiIsImdldEN1cnJlbnRMb2NhdGlvbiIsInNlYXJjaCIsIkhhc2hIaXN0b3J5IiwiZmFsbGJhY2siLCJjaGVja0ZhbGxiYWNrIiwiZW5zdXJlU2xhc2giLCJzZXR1cExpc3RlbmVycyIsImdldEhhc2giLCJyZXBsYWNlSGFzaCIsInB1c2hIYXNoIiwiQWJzdHJhY3RIaXN0b3J5IiwidGFyZ2V0SW5kZXgiLCJWdWVSb3V0ZXIiLCJhcHBzIiwibWF0Y2hlciIsInByb3RvdHlwZUFjY2Vzc29ycyIsInNldHVwSGFzaExpc3RlbmVyIiwiYmVmb3JlRWFjaCIsImFmdGVyRWFjaCIsImJhY2siLCJmb3J3YXJkIiwiZ2V0TWF0Y2hlZENvbXBvbmVudHMiLCJjcmVhdGVIcmVmIiwibm9ybWFsaXplZFRvIiwicmVzb2x2ZWQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX3RvU3RyaW5nIiwidG9OdW1iZXIiLCJwYXJzZUZsb2F0IiwiaXNOYU4iLCJtYWtlTWFwIiwiZXhwZWN0c0xvd2VyQ2FzZSIsImxpc3QiLCJ0b0xvd2VyQ2FzZSIsImlzQnVpbHRJblRhZyIsInJlbW92ZSIsIml0ZW0iLCJzcGxpY2UiLCJoYXNPd24iLCJpc1ByaW1pdGl2ZSIsImNhY2hlZCIsImNhY2hlZEZuIiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwiY2FwaXRhbGl6ZSIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwiY3R4IiwiYm91bmRGbiIsImwiLCJfbGVuZ3RoIiwidG9BcnJheSIsInN0YXJ0IiwicmV0IiwiX2Zyb20iLCJPQkpFQ1RfU1RSSU5HIiwiaXNQbGFpbk9iamVjdCIsInRvT2JqZWN0Iiwibm8iLCJpZGVudGl0eSIsImdlblN0YXRpY0tleXMiLCJtb2R1bGVzIiwicmVkdWNlIiwic3RhdGljS2V5cyIsImxvb3NlRXF1YWwiLCJpc09iamVjdEEiLCJpc09iamVjdEIiLCJsb29zZUluZGV4T2YiLCJzaWxlbnQiLCJwcm9kdWN0aW9uVGlwIiwiZGV2dG9vbHMiLCJlcnJvckhhbmRsZXIiLCJpZ25vcmVkRWxlbWVudHMiLCJrZXlDb2RlcyIsImlzUmVzZXJ2ZWRUYWciLCJpc1Vua25vd25FbGVtZW50IiwiZ2V0VGFnTmFtZXNwYWNlIiwicGFyc2VQbGF0Zm9ybVRhZ05hbWUiLCJtdXN0VXNlUHJvcCIsIl9hc3NldFR5cGVzIiwiX2xpZmVjeWNsZUhvb2tzIiwiX21heFVwZGF0ZUNvdW50IiwiZW1wdHlPYmplY3QiLCJpc1Jlc2VydmVkIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiYmFpbFJFIiwiaGFzUHJvdG8iLCJVQSIsImlzSUUiLCJpc0lFOSIsImlzRWRnZSIsImlzQW5kcm9pZCIsImlzSU9TIiwiaXNDaHJvbWUiLCJfaXNTZXJ2ZXIiLCJpc1NlcnZlclJlbmRlcmluZyIsImdsb2JhbCIsIlZVRV9FTlYiLCJfX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiaXNOYXRpdmUiLCJDdG9yIiwiaGFzU3ltYm9sIiwiU3ltYm9sIiwiUmVmbGVjdCIsIm93bktleXMiLCJjYWxsYmFja3MiLCJ0aW1lckZ1bmMiLCJuZXh0VGlja0hhbmRsZXIiLCJjb3BpZXMiLCJQcm9taXNlIiwicCIsImxvZ0Vycm9yIiwiZXJyIiwiZXJyb3IiLCJjYXRjaCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJjb3VudGVyIiwib2JzZXJ2ZXIiLCJ0ZXh0Tm9kZSIsImNyZWF0ZVRleHROb2RlIiwib2JzZXJ2ZSIsImNoYXJhY3RlckRhdGEiLCJxdWV1ZU5leHRUaWNrIiwiX3Jlc29sdmUiLCJfU2V0IiwiU2V0Iiwic2V0IiwiaGFzIiwiYWRkIiwiY2xlYXIiLCJ0aXAiLCJmb3JtYXRDb21wb25lbnROYW1lIiwiaGFzQ29uc29sZSIsImNsYXNzaWZ5UkUiLCJjbGFzc2lmeSIsIm1zZyIsInZtIiwiZm9ybWF0TG9jYXRpb24iLCJpbmNsdWRlRmlsZSIsIl9pc1Z1ZSIsIl9jb21wb25lbnRUYWciLCJmaWxlIiwiX19maWxlIiwidWlkJDEiLCJEZXAiLCJzdWJzIiwiYWRkU3ViIiwic3ViIiwicmVtb3ZlU3ViIiwiZGVwZW5kIiwiYWRkRGVwIiwibm90aWZ5IiwidXBkYXRlIiwidGFyZ2V0U3RhY2siLCJwdXNoVGFyZ2V0IiwiX3RhcmdldCIsInBvcFRhcmdldCIsImFycmF5UHJvdG8iLCJhcnJheU1ldGhvZHMiLCJtZXRob2QiLCJvcmlnaW5hbCIsIm11dGF0b3IiLCJhcmd1bWVudHMkMSIsIm9iIiwiX19vYl9fIiwiaW5zZXJ0ZWQiLCJvYnNlcnZlQXJyYXkiLCJkZXAiLCJhcnJheUtleXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwib2JzZXJ2ZXJTdGF0ZSIsInNob3VsZENvbnZlcnQiLCJpc1NldHRpbmdQcm9wcyIsIk9ic2VydmVyIiwidm1Db3VudCIsImF1Z21lbnQiLCJwcm90b0F1Z21lbnQiLCJjb3B5QXVnbWVudCIsIndhbGsiLCJkZWZpbmVSZWFjdGl2ZSQkMSIsIml0ZW1zIiwic3JjIiwiYXNSb290RGF0YSIsImlzRXh0ZW5zaWJsZSIsImN1c3RvbVNldHRlciIsInByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0dGVyIiwic2V0dGVyIiwiY2hpbGRPYiIsInJlYWN0aXZlR2V0dGVyIiwiZGVwZW5kQXJyYXkiLCJyZWFjdGl2ZVNldHRlciIsIm5ld1ZhbCIsImRlbCIsInByb3BzRGF0YSIsImRlZmF1bHRTdHJhdCIsIm1lcmdlRGF0YSIsInRvVmFsIiwiZnJvbVZhbCIsInBhcmVudFZhbCIsImNoaWxkVmFsIiwibWVyZ2VkRGF0YUZuIiwibWVyZ2VkSW5zdGFuY2VEYXRhRm4iLCJpbnN0YW5jZURhdGEiLCJkZWZhdWx0RGF0YSIsIm1lcmdlSG9vayIsIm1lcmdlQXNzZXRzIiwid2F0Y2giLCJtZXRob2RzIiwiY29tcHV0ZWQiLCJjaGVja0NvbXBvbmVudHMiLCJsb3dlciIsIm5vcm1hbGl6ZVByb3BzIiwibm9ybWFsaXplRGlyZWN0aXZlcyIsImRpcnMiLCJkaXJlY3RpdmVzIiwibWVyZ2VPcHRpb25zIiwiZXh0ZW5kc0Zyb20iLCJleHRlbmRzIiwibWl4aW5zIiwiVnVlJDMiLCJtZXJnZUZpZWxkIiwic3RyYXQiLCJyZXNvbHZlQXNzZXQiLCJ3YXJuTWlzc2luZyIsImFzc2V0cyIsImNhbWVsaXplZElkIiwiUGFzY2FsQ2FzZUlkIiwidmFsaWRhdGVQcm9wIiwicHJvcE9wdGlvbnMiLCJwcm9wIiwiYWJzZW50IiwiaXNUeXBlIiwiZ2V0UHJvcERlZmF1bHRWYWx1ZSIsInByZXZTaG91bGRDb252ZXJ0IiwiYXNzZXJ0UHJvcCIsIl9wcm9wcyIsImdldFR5cGUiLCJ2YWxpZCIsImV4cGVjdGVkVHlwZXMiLCJhc3NlcnRlZFR5cGUiLCJhc3NlcnRUeXBlIiwiZXhwZWN0ZWRUeXBlIiwidmFsaWRhdG9yIiwiaGFuZGxlRXJyb3IiLCJpbmZvIiwiaW5pdFByb3h5IiwiYWxsb3dlZEdsb2JhbHMiLCJ3YXJuTm9uUHJlc2VudCIsImhhc1Byb3h5IiwiUHJveHkiLCJpc0J1aWx0SW5Nb2RpZmllciIsImhhc0hhbmRsZXIiLCJpc0FsbG93ZWQiLCJnZXRIYW5kbGVyIiwiaGFuZGxlcnMiLCJfd2l0aFN0cmlwcGVkIiwiX3JlbmRlclByb3h5IiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJzdGFydFRhZyIsImVuZFRhZyIsIlZOb2RlIiwidGV4dCIsImVsbSIsImNvbnRleHQiLCJjb21wb25lbnRPcHRpb25zIiwibnMiLCJmdW5jdGlvbmFsQ29udGV4dCIsImNvbXBvbmVudEluc3RhbmNlIiwiaXNSb290SW5zZXJ0IiwiaXNDb21tZW50IiwiaXNDbG9uZWQiLCJpc09uY2UiLCJjcmVhdGVFbXB0eVZOb2RlIiwibm9kZSIsImNyZWF0ZVRleHRWTm9kZSIsImNsb25lVk5vZGUiLCJjbG9uZWQiLCJjbG9uZVZOb2RlcyIsInZub2RlcyIsIm5vcm1hbGl6ZUV2ZW50Iiwib25jZSQkMSIsImNyZWF0ZUZuSW52b2tlciIsImZucyIsImludm9rZXIiLCJ1cGRhdGVMaXN0ZW5lcnMiLCJvbGRPbiIsInJlbW92ZSQkMSIsImN1ciIsIm9sZCIsIm1lcmdlVk5vZGVIb29rIiwiaG9va0tleSIsIm9sZEhvb2siLCJ3cmFwcGVkSG9vayIsIm1lcmdlZCIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwibmVzdGVkSW5kZXgiLCJsYXN0IiwiZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCIsImluaXRFdmVudHMiLCJfZXZlbnRzIiwiX2hhc0hvb2tFdmVudCIsImxpc3RlbmVycyIsIl9wYXJlbnRMaXN0ZW5lcnMiLCJ1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMiLCIkb25jZSIsIiRvbiIsInJlbW92ZSQxIiwiJG9mZiIsIm9sZExpc3RlbmVycyIsImV2ZW50c01peGluIiwiaG9va1JFIiwiaSQxIiwiJGVtaXQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsImRlZmF1bHRTbG90Iiwic2xvdCIsImlzV2hpdGVzcGFjZSIsInJlc29sdmVTY29wZWRTbG90cyIsImFjdGl2ZUluc3RhbmNlIiwiaW5pdExpZmVjeWNsZSIsImFic3RyYWN0IiwiJGNoaWxkcmVuIiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc01vdW50ZWQiLCJfaXNEZXN0cm95ZWQiLCJfaXNCZWluZ0Rlc3Ryb3llZCIsImxpZmVjeWNsZU1peGluIiwiX3VwZGF0ZSIsImh5ZHJhdGluZyIsImNhbGxIb29rIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwiX3Zub2RlIiwicHJldkFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX3BhcmVudEVsbSIsIl9yZWZFbG0iLCJfX3Z1ZV9fIiwiJGZvcmNlVXBkYXRlIiwiJGRlc3Ryb3kiLCJ0ZWFyZG93biIsIl93YXRjaGVycyIsIl9kYXRhIiwibW91bnRDb21wb25lbnQiLCJ0ZW1wbGF0ZSIsInVwZGF0ZUNvbXBvbmVudCIsIl9uYW1lIiwiX3VpZCIsIl9yZW5kZXIiLCJXYXRjaGVyIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJwYXJlbnRWbm9kZSIsInJlbmRlckNoaWxkcmVuIiwiaGFzQ2hpbGRyZW4iLCJfcmVuZGVyQ2hpbGRyZW4iLCJzY29wZWRTbG90cyIsIiRzY29wZWRTbG90cyIsIl9wYXJlbnRWbm9kZSIsInByb3BLZXlzIiwiX3Byb3BLZXlzIiwiaXNJbkluYWN0aXZlVHJlZSIsImFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJkaXJlY3QiLCJkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJjaXJjdWxhciIsIndhaXRpbmciLCJmbHVzaGluZyIsInJlc2V0U2NoZWR1bGVyU3RhdGUiLCJmbHVzaFNjaGVkdWxlclF1ZXVlIiwid2F0Y2hlciIsInNvcnQiLCJ1c2VyIiwiZXhwcmVzc2lvbiIsInF1ZXVlV2F0Y2hlciIsInVpZCQyIiwiZXhwT3JGbiIsImRlZXAiLCJsYXp5Iiwic3luYyIsImFjdGl2ZSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJ0cmF2ZXJzZSIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNlZW5PYmplY3RzIiwiX3RyYXZlcnNlIiwic2VlbiIsImlzQSIsImRlcElkIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwicHJveHkiLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsImlzUmVzZXJ2ZWRQcm9wIiwicHJvcHNPcHRpb25zIiwiaXNSb290IiwibG9vcCIsImNvbXB1dGVkV2F0Y2hlck9wdGlvbnMiLCJ3YXRjaGVycyIsIl9jb21wdXRlZFdhdGNoZXJzIiwidXNlckRlZiIsImRlZmluZUNvbXB1dGVkIiwiY3JlYXRlQ29tcHV0ZWRHZXR0ZXIiLCJjb21wdXRlZEdldHRlciIsImNyZWF0ZVdhdGNoZXIiLCIkd2F0Y2giLCJzdGF0ZU1peGluIiwiZGF0YURlZiIsInByb3BzRGVmIiwibmV3RGF0YSIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwiY29tcG9uZW50Vk5vZGVIb29rcyIsInBhcmVudEVsbSIsInJlZkVsbSIsImNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUiLCJrZWVwQWxpdmUiLCJtb3VudGVkTm9kZSIsImluc2VydCIsImhvb2tzVG9NZXJnZSIsImNyZWF0ZUNvbXBvbmVudCIsImJhc2VDdG9yIiwiX2Jhc2UiLCJjaWQiLCJyZXNvbHZlQXN5bmNDb21wb25lbnQiLCJyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIiwibW9kZWwiLCJ0cmFuc2Zvcm1Nb2RlbCIsImV4dHJhY3RQcm9wcyIsImNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJuYXRpdmVPbiIsIm1lcmdlSG9va3MiLCJfY29udGV4dCIsImQiLCJ2bm9kZUNvbXBvbmVudE9wdGlvbnMiLCJfaXNDb21wb25lbnQiLCJpbmxpbmVUZW1wbGF0ZSIsInN0YXRpY1JlbmRlckZucyIsImZhY3RvcnkiLCJyZXF1ZXN0ZWQiLCJwZW5kaW5nQ2FsbGJhY2tzIiwiZG9tUHJvcHMiLCJhbHRLZXkiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsInByZXNlcnZlIiwiZnJvbVBhcmVudCIsIm91cnMiLCJtZXJnZUhvb2skMSIsIm9uZSIsInR3byIsImNhbGxiYWNrIiwiU0lNUExFX05PUk1BTElaRSIsIkFMV0FZU19OT1JNQUxJWkUiLCJub3JtYWxpemF0aW9uVHlwZSIsImFsd2F5c05vcm1hbGl6ZSIsIl9jcmVhdGVFbGVtZW50IiwiYXBwbHlOUyIsInJlbmRlckxpc3QiLCJyZW5kZXJTbG90IiwiYmluZE9iamVjdCIsInNjb3BlZFNsb3RGbiIsInNsb3ROb2RlcyIsIl9yZW5kZXJlZCIsInJlc29sdmVGaWx0ZXIiLCJjaGVja0tleUNvZGVzIiwiZXZlbnRLZXlDb2RlIiwiYnVpbHRJbkFsaWFzIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwicmVuZGVyU3RhdGljIiwiaXNJbkZvciIsInRyZWUiLCJfc3RhdGljVHJlZXMiLCJtYXJrU3RhdGljIiwibWFya09uY2UiLCJtYXJrU3RhdGljTm9kZSIsImluaXRSZW5kZXIiLCJyZW5kZXJDb250ZXh0IiwiX2MiLCIkY3JlYXRlRWxlbWVudCIsInJlbmRlck1peGluIiwicmVuZGVyRXJyb3IiLCJfbyIsIl9uIiwiX3MiLCJfbCIsIl90IiwiX3EiLCJfaSIsIl9tIiwiX2YiLCJfayIsIl9iIiwiX3YiLCJfZSIsIl91IiwiaW5pdFByb3ZpZGUiLCJwcm92aWRlIiwiX3Byb3ZpZGVkIiwiaW5pdEluamVjdGlvbnMiLCJpbmplY3QiLCJwcm92aWRlS2V5IiwidWlkIiwiaW5pdE1peGluIiwiX2luaXQiLCJpbml0SW50ZXJuYWxDb21wb25lbnQiLCJfc2VsZiIsInN1cGVyIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJkZWR1cGUiLCJpbml0VXNlIiwicGx1Z2luIiwiaW5pdE1peGluJDEiLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsInBhdHRlcm5UeXBlcyIsImdldENvbXBvbmVudE5hbWUiLCJwcnVuZUNhY2hlIiwiY2FjaGVkTm9kZSIsInBydW5lQ2FjaGVFbnRyeSIsIktlZXBBbGl2ZSIsImluY2x1ZGUiLCJleGNsdWRlIiwiZGVzdHJveWVkIiwiYnVpbHRJbkNvbXBvbmVudHMiLCJpbml0R2xvYmFsQVBJIiwiY29uZmlnRGVmIiwiZGVsZXRlIiwiYWNjZXB0VmFsdWUiLCJhdHRyIiwiaXNFbnVtZXJhdGVkQXR0ciIsImlzQm9vbGVhbkF0dHIiLCJ4bGlua05TIiwiaXNYbGluayIsImdldFhsaW5rUHJvcCIsImlzRmFsc3lBdHRyVmFsdWUiLCJnZW5DbGFzc0ZvclZub2RlIiwicGFyZW50Tm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwiZ2VuQ2xhc3NGcm9tRGF0YSIsInN0YXRpY0NsYXNzIiwiZHluYW1pY0NsYXNzIiwic3RyaW5naWZ5Q2xhc3MiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsImlzUHJlVGFnIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50Iiwic2VsZWN0ZWQiLCJjcmVhdGVFbGVtZW50JDEiLCJ0YWdOYW1lIiwibXVsdGlwbGUiLCJzZXRBdHRyaWJ1dGUiLCJjcmVhdGVFbGVtZW50TlMiLCJuYW1lc3BhY2UiLCJjcmVhdGVDb21tZW50IiwiaW5zZXJ0QmVmb3JlIiwibmV3Tm9kZSIsInJlZmVyZW5jZU5vZGUiLCJyZW1vdmVDaGlsZCIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsIm5vZGVPcHMiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsImlzVW5kZWYiLCJzIiwiaXNEZWYiLCJzYW1lVm5vZGUiLCJ2bm9kZTEiLCJ2bm9kZTIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJlbXB0eU5vZGVBdCIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsInJlbW92ZU5vZGUiLCJpblByZSIsImNyZWF0ZUVsbSIsImluc2VydGVkVm5vZGVRdWV1ZSIsIm5lc3RlZCIsInByZSIsInNldFNjb3BlIiwiY3JlYXRlQ2hpbGRyZW4iLCJpbnZva2VDcmVhdGVIb29rcyIsImlzUmVhY3RpdmF0ZWQiLCJpbml0Q29tcG9uZW50IiwicmVhY3RpdmF0ZUNvbXBvbmVudCIsInBlbmRpbmdJbnNlcnQiLCJpc1BhdGNoYWJsZSIsImlubmVyTm9kZSIsInRyYW5zaXRpb24iLCJhY3RpdmF0ZSIsImFuY2VzdG9yIiwiX3Njb3BlSWQiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJlbG1Ub01vdmUiLCJjYW5Nb3ZlIiwicGF0Y2hWbm9kZSIsImhhc0RhdGEiLCJwb3N0cGF0Y2giLCJpbnZva2VJbnNlcnRIb29rIiwiaW5pdGlhbCIsImJhaWxlZCIsImlzUmVuZGVyZWRNb2R1bGUiLCJoeWRyYXRlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsIm5vZGVUeXBlIiwicGF0Y2giLCJpc0luaXRpYWxQYXRjaCIsImlzUmVhbEVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJvbGRFbG0iLCJwYXJlbnRFbG0kMSIsIl9sZWF2ZUNiIiwidXBkYXRlRGlyZWN0aXZlcyIsInVuYmluZERpcmVjdGl2ZXMiLCJpc0NyZWF0ZSIsImlzRGVzdHJveSIsIm9sZERpcnMiLCJub3JtYWxpemVEaXJlY3RpdmVzJDEiLCJuZXdEaXJzIiwiZGlyc1dpdGhJbnNlcnQiLCJkaXJzV2l0aFBvc3RwYXRjaCIsIm9sZERpciIsImNhbGxIb29rJDEiLCJjb21wb25lbnRVcGRhdGVkIiwiY2FsbEluc2VydCIsImVtcHR5TW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiZ2V0UmF3RGlyTmFtZSIsInJhd05hbWUiLCJiYXNlTW9kdWxlcyIsInVwZGF0ZUF0dHJzIiwib2xkQXR0cnMiLCJzZXRBdHRyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGVOUyIsInVwZGF0ZUNsYXNzIiwib2xkRGF0YSIsInRyYW5zaXRpb25DbGFzcyIsIl90cmFuc2l0aW9uQ2xhc3NlcyIsIl9wcmV2Q2xhc3MiLCJrbGFzcyIsInZhbGlkRGl2aXNpb25DaGFyUkUiLCJwYXJzZUZpbHRlcnMiLCJleHAiLCJpblNpbmdsZSIsImluRG91YmxlIiwiaW5UZW1wbGF0ZVN0cmluZyIsImluUmVnZXgiLCJjdXJseSIsInNxdWFyZSIsInBhcmVuIiwibGFzdEZpbHRlckluZGV4IiwiZmlsdGVycyIsInB1c2hGaWx0ZXIiLCJ3cmFwRmlsdGVyIiwiYmFzZVdhcm4iLCJwbHVja01vZHVsZUZ1bmN0aW9uIiwiYWRkUHJvcCIsImFkZEF0dHIiLCJhZGREaXJlY3RpdmUiLCJhcmciLCJhZGRIYW5kbGVyIiwiaW1wb3J0YW50IiwiZXZlbnRzIiwibmF0aXZlIiwibmF0aXZlRXZlbnRzIiwibmV3SGFuZGxlciIsImdldEJpbmRpbmdBdHRyIiwiZ2V0U3RhdGljIiwiZHluYW1pY1ZhbHVlIiwiZ2V0QW5kUmVtb3ZlQXR0ciIsInN0YXRpY1ZhbHVlIiwiYXR0cnNNYXAiLCJhdHRyc0xpc3QiLCJnZW5Db21wb25lbnRNb2RlbCIsIm51bWJlciIsImJhc2VWYWx1ZUV4cHJlc3Npb24iLCJ2YWx1ZUV4cHJlc3Npb24iLCJhc3NpZ25tZW50IiwiZ2VuQXNzaWdubWVudENvZGUiLCJtb2RlbFJzIiwicGFyc2VNb2RlbCIsImlkeCIsImNociIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwibGFzdEluZGV4T2YiLCJlb2YiLCJpc1N0cmluZ1N0YXJ0IiwicGFyc2VTdHJpbmciLCJwYXJzZUJyYWNrZXQiLCJzdWJzdHJpbmciLCJpbkJyYWNrZXQiLCJzdHJpbmdRdW90ZSIsIndhcm4kMSIsIlJBTkdFX1RPS0VOIiwiQ0hFQ0tCT1hfUkFESU9fVE9LRU4iLCJfd2FybiIsImR5bmFtaWNUeXBlIiwiZ2VuU2VsZWN0IiwiZ2VuQ2hlY2tib3hNb2RlbCIsImdlblJhZGlvTW9kZWwiLCJnZW5EZWZhdWx0TW9kZWwiLCJ2YWx1ZUJpbmRpbmciLCJ0cnVlVmFsdWVCaW5kaW5nIiwiZmFsc2VWYWx1ZUJpbmRpbmciLCJzZWxlY3RlZFZhbCIsImNvZGUiLCJuZWVkQ29tcG9zaXRpb25HdWFyZCIsIm5vcm1hbGl6ZUV2ZW50cyIsInRhcmdldCQxIiwiYWRkJDEiLCJvbGRIYW5kbGVyIiwiZXYiLCJyZW1vdmUkMiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1cGRhdGVET01MaXN0ZW5lcnMiLCJ1cGRhdGVET01Qcm9wcyIsIm9sZFByb3BzIiwiX3ZhbHVlIiwic3RyQ3VyIiwic2hvdWxkVXBkYXRlVmFsdWUiLCJjaGVja1ZhbCIsImNvbXBvc2luZyIsImlzRGlydHkiLCJpc0lucHV0Q2hhbmdlZCIsImFjdGl2ZUVsZW1lbnQiLCJfdk1vZGlmaWVycyIsInBhcnNlU3R5bGVUZXh0IiwiY3NzVGV4dCIsImxpc3REZWxpbWl0ZXIiLCJwcm9wZXJ0eURlbGltaXRlciIsIm5vcm1hbGl6ZVN0eWxlRGF0YSIsInN0eWxlIiwibm9ybWFsaXplU3R5bGVCaW5kaW5nIiwic3RhdGljU3R5bGUiLCJiaW5kaW5nU3R5bGUiLCJnZXRTdHlsZSIsImNoZWNrQ2hpbGQiLCJzdHlsZURhdGEiLCJjc3NWYXJSRSIsImltcG9ydGFudFJFIiwic2V0UHJvcCIsInNldFByb3BlcnR5Iiwibm9ybWFsaXplIiwicHJlZml4ZXMiLCJ0ZXN0RWwiLCJ1cHBlciIsInByZWZpeGVkIiwidXBkYXRlU3R5bGUiLCJvbGRTdGF0aWNTdHlsZSIsIm9sZFN0eWxlQmluZGluZyIsIm9sZFN0eWxlIiwibmV3U3R5bGUiLCJhZGRDbGFzcyIsImNsYXNzTGlzdCIsInJlbW92ZUNsYXNzIiwidGFyIiwicmVzb2x2ZVRyYW5zaXRpb24iLCJkZWYkJDEiLCJjc3MiLCJhdXRvQ3NzVHJhbnNpdGlvbiIsImVudGVyQ2xhc3MiLCJlbnRlclRvQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwibGVhdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsImxlYXZlQWN0aXZlQ2xhc3MiLCJoYXNUcmFuc2l0aW9uIiwiVFJBTlNJVElPTiIsIkFOSU1BVElPTiIsInRyYW5zaXRpb25Qcm9wIiwidHJhbnNpdGlvbkVuZEV2ZW50IiwiYW5pbWF0aW9uUHJvcCIsImFuaW1hdGlvbkVuZEV2ZW50Iiwib250cmFuc2l0aW9uZW5kIiwib253ZWJraXR0cmFuc2l0aW9uZW5kIiwib25hbmltYXRpb25lbmQiLCJvbndlYmtpdGFuaW1hdGlvbmVuZCIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5leHRGcmFtZSIsImFkZFRyYW5zaXRpb25DbGFzcyIsInJlbW92ZVRyYW5zaXRpb25DbGFzcyIsIndoZW5UcmFuc2l0aW9uRW5kcyIsImdldFRyYW5zaXRpb25JbmZvIiwicHJvcENvdW50IiwiZW5kZWQiLCJvbkVuZCIsInRyYW5zZm9ybVJFIiwic3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRyYW5zaXRpb25EZWxheXMiLCJ0cmFuc2l0aW9uRHVyYXRpb25zIiwidHJhbnNpdGlvblRpbWVvdXQiLCJnZXRUaW1lb3V0IiwiYW5pbWF0aW9uRGVsYXlzIiwiYW5pbWF0aW9uRHVyYXRpb25zIiwiYW5pbWF0aW9uVGltZW91dCIsImhhc1RyYW5zZm9ybSIsImRlbGF5cyIsImR1cmF0aW9ucyIsInRvTXMiLCJOdW1iZXIiLCJlbnRlciIsInRvZ2dsZURpc3BsYXkiLCJjYW5jZWxsZWQiLCJfZW50ZXJDYiIsImFwcGVhckNsYXNzIiwiYXBwZWFyVG9DbGFzcyIsImFwcGVhckFjdGl2ZUNsYXNzIiwiYWZ0ZXJFbnRlciIsImVudGVyQ2FuY2VsbGVkIiwiYmVmb3JlQXBwZWFyIiwiYXBwZWFyIiwiYWZ0ZXJBcHBlYXIiLCJhcHBlYXJDYW5jZWxsZWQiLCJkdXJhdGlvbiIsInRyYW5zaXRpb25Ob2RlIiwiaXNBcHBlYXIiLCJzdGFydENsYXNzIiwidG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJiZWZvcmVMZWF2ZSIsImFmdGVyTGVhdmUiLCJsZWF2ZUNhbmNlbGxlZCIsImRlbGF5TGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJwZXJmb3JtTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwidm1vZGVsIiwidHJpZ2dlciIsIm1vZGVsJDEiLCJzZXRTZWxlY3RlZCIsIm9uQ29tcG9zaXRpb25TdGFydCIsIm9uQ29tcG9zaXRpb25FbmQiLCJuZWVkUmVzZXQiLCJoYXNOb01hdGNoaW5nT3B0aW9uIiwiaXNNdWx0aXBsZSIsIm9wdGlvbiIsImdldFZhbHVlIiwic2VsZWN0ZWRJbmRleCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImxvY2F0ZU5vZGUiLCJvcmlnaW5hbERpc3BsYXkiLCJfX3ZPcmlnaW5hbERpc3BsYXkiLCJkaXNwbGF5IiwidW5iaW5kIiwicGxhdGZvcm1EaXJlY3RpdmVzIiwidHJhbnNpdGlvblByb3BzIiwiZ2V0UmVhbENoaWxkIiwiY29tcE9wdGlvbnMiLCJleHRyYWN0VHJhbnNpdGlvbkRhdGEiLCJjb21wIiwia2V5JDEiLCJwbGFjZWhvbGRlciIsInJhd0NoaWxkIiwiaGFzUGFyZW50VHJhbnNpdGlvbiIsImlzU2FtZUNoaWxkIiwib2xkQ2hpbGQiLCJUcmFuc2l0aW9uIiwiX2xlYXZpbmciLCJvbGRSYXdDaGlsZCIsImRlbGF5ZWRMZWF2ZSIsIm1vdmVDbGFzcyIsIlRyYW5zaXRpb25Hcm91cCIsInByZXZDaGlsZHJlbiIsInJhd0NoaWxkcmVuIiwidHJhbnNpdGlvbkRhdGEiLCJrZXB0IiwicmVtb3ZlZCIsImMkMSIsInBvcyIsImJlZm9yZVVwZGF0ZSIsImhhc01vdmUiLCJjYWxsUGVuZGluZ0NicyIsInJlY29yZFBvc2l0aW9uIiwiYXBwbHlUcmFuc2xhdGlvbiIsImJvZHkiLCJmIiwib2Zmc2V0SGVpZ2h0IiwibW92ZWQiLCJ0cmFuc2Zvcm0iLCJXZWJraXRUcmFuc2Zvcm0iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJfbW92ZUNiIiwicHJvcGVydHlOYW1lIiwiX2hhc01vdmUiLCJjbG9uZSIsImNsb25lTm9kZSIsIm5ld1BvcyIsIm9sZFBvcyIsImR4IiwiZHkiLCJwbGF0Zm9ybUNvbXBvbmVudHMiLCJzaG91bGREZWNvZGUiLCJjb250ZW50IiwiZW5jb2RlZCIsImRpdiIsInNob3VsZERlY29kZU5ld2xpbmVzIiwiaXNVbmFyeVRhZyIsImNhbkJlTGVmdE9wZW5UYWciLCJpc05vblBocmFzaW5nVGFnIiwiZGVjb2RlciIsImh0bWwiLCJzaW5nbGVBdHRySWRlbnRpZmllciIsInNpbmdsZUF0dHJBc3NpZ24iLCJzaW5nbGVBdHRyVmFsdWVzIiwiYXR0cmlidXRlIiwibmNuYW1lIiwicW5hbWVDYXB0dXJlIiwic3RhcnRUYWdPcGVuIiwic3RhcnRUYWdDbG9zZSIsImRvY3R5cGUiLCJjb21tZW50IiwiY29uZGl0aW9uYWxDb21tZW50IiwiSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiIsImciLCJpc1BsYWluVGV4dEVsZW1lbnQiLCJyZUNhY2hlIiwiZGVjb2RpbmdNYXAiLCJlbmNvZGVkQXR0ciIsImVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIiwiZGVjb2RlQXR0ciIsInBhcnNlSFRNTCIsImV4cGVjdEhUTUwiLCJpc1VuYXJ5VGFnJCQxIiwibGFzdFRhZyIsInRleHRFbmQiLCJjb21tZW50RW5kIiwiYWR2YW5jZSIsImNvbmRpdGlvbmFsRW5kIiwiZG9jdHlwZU1hdGNoIiwiZW5kVGFnTWF0Y2giLCJjdXJJbmRleCIsInBhcnNlRW5kVGFnIiwic3RhcnRUYWdNYXRjaCIsInBhcnNlU3RhcnRUYWciLCJoYW5kbGVTdGFydFRhZyIsInJlc3QkMSIsImNoYXJzIiwic3RhY2tlZFRhZyIsInJlU3RhY2tlZFRhZyIsImVuZFRhZ0xlbmd0aCIsInJlc3QiLCJhbGwiLCJ1bmFyeVNsYXNoIiwidW5hcnkiLCJsb3dlckNhc2VkVGFnIiwibG93ZXJDYXNlZFRhZ05hbWUiLCJkZWZhdWx0VGFnUkUiLCJyZWdleEVzY2FwZVJFIiwiYnVpbGRSZWdleCIsImRlbGltaXRlcnMiLCJvcGVuIiwiY2xvc2UiLCJwYXJzZVRleHQiLCJ0YWdSRSIsImxhc3RJbmRleCIsIm9uUkUiLCJkaXJSRSIsImZvckFsaWFzUkUiLCJmb3JJdGVyYXRvclJFIiwiYXJnUkUiLCJiaW5kUkUiLCJtb2RpZmllclJFIiwiZGVjb2RlSFRNTENhY2hlZCIsIndhcm4kMiIsInRyYW5zZm9ybXMiLCJwcmVUcmFuc2Zvcm1zIiwicG9zdFRyYW5zZm9ybXMiLCJwbGF0Zm9ybUlzUHJlVGFnIiwicGxhdGZvcm1NdXN0VXNlUHJvcCIsInBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlIiwicHJlc2VydmVXaGl0ZXNwYWNlIiwicm9vdCIsImN1cnJlbnRQYXJlbnQiLCJpblZQcmUiLCJ3YXJuZWQiLCJ3YXJuT25jZSIsImVuZFByZSIsImd1YXJkSUVTVkdCdWciLCJtYWtlQXR0cnNNYXAiLCJpc0ZvcmJpZGRlblRhZyIsImZvcmJpZGRlbiIsInByb2Nlc3NQcmUiLCJwcm9jZXNzUmF3QXR0cnMiLCJwcm9jZXNzRm9yIiwicHJvY2Vzc0lmIiwicHJvY2Vzc09uY2UiLCJwcm9jZXNzS2V5IiwicGxhaW4iLCJwcm9jZXNzUmVmIiwicHJvY2Vzc1Nsb3QiLCJwcm9jZXNzQ29tcG9uZW50IiwicHJvY2Vzc0F0dHJzIiwiY2hlY2tSb290Q29uc3RyYWludHMiLCJpZiIsImVsc2VpZiIsImVsc2UiLCJhZGRJZkNvbmRpdGlvbiIsImJsb2NrIiwicHJvY2Vzc0lmQ29uZGl0aW9ucyIsInNsb3RTY29wZSIsInNsb3RUYXJnZXQiLCJpJDIiLCJsYXN0Tm9kZSIsImNoZWNrSW5Gb3IiLCJpbk1hdGNoIiwiZm9yIiwiaXRlcmF0b3JNYXRjaCIsIml0ZXJhdG9yMSIsIml0ZXJhdG9yMiIsImZpbmRQcmV2RWxlbWVudCIsImlmQ29uZGl0aW9ucyIsInNsb3ROYW1lIiwiaXNQcm9wIiwiaGFzQmluZGluZ3MiLCJwYXJzZU1vZGlmaWVycyIsImNhbWVsIiwiYXJnTWF0Y2giLCJjaGVja0ZvckFsaWFzTW9kZWwiLCJpZU5TQnVnIiwiaWVOU1ByZWZpeCIsIl9lbCIsImlzU3RhdGljS2V5IiwiaXNQbGF0Zm9ybVJlc2VydmVkVGFnIiwiZ2VuU3RhdGljS2V5c0NhY2hlZCIsImdlblN0YXRpY0tleXMkMSIsIm9wdGltaXplIiwibWFya1N0YXRpYyQxIiwibWFya1N0YXRpY1Jvb3RzIiwic3RhdGljIiwic3RhdGljSW5Gb3IiLCJzdGF0aWNSb290Iiwid2Fsa1Rocm91Z2hDb25kaXRpb25zQmxvY2tzIiwiY29uZGl0aW9uQmxvY2tzIiwiaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IiLCJmbkV4cFJFIiwic2ltcGxlUGF0aFJFIiwiZXNjIiwidGFiIiwic3BhY2UiLCJ1cCIsInJpZ2h0IiwiZG93biIsImdlbkd1YXJkIiwibW9kaWZpZXJDb2RlIiwic3RvcCIsInByZXZlbnQiLCJzZWxmIiwiY3RybCIsImFsdCIsIm1pZGRsZSIsImdlbkhhbmRsZXJzIiwiZ2VuSGFuZGxlciIsImlzTWV0aG9kUGF0aCIsImlzRnVuY3Rpb25FeHByZXNzaW9uIiwiZ2VuTW9kaWZpZXJDb2RlIiwiZ2VuS2V5RmlsdGVyIiwiaGFuZGxlckNvZGUiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwicGFyc2VJbnQiLCJiaW5kJDEiLCJ3cmFwRGF0YSIsImJhc2VEaXJlY3RpdmVzIiwiY2xvYWsiLCJ3YXJuJDMiLCJ0cmFuc2Zvcm1zJDEiLCJkYXRhR2VuRm5zIiwicGxhdGZvcm1EaXJlY3RpdmVzJDEiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMSIsIm9uY2VDb3VudCIsImN1cnJlbnRPcHRpb25zIiwiZ2VuZXJhdGUiLCJhc3QiLCJwcmV2U3RhdGljUmVuZGVyRm5zIiwiY3VycmVudFN0YXRpY1JlbmRlckZucyIsInByZXZPbmNlQ291bnQiLCJnZW5FbGVtZW50Iiwic3RhdGljUHJvY2Vzc2VkIiwiZ2VuU3RhdGljIiwib25jZVByb2Nlc3NlZCIsImdlbk9uY2UiLCJmb3JQcm9jZXNzZWQiLCJnZW5Gb3IiLCJpZlByb2Nlc3NlZCIsImdlbklmIiwiZ2VuQ2hpbGRyZW4iLCJnZW5TbG90IiwiZ2VuQ29tcG9uZW50IiwiZ2VuRGF0YSIsImdlbklmQ29uZGl0aW9ucyIsImNvbmRpdGlvbnMiLCJnZW5UZXJuYXJ5RXhwIiwibWF5YmVDb21wb25lbnQiLCJnZW5EaXJlY3RpdmVzIiwiZ2VuUHJvcHMiLCJnZW5TY29wZWRTbG90cyIsImdlbklubGluZVRlbXBsYXRlIiwiaGFzUnVudGltZSIsIm5lZWRSdW50aW1lIiwiZ2VuIiwiaW5saW5lUmVuZGVyRm5zIiwiZ2VuU2NvcGVkU2xvdCIsInNjb3BlIiwiY2hlY2tTa2lwIiwiZWwkMSIsImdldE5vcm1hbGl6YXRpb25UeXBlIiwiZ2VuTm9kZSIsIm5lZWRzTm9ybWFsaXphdGlvbiIsImdlblRleHQiLCJ0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMiLCJiaW5kJCQxIiwiY29tcG9uZW50TmFtZSIsInByb2hpYml0ZWRLZXl3b3JkUkUiLCJ1bmFyeU9wZXJhdG9yc1JFIiwiaWRlbnRSRSIsInN0cmlwU3RyaW5nUkUiLCJkZXRlY3RFcnJvcnMiLCJlcnJvcnMiLCJjaGVja05vZGUiLCJjaGVja0ZvciIsImNoZWNrRXZlbnQiLCJjaGVja0V4cHJlc3Npb24iLCJrZXl3b3JkTWF0Y2giLCJjaGVja0lkZW50aWZpZXIiLCJpZGVudCIsIkZ1bmN0aW9uIiwiYmFzZUNvbXBpbGUiLCJtYWtlRnVuY3Rpb24iLCJjcmVhdGVDb21waWxlciIsImJhc2VPcHRpb25zIiwiZnVuY3Rpb25Db21waWxlQ2FjaGUiLCJmaW5hbE9wdGlvbnMiLCJ0aXBzIiwidGlwJCQxIiwiY29tcGlsZWQiLCJjb21waWxlVG9GdW5jdGlvbnMiLCJmbkdlbkVycm9ycyIsInRyYW5zZm9ybU5vZGUiLCJjbGFzc0JpbmRpbmciLCJnZW5EYXRhJDEiLCJrbGFzcyQxIiwidHJhbnNmb3JtTm9kZSQxIiwic3R5bGVCaW5kaW5nIiwiZ2VuRGF0YSQyIiwic3R5bGUkMSIsIm1vZHVsZXMkMSIsImRpcmVjdGl2ZXMkMSIsInJlZiQxIiwiaWRUb1RlbXBsYXRlIiwibW91bnQiLCJnZXRPdXRlckhUTUwiLCJvdXRlckhUTUwiLCJjb250YWluZXIiLCJldmFsIiwicmVxdWlyZSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUEyQyxjQUFjOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNoRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDbERBO0FBQ0EsSUFBSUEs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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7Ozs7Ozs7QUMzQkEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7QUNuQ0EsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBLENBQUMsK0JBQStCLGFBQWEsMEJBQTBCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7OztBQ2hCQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLCtCQUErQixhQUFhLDBCQUEwQjtBQUN2RTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDIiwiZmlsZSI6Img1cC1mZWVkYmFjay5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA2MWFmZmJmYjk2Zjk3MWNjNmQ4OSIsIi8vIHRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHJhd1NjcmlwdEV4cG9ydHMsXG4gIGNvbXBpbGVkVGVtcGxhdGUsXG4gIHNjb3BlSWQsXG4gIGNzc01vZHVsZXNcbikge1xuICB2YXIgZXNNb2R1bGVcbiAgdmFyIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyB8fCB7fVxuXG4gIC8vIEVTNiBtb2R1bGVzIGludGVyb3BcbiAgdmFyIHR5cGUgPSB0eXBlb2YgcmF3U2NyaXB0RXhwb3J0cy5kZWZhdWx0XG4gIGlmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXNNb2R1bGUgPSByYXdTY3JpcHRFeHBvcnRzXG4gICAgc2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICB9XG5cbiAgLy8gVnVlLmV4dGVuZCBjb25zdHJ1Y3RvciBleHBvcnQgaW50ZXJvcFxuICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzY3JpcHRFeHBvcnRzID09PSAnZnVuY3Rpb24nXG4gICAgPyBzY3JpcHRFeHBvcnRzLm9wdGlvbnNcbiAgICA6IHNjcmlwdEV4cG9ydHNcblxuICAvLyByZW5kZXIgZnVuY3Rpb25zXG4gIGlmIChjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBjb21waWxlZFRlbXBsYXRlLnJlbmRlclxuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWRUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9IHNjb3BlSWRcbiAgfVxuXG4gIC8vIGluamVjdCBjc3NNb2R1bGVzXG4gIGlmIChjc3NNb2R1bGVzKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zLmNvbXB1dGVkIHx8IG51bGwpXG4gICAgT2JqZWN0LmtleXMoY3NzTW9kdWxlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbW9kdWxlID0gY3NzTW9kdWxlc1trZXldXG4gICAgICBjb21wdXRlZFtrZXldID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbW9kdWxlIH1cbiAgICB9KVxuICAgIG9wdGlvbnMuY29tcHV0ZWQgPSBjb21wdXRlZFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlc01vZHVsZTogZXNNb2R1bGUsXG4gICAgZXhwb3J0czogc2NyaXB0RXhwb3J0cyxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XG5pbXBvcnQgUm91dGVyIGZyb20gJ3Z1ZS1yb3V0ZXInO1xuaW1wb3J0IFNjb3JlSW5wdXQgZnJvbSAnLi92aWV3cy9TY29yZUlucHV0LnZ1ZSc7XG5pbXBvcnQgVGV4dElucHV0IGZyb20gJy4vdmlld3MvVGV4dElucHV0LnZ1ZSc7XG5pbXBvcnQgRmluYWwgZnJvbSAnLi92aWV3cy9GaW5hbC52dWUnO1xuXG5WdWUudXNlKFJvdXRlcik7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZlZWRiYWNrIGV4dGVuZHMgSDVQLkV2ZW50RGlzcGF0Y2hlciB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudElkXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RGF0YVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnLCBjb250ZW50SWQsIGNvbnRlbnREYXRhID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29udGVudElkID0gY29udGVudElkO1xuXG4gICAgY29uc3QgYWx0ZXJuYXRpdmVzID0gW1xuICAgICAge1xuICAgICAgICB0aXRsZTogJ1ZlcnkgU2F0aXNmaWVkJyxcbiAgICAgICAgY2xzOiAnZmVlZGJhY2stc2NvcmUtNCcsXG4gICAgICAgIHNjb3JlOiAnNCdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRpdGxlOiAnU2F0aXNmaWVkJyxcbiAgICAgICAgY2xzOiAnZmVlZGJhY2stc2NvcmUtMycsXG4gICAgICAgIHNjb3JlOiAnMydcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRpdGxlOiAnTmV1dHJhbCcsXG4gICAgICAgIGNsczogJ2ZlZWRiYWNrLXNjb3JlLTInLFxuICAgICAgICBzY29yZTogJzInXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0aXRsZTogJ1Vuc2F0aXNmaWVkJyxcbiAgICAgICAgY2xzOiAnZmVlZGJhY2stc2NvcmUtMScsXG4gICAgICAgIHNjb3JlOiAnMSdcbiAgICAgIH1dO1xuXG4gICAgLy8gc2V0IGRhdGEgb24gc2NvcmUgaW5wdXQgdmlld1xuICAgIFNjb3JlSW5wdXQuZGF0YSA9ICgpID0+ICh7XG4gICAgICBtZXNzYWdlOiBjb25maWcudGl0bGUsXG4gICAgICBzY29yZTogJzAnLFxuICAgICAgYWx0ZXJuYXRpdmVzXG4gICAgfSk7XG5cbiAgICAvLyBzZXQgZGF0YSBvbiB0ZXh0IGlucHV0IHZpZXdcbiAgICBUZXh0SW5wdXQuZGF0YSA9ICgpID0+ICh7XG4gICAgICBhbHRlcm5hdGl2ZXNcbiAgICB9KTtcblxuICAgIC8vIGNyYXRlIHJvdXRlclxuICAgIGNvbnN0IHJvdXRlciA9IG5ldyBSb3V0ZXIoe1xuICAgICAgbW9kZTogJ2Fic3RyYWN0JyxcbiAgICAgIHJvdXRlczogW1xuICAgICAgICB7IHBhdGg6ICcvc2NvcmUtaW5wdXQnLCBjb21wb25lbnQ6IFNjb3JlSW5wdXQgfSxcbiAgICAgICAgeyBwYXRoOiAnL3RleHQtaW5wdXQvOnNjb3JlJywgY29tcG9uZW50OiBUZXh0SW5wdXQsIHByb3BzOiB0cnVlIH0sXG4gICAgICAgIHsgcGF0aDogJy9maW5hbCcsIGNvbXBvbmVudDogRmluYWwgfSxcbiAgICAgIF1cbiAgICB9KTtcblxuICAgIC8vIGNyZWF0ZSB2aWV3IG1vZGVsXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVnVlKHsgcm91dGVyIH0pO1xuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIGxpYnJhcnkgdG8gd3JhcHBlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICR3cmFwcGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMuYXR0YWNoID0gJHdyYXBwZXIgPT4ge1xuICAgICAgLy8gY3JlYXRlIHJvb3QgZWxlbWVudFxuICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGVsZW1lbnQuaWQgPSBgaDVwLWZlZWRiYWNrLWNvbnRlbnQtJHt0aGlzLmNvbnRlbnRJZH1gO1xuICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSAnaDVwLWZlZWRiYWNrJztcbiAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxyb3V0ZXItdmlldz48L3JvdXRlci12aWV3Pic7XG5cbiAgICAgIC8vIGFkZCByb290IGVsZW1lbnQgdG8gd3JhcHBlclxuICAgICAgJHdyYXBwZXIuZ2V0KDApLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXG4gICAgICAvLyBtb3VudCByb290IHZpZXdcbiAgICAgIHRoaXMudmlld01vZGVsLiRtb3VudChgIyR7ZWxlbWVudC5pZH1gKTtcblxuICAgICAgLy8gbmF2aWdhdGUgdG8gc2NvcmVcbiAgICAgIHJvdXRlci5wdXNoKCdzY29yZS1pbnB1dCcpO1xuICAgIH07XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2NyaXB0cy9mZWVkYmFjay5qcyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc3R5bGVzL21haW4uc2Nzc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI8dGVtcGxhdGU+XG4gIDxkaXYgcm9sZT1cInJlZ2lvblwiIGNsYXNzPVwiaDVwLWZlZWRiYWNrLWZpbmFsXCI+XG4gICAgPHA+V2UgcHV0IGEgbG90IG9mIGVmZm9ydCBpbnRvIG1ha2luZyBINVAgZWFzeSB0byB1c2UgZm9yIGFsbCE8L3A+XG4gICAgPGgzPllvdXIgZmVlZGJhY2sgaXMgaGlnaGx5IGFwcHJlY2lhdGVkITwvaDM+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6ICdmaW5hbC12aWV3J1xuICB9XG48L3NjcmlwdD5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gRmluYWwudnVlPzIyYTE4MmQyIiwiPHRlbXBsYXRlPlxuICA8ZGl2IHJvbGU9XCJyZWdpb25cIiBjbGFzcz1cImg1cC1mZWVkYmFjay1zY29yZVwiPlxuICAgIDxoMyBjbGFzcz1cImZlZWRiYWNrLXRpdGxlXCIgdi1odG1sPVwibWVzc2FnZVwiPjwvaDM+XG5cbiAgICA8dWwgY2xhc3M9XCJmZWVkYmFjay1zY29yZS1pbnB1dFwiPlxuICAgICAgPGxpIHYtZm9yPVwiYWx0ZXJuYXRpdmUgaW4gYWx0ZXJuYXRpdmVzXCI+XG4gICAgICAgIDxkaXYgcm9sZT1cImJ1dHRvblwiIHYtYmluZDpjbGFzcz1cImFsdGVybmF0aXZlLmNsc1wiIHYtb246Y2xpY2s9XCJzZW5kU2NvcmUoYWx0ZXJuYXRpdmUpXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImZlZWRiYWNrLXNjb3JlLXRpdGxlXCI+e3sgYWx0ZXJuYXRpdmUudGl0bGUgfX08L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2xpPlxuICAgIDwvdWw+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6ICdzY29yZS1pbnB1dC12aWV3JyxcblxuICAgIG1ldGhvZHM6IHtcbiAgICAgIHNlbmRTY29yZTogZnVuY3Rpb24oYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgdGhpcy5zY29yZSA9IGFsdGVybmF0aXZlLnNjb3JlO1xuXG4gICAgICAgIHRoaXMuJHJvdXRlci5wdXNoKGB0ZXh0LWlucHV0LyR7YWx0ZXJuYXRpdmUuc2NvcmV9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG48L3NjcmlwdD5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gU2NvcmVJbnB1dC52dWU/M2ZjZThkMGEiLCI8dGVtcGxhdGU+XG4gIDxkaXYgcm9sZT1cInJlZ2lvblwiIGNsYXNzPVwiaDVwLWZlZWRiYWNrLXRleHRcIj5cbiAgICA8ZGl2IGNsYXNzPVwiZmVlZGJhY2stc2NvcmVcIiB2LWJpbmQ6Y2xhc3M9XCJhbHRlcm5hdGl2ZS5jbHNcIj48L2Rpdj5cbiAgICA8cD57eyB0aGlzLmFsdGVybmF0aXZlLnRpdGxlIH19PC9wPlxuXG4gICAgPHJvdXRlci1saW5rIHRvPVwiL3Njb3JlLWlucHV0XCI+Q2hhbmdlPC9yb3V0ZXItbGluaz5cblxuICAgIDxoMz5UaGFua3MgZm9yIHRoZSByYXRpbmchPC9oMz5cblxuICAgIDxwPkxldCB1cyBrbm93IGhvdyB3ZSBjYW4gaW1wcm92ZSB5b3VyIGV4cGVyaWVuY2Ugd2l0aCB0aGUgPHN0cm9uZz5EcmFnIFRleHQ8L3N0cm9uZz4gYXV0aG9yaW5nIHRvb2wuPC9wPlxuXG4gICAgPHRleHRhcmVhIHJvd3M9XCI0XCIgcGxhY2Vob2xkZXI9XCJZb3VyIEZlZWRiYWNrXCI+PC90ZXh0YXJlYT5cblxuICAgIDxidXR0b24gdi1vbjpjbGljaz1cInNlbmRUZXh0KClcIj5TZW5kPC9idXR0b24+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6ICd0ZXh0LWlucHV0LXZpZXcnLFxuICAgIHByb3BzOiBbJ3Njb3JlJ10sXG4gICAgd2F0Y2g6IHtcbiAgICAgICckcm91dGUnOiAndXBkYXRlQWx0ZXJuYXRpdmUnXG4gICAgfSxcblxuICAgIGNyZWF0ZWQgKCkge1xuICAgICAgdGhpcy51cGRhdGVBbHRlcm5hdGl2ZSgpO1xuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG4gICAgICB1cGRhdGVBbHRlcm5hdGl2ZSAoKSB7XG4gICAgICAgIHRoaXMuYWx0ZXJuYXRpdmUgPSB0aGlzLmFsdGVybmF0aXZlc1xuICAgICAgICAgIC5maWx0ZXIoYWx0ZXJuYXRpdmUgPT4gYWx0ZXJuYXRpdmUuc2NvcmUgPT09IHRoaXMuc2NvcmUpWzBdO1xuICAgICAgfSxcblxuICAgICAgc2VuZFRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBUT0RPIEZpcmUgeEFQSVxuICAgICAgICB0aGlzLiRyb3V0ZXIucHVzaCgnL2ZpbmFsJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG48L3NjcmlwdD5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gVGV4dElucHV0LnZ1ZT8wY2FjZWQ2YSIsIi8qKlxuICAqIHZ1ZS1yb3V0ZXIgdjIuMi4xXG4gICogKGMpIDIwMTcgRXZhbiBZb3VcbiAgKiBAbGljZW5zZSBNSVRcbiAgKi9cbi8qICAqL1xuXG5mdW5jdGlvbiBhc3NlcnQgKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcigoXCJbdnVlLXJvdXRlcl0gXCIgKyBtZXNzYWdlKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuIChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKChcIlt2dWUtcm91dGVyXSBcIiArIG1lc3NhZ2UpKTtcbiAgfVxufVxuXG52YXIgVmlldyA9IHtcbiAgbmFtZTogJ3JvdXRlci12aWV3JyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGVmYXVsdCdcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciBwYXJlbnQgPSByZWYucGFyZW50O1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG5cbiAgICBkYXRhLnJvdXRlclZpZXcgPSB0cnVlO1xuXG4gICAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICAgIHZhciByb3V0ZSA9IHBhcmVudC4kcm91dGU7XG4gICAgdmFyIGNhY2hlID0gcGFyZW50Ll9yb3V0ZXJWaWV3Q2FjaGUgfHwgKHBhcmVudC5fcm91dGVyVmlld0NhY2hlID0ge30pO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGN1cnJlbnQgdmlldyBkZXB0aCwgYWxzbyBjaGVjayB0byBzZWUgaWYgdGhlIHRyZWVcbiAgICAvLyBoYXMgYmVlbiB0b2dnbGVkIGluYWN0aXZlIGJ1dCBrZXB0LWFsaXZlLlxuICAgIHZhciBkZXB0aCA9IDA7XG4gICAgdmFyIGluYWN0aXZlID0gZmFsc2U7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC4kdm5vZGUgJiYgcGFyZW50LiR2bm9kZS5kYXRhLnJvdXRlclZpZXcpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQuX2luYWN0aXZlKSB7XG4gICAgICAgIGluYWN0aXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBkYXRhLnJvdXRlclZpZXdEZXB0aCA9IGRlcHRoO1xuXG4gICAgLy8gcmVuZGVyIHByZXZpb3VzIHZpZXcgaWYgdGhlIHRyZWUgaXMgaW5hY3RpdmUgYW5kIGtlcHQtYWxpdmVcbiAgICBpZiAoaW5hY3RpdmUpIHtcbiAgICAgIHJldHVybiBoKGNhY2hlW25hbWVdLCBkYXRhLCBjaGlsZHJlbilcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlZCA9IHJvdXRlLm1hdGNoZWRbZGVwdGhdO1xuICAgIC8vIHJlbmRlciBlbXB0eSBub2RlIGlmIG5vIG1hdGNoZWQgcm91dGVcbiAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgIGNhY2hlW25hbWVdID0gbnVsbDtcbiAgICAgIHJldHVybiBoKClcbiAgICB9XG5cbiAgICB2YXIgY29tcG9uZW50ID0gY2FjaGVbbmFtZV0gPSBtYXRjaGVkLmNvbXBvbmVudHNbbmFtZV07XG5cbiAgICAvLyBpbmplY3QgaW5zdGFuY2UgcmVnaXN0cmF0aW9uIGhvb2tzXG4gICAgdmFyIGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gICAgaG9va3MuaW5pdCA9IGZ1bmN0aW9uICh2bm9kZSkge1xuICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB2bm9kZS5jaGlsZDtcbiAgICB9O1xuICAgIGhvb2tzLnByZXBhdGNoID0gZnVuY3Rpb24gKG9sZFZub2RlLCB2bm9kZSkge1xuICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB2bm9kZS5jaGlsZDtcbiAgICB9O1xuICAgIGhvb2tzLmRlc3Ryb3kgPSBmdW5jdGlvbiAodm5vZGUpIHtcbiAgICAgIGlmIChtYXRjaGVkLmluc3RhbmNlc1tuYW1lXSA9PT0gdm5vZGUuY2hpbGQpIHtcbiAgICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHJlc29sdmUgcHJvcHNcbiAgICBkYXRhLnByb3BzID0gcmVzb2x2ZVByb3BzKHJvdXRlLCBtYXRjaGVkLnByb3BzICYmIG1hdGNoZWQucHJvcHNbbmFtZV0pO1xuXG4gICAgcmV0dXJuIGgoY29tcG9uZW50LCBkYXRhLCBjaGlsZHJlbilcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVzb2x2ZVByb3BzIChyb3V0ZSwgY29uZmlnKSB7XG4gIHN3aXRjaCAodHlwZW9mIGNvbmZpZykge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiBjb25maWcocm91dGUpXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gY29uZmlnID8gcm91dGUucGFyYW1zIDogdW5kZWZpbmVkXG4gICAgZGVmYXVsdDpcbiAgICAgIHdhcm4oZmFsc2UsIChcInByb3BzIGluIFxcXCJcIiArIChyb3V0ZS5wYXRoKSArIFwiXFxcIiBpcyBhIFwiICsgKHR5cGVvZiBjb25maWcpICsgXCIsIGV4cGVjdGluZyBhbiBvYmplY3QsIGZ1bmN0aW9uIG9yIGJvb2xlYW4uXCIpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGVuY29kZVJlc2VydmVSRSA9IC9bIScoKSpdL2c7XG52YXIgZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7IH07XG52YXIgY29tbWFSRSA9IC8lMkMvZztcblxuLy8gZml4ZWQgZW5jb2RlVVJJQ29tcG9uZW50IHdoaWNoIGlzIG1vcmUgY29tZm9ybWFudCB0byBSRkMzOTg2OlxuLy8gLSBlc2NhcGVzIFshJygpKl1cbi8vIC0gcHJlc2VydmUgY29tbWFzXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgLnJlcGxhY2UoZW5jb2RlUmVzZXJ2ZVJFLCBlbmNvZGVSZXNlcnZlUmVwbGFjZXIpXG4gIC5yZXBsYWNlKGNvbW1hUkUsICcsJyk7IH07XG5cbnZhciBkZWNvZGUgPSBkZWNvZGVVUklDb21wb25lbnQ7XG5cbmZ1bmN0aW9uIHJlc29sdmVRdWVyeSAoXG4gIHF1ZXJ5LFxuICBleHRyYVF1ZXJ5XG4pIHtcbiAgaWYgKCBleHRyYVF1ZXJ5ID09PSB2b2lkIDAgKSBleHRyYVF1ZXJ5ID0ge307XG5cbiAgaWYgKHF1ZXJ5KSB7XG4gICAgdmFyIHBhcnNlZFF1ZXJ5O1xuICAgIHRyeSB7XG4gICAgICBwYXJzZWRRdWVyeSA9IHBhcnNlUXVlcnkocXVlcnkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihmYWxzZSwgZS5tZXNzYWdlKTtcbiAgICAgIHBhcnNlZFF1ZXJ5ID0ge307XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBleHRyYVF1ZXJ5KSB7XG4gICAgICBwYXJzZWRRdWVyeVtrZXldID0gZXh0cmFRdWVyeVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkUXVlcnlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXh0cmFRdWVyeVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlUXVlcnkgKHF1ZXJ5KSB7XG4gIHZhciByZXMgPSB7fTtcblxuICBxdWVyeSA9IHF1ZXJ5LnRyaW0oKS5yZXBsYWNlKC9eKFxcP3wjfCYpLywgJycpO1xuXG4gIGlmICghcXVlcnkpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBxdWVyeS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIHBhcnRzID0gcGFyYW0ucmVwbGFjZSgvXFwrL2csICcgJykuc3BsaXQoJz0nKTtcbiAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRzLnNoaWZ0KCkpO1xuICAgIHZhciB2YWwgPSBwYXJ0cy5sZW5ndGggPiAwXG4gICAgICA/IGRlY29kZShwYXJ0cy5qb2luKCc9JykpXG4gICAgICA6IG51bGw7XG5cbiAgICBpZiAocmVzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzW2tleV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc1trZXldKSkge1xuICAgICAgcmVzW2tleV0ucHVzaCh2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNba2V5XSA9IFtyZXNba2V5XSwgdmFsXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5UXVlcnkgKG9iaikge1xuICB2YXIgcmVzID0gb2JqID8gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2YWwgPSBvYmpba2V5XTtcblxuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVuY29kZShrZXkpXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFsLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAodmFsMikge1xuICAgICAgICBpZiAodmFsMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbDIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGUoa2V5KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsMikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQuam9pbignJicpXG4gICAgfVxuXG4gICAgcmV0dXJuIGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHZhbClcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lmxlbmd0aCA+IDA7IH0pLmpvaW4oJyYnKSA6IG51bGw7XG4gIHJldHVybiByZXMgPyAoXCI/XCIgKyByZXMpIDogJydcbn1cblxuLyogICovXG5cbnZhciB0cmFpbGluZ1NsYXNoUkUgPSAvXFwvPyQvO1xuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZSAoXG4gIHJlY29yZCxcbiAgbG9jYXRpb24sXG4gIHJlZGlyZWN0ZWRGcm9tXG4pIHtcbiAgdmFyIHJvdXRlID0ge1xuICAgIG5hbWU6IGxvY2F0aW9uLm5hbWUgfHwgKHJlY29yZCAmJiByZWNvcmQubmFtZSksXG4gICAgbWV0YTogKHJlY29yZCAmJiByZWNvcmQubWV0YSkgfHwge30sXG4gICAgcGF0aDogbG9jYXRpb24ucGF0aCB8fCAnLycsXG4gICAgaGFzaDogbG9jYXRpb24uaGFzaCB8fCAnJyxcbiAgICBxdWVyeTogbG9jYXRpb24ucXVlcnkgfHwge30sXG4gICAgcGFyYW1zOiBsb2NhdGlvbi5wYXJhbXMgfHwge30sXG4gICAgZnVsbFBhdGg6IGdldEZ1bGxQYXRoKGxvY2F0aW9uKSxcbiAgICBtYXRjaGVkOiByZWNvcmQgPyBmb3JtYXRNYXRjaChyZWNvcmQpIDogW11cbiAgfTtcbiAgaWYgKHJlZGlyZWN0ZWRGcm9tKSB7XG4gICAgcm91dGUucmVkaXJlY3RlZEZyb20gPSBnZXRGdWxsUGF0aChyZWRpcmVjdGVkRnJvbSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUocm91dGUpXG59XG5cbi8vIHRoZSBzdGFydGluZyByb3V0ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGluaXRpYWwgc3RhdGVcbnZhciBTVEFSVCA9IGNyZWF0ZVJvdXRlKG51bGwsIHtcbiAgcGF0aDogJy8nXG59KTtcblxuZnVuY3Rpb24gZm9ybWF0TWF0Y2ggKHJlY29yZCkge1xuICB2YXIgcmVzID0gW107XG4gIHdoaWxlIChyZWNvcmQpIHtcbiAgICByZXMudW5zaGlmdChyZWNvcmQpO1xuICAgIHJlY29yZCA9IHJlY29yZC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRGdWxsUGF0aCAocmVmKSB7XG4gIHZhciBwYXRoID0gcmVmLnBhdGg7XG4gIHZhciBxdWVyeSA9IHJlZi5xdWVyeTsgaWYgKCBxdWVyeSA9PT0gdm9pZCAwICkgcXVlcnkgPSB7fTtcbiAgdmFyIGhhc2ggPSByZWYuaGFzaDsgaWYgKCBoYXNoID09PSB2b2lkIDAgKSBoYXNoID0gJyc7XG5cbiAgcmV0dXJuIChwYXRoIHx8ICcvJykgKyBzdHJpbmdpZnlRdWVyeShxdWVyeSkgKyBoYXNoXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVJvdXRlIChhLCBiKSB7XG4gIGlmIChiID09PSBTVEFSVCkge1xuICAgIHJldHVybiBhID09PSBiXG4gIH0gZWxzZSBpZiAoIWIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChhLnBhdGggJiYgYi5wYXRoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGEucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJycpID09PSBiLnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcnKSAmJlxuICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5xdWVyeSwgYi5xdWVyeSlcbiAgICApXG4gIH0gZWxzZSBpZiAoYS5uYW1lICYmIGIubmFtZSkge1xuICAgIHJldHVybiAoXG4gICAgICBhLm5hbWUgPT09IGIubmFtZSAmJlxuICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5xdWVyeSwgYi5xdWVyeSkgJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5wYXJhbXMsIGIucGFyYW1zKVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBpc09iamVjdEVxdWFsIChhLCBiKSB7XG4gIGlmICggYSA9PT0gdm9pZCAwICkgYSA9IHt9O1xuICBpZiAoIGIgPT09IHZvaWQgMCApIGIgPSB7fTtcblxuICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG4gIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiBhS2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBTdHJpbmcoYVtrZXldKSA9PT0gU3RyaW5nKGJba2V5XSk7IH0pXG59XG5cbmZ1bmN0aW9uIGlzSW5jbHVkZWRSb3V0ZSAoY3VycmVudCwgdGFyZ2V0KSB7XG4gIHJldHVybiAoXG4gICAgY3VycmVudC5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnLycpLmluZGV4T2YoXG4gICAgICB0YXJnZXQucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJy8nKVxuICAgICkgPT09IDAgJiZcbiAgICAoIXRhcmdldC5oYXNoIHx8IGN1cnJlbnQuaGFzaCA9PT0gdGFyZ2V0Lmhhc2gpICYmXG4gICAgcXVlcnlJbmNsdWRlcyhjdXJyZW50LnF1ZXJ5LCB0YXJnZXQucXVlcnkpXG4gIClcbn1cblxuZnVuY3Rpb24gcXVlcnlJbmNsdWRlcyAoY3VycmVudCwgdGFyZ2V0KSB7XG4gIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICBpZiAoIShrZXkgaW4gY3VycmVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKiAgKi9cblxuLy8gd29yayBhcm91bmQgd2VpcmQgZmxvdyBidWdcbnZhciB0b1R5cGVzID0gW1N0cmluZywgT2JqZWN0XTtcbnZhciBldmVudFR5cGVzID0gW1N0cmluZywgQXJyYXldO1xuXG52YXIgTGluayA9IHtcbiAgbmFtZTogJ3JvdXRlci1saW5rJyxcbiAgcHJvcHM6IHtcbiAgICB0bzoge1xuICAgICAgdHlwZTogdG9UeXBlcyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICB0YWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdhJ1xuICAgIH0sXG4gICAgZXhhY3Q6IEJvb2xlYW4sXG4gICAgYXBwZW5kOiBCb29sZWFuLFxuICAgIHJlcGxhY2U6IEJvb2xlYW4sXG4gICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBldmVudDoge1xuICAgICAgdHlwZTogZXZlbnRUeXBlcyxcbiAgICAgIGRlZmF1bHQ6ICdjbGljaydcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcm91dGVyID0gdGhpcy4kcm91dGVyO1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy4kcm91dGU7XG4gICAgdmFyIHJlZiA9IHJvdXRlci5yZXNvbHZlKHRoaXMudG8sIGN1cnJlbnQsIHRoaXMuYXBwZW5kKTtcbiAgICB2YXIgbG9jYXRpb24gPSByZWYubG9jYXRpb247XG4gICAgdmFyIHJvdXRlID0gcmVmLnJvdXRlO1xuICAgIHZhciBocmVmID0gcmVmLmhyZWY7XG4gICAgdmFyIGNsYXNzZXMgPSB7fTtcbiAgICB2YXIgYWN0aXZlQ2xhc3MgPSB0aGlzLmFjdGl2ZUNsYXNzIHx8IHJvdXRlci5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcyB8fCAncm91dGVyLWxpbmstYWN0aXZlJztcbiAgICB2YXIgY29tcGFyZVRhcmdldCA9IGxvY2F0aW9uLnBhdGggPyBjcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbikgOiByb3V0ZTtcbiAgICBjbGFzc2VzW2FjdGl2ZUNsYXNzXSA9IHRoaXMuZXhhY3RcbiAgICAgID8gaXNTYW1lUm91dGUoY3VycmVudCwgY29tcGFyZVRhcmdldClcbiAgICAgIDogaXNJbmNsdWRlZFJvdXRlKGN1cnJlbnQsIGNvbXBhcmVUYXJnZXQpO1xuXG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGd1YXJkRXZlbnQoZSkpIHtcbiAgICAgICAgaWYgKHRoaXMkMS5yZXBsYWNlKSB7XG4gICAgICAgICAgcm91dGVyLnJlcGxhY2UobG9jYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvdXRlci5wdXNoKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb24gPSB7IGNsaWNrOiBndWFyZEV2ZW50IH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5ldmVudCkpIHtcbiAgICAgIHRoaXMuZXZlbnQuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyBvbltlXSA9IGhhbmRsZXI7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvblt0aGlzLmV2ZW50XSA9IGhhbmRsZXI7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBjbGFzczogY2xhc3Nlc1xuICAgIH07XG5cbiAgICBpZiAodGhpcy50YWcgPT09ICdhJykge1xuICAgICAgZGF0YS5vbiA9IG9uO1xuICAgICAgZGF0YS5hdHRycyA9IHsgaHJlZjogaHJlZiB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmaW5kIHRoZSBmaXJzdCA8YT4gY2hpbGQgYW5kIGFwcGx5IGxpc3RlbmVyIGFuZCBocmVmXG4gICAgICB2YXIgYSA9IGZpbmRBbmNob3IodGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgICBpZiAoYSkge1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSA8YT4gaXMgYSBzdGF0aWMgbm9kZVxuICAgICAgICBhLmlzU3RhdGljID0gZmFsc2U7XG4gICAgICAgIHZhciBleHRlbmQgPSBfVnVlLnV0aWwuZXh0ZW5kO1xuICAgICAgICB2YXIgYURhdGEgPSBhLmRhdGEgPSBleHRlbmQoe30sIGEuZGF0YSk7XG4gICAgICAgIGFEYXRhLm9uID0gb247XG4gICAgICAgIHZhciBhQXR0cnMgPSBhLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGEuZGF0YS5hdHRycyk7XG4gICAgICAgIGFBdHRycy5ocmVmID0gaHJlZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRvZXNuJ3QgaGF2ZSA8YT4gY2hpbGQsIGFwcGx5IGxpc3RlbmVyIHRvIHNlbGZcbiAgICAgICAgZGF0YS5vbiA9IG9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoKHRoaXMudGFnLCBkYXRhLCB0aGlzLiRzbG90cy5kZWZhdWx0KVxuICB9XG59O1xuXG5mdW5jdGlvbiBndWFyZEV2ZW50IChlKSB7XG4gIC8vIGRvbid0IHJlZGlyZWN0IHdpdGggY29udHJvbCBrZXlzXG4gIGlmIChlLm1ldGFLZXkgfHwgZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkpIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgd2hlbiBwcmV2ZW50RGVmYXVsdCBjYWxsZWRcbiAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCBvbiByaWdodCBjbGlja1xuICBpZiAoZS5idXR0b24gIT09IHVuZGVmaW5lZCAmJiBlLmJ1dHRvbiAhPT0gMCkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCBpZiBgdGFyZ2V0PVwiX2JsYW5rXCJgXG4gIGlmIChlLnRhcmdldCAmJiBlLnRhcmdldC5nZXRBdHRyaWJ1dGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKTtcbiAgICBpZiAoL1xcYl9ibGFua1xcYi9pLnRlc3QodGFyZ2V0KSkgeyByZXR1cm4gfVxuICB9XG4gIC8vIHRoaXMgbWF5IGJlIGEgV2VleCBldmVudCB3aGljaCBkb2Vzbid0IGhhdmUgdGhpcyBtZXRob2RcbiAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZmluZEFuY2hvciAoY2hpbGRyZW4pIHtcbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgdmFyIGNoaWxkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAnYScpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQuY2hpbGRyZW4gJiYgKGNoaWxkID0gZmluZEFuY2hvcihjaGlsZC5jaGlsZHJlbikpKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgX1Z1ZTtcblxuZnVuY3Rpb24gaW5zdGFsbCAoVnVlKSB7XG4gIGlmIChpbnN0YWxsLmluc3RhbGxlZCkgeyByZXR1cm4gfVxuICBpbnN0YWxsLmluc3RhbGxlZCA9IHRydWU7XG5cbiAgX1Z1ZSA9IFZ1ZTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRyb3V0ZXInLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkgeyByZXR1cm4gdGhpcy4kcm9vdC5fcm91dGVyIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcm91dGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkgeyByZXR1cm4gdGhpcy4kcm9vdC5fcm91dGUgfVxuICB9KTtcblxuICBWdWUubWl4aW4oe1xuICAgIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gYmVmb3JlQ3JlYXRlICgpIHtcbiAgICAgIGlmICh0aGlzLiRvcHRpb25zLnJvdXRlcikge1xuICAgICAgICB0aGlzLl9yb3V0ZXIgPSB0aGlzLiRvcHRpb25zLnJvdXRlcjtcbiAgICAgICAgdGhpcy5fcm91dGVyLmluaXQodGhpcyk7XG4gICAgICAgIFZ1ZS51dGlsLmRlZmluZVJlYWN0aXZlKHRoaXMsICdfcm91dGUnLCB0aGlzLl9yb3V0ZXIuaGlzdG9yeS5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIFZ1ZS5jb21wb25lbnQoJ3JvdXRlci12aWV3JywgVmlldyk7XG4gIFZ1ZS5jb21wb25lbnQoJ3JvdXRlci1saW5rJywgTGluayk7XG5cbiAgdmFyIHN0cmF0cyA9IFZ1ZS5jb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuICAvLyB1c2UgdGhlIHNhbWUgaG9vayBtZXJnaW5nIHN0cmF0ZWd5IGZvciByb3V0ZSBob29rc1xuICBzdHJhdHMuYmVmb3JlUm91dGVFbnRlciA9IHN0cmF0cy5iZWZvcmVSb3V0ZUxlYXZlID0gc3RyYXRzLmNyZWF0ZWQ7XG59XG5cbi8qICAqL1xuXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlUGF0aCAoXG4gIHJlbGF0aXZlLFxuICBiYXNlLFxuICBhcHBlbmRcbikge1xuICBpZiAocmVsYXRpdmUuY2hhckF0KDApID09PSAnLycpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5jaGFyQXQoMCkgPT09ICc/JyB8fCByZWxhdGl2ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIHJldHVybiBiYXNlICsgcmVsYXRpdmVcbiAgfVxuXG4gIHZhciBzdGFjayA9IGJhc2Uuc3BsaXQoJy8nKTtcblxuICAvLyByZW1vdmUgdHJhaWxpbmcgc2VnbWVudCBpZjpcbiAgLy8gLSBub3QgYXBwZW5kaW5nXG4gIC8vIC0gYXBwZW5kaW5nIHRvIHRyYWlsaW5nIHNsYXNoIChsYXN0IHNlZ21lbnQgaXMgZW1wdHkpXG4gIGlmICghYXBwZW5kIHx8ICFzdGFja1tzdGFjay5sZW5ndGggLSAxXSkge1xuICAgIHN0YWNrLnBvcCgpO1xuICB9XG5cbiAgLy8gcmVzb2x2ZSByZWxhdGl2ZSBwYXRoXG4gIHZhciBzZWdtZW50cyA9IHJlbGF0aXZlLnJlcGxhY2UoL15cXC8vLCAnJykuc3BsaXQoJy8nKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgaWYgKHNlZ21lbnQgPT09ICcuJykge1xuICAgICAgY29udGludWVcbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgPT09ICcuLicpIHtcbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFjay5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVuc3VyZSBsZWFkaW5nIHNsYXNoXG4gIGlmIChzdGFja1swXSAhPT0gJycpIHtcbiAgICBzdGFjay51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIHJldHVybiBzdGFjay5qb2luKCcvJylcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIHZhciBoYXNoID0gJyc7XG4gIHZhciBxdWVyeSA9ICcnO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgaGFzaCA9IHBhdGguc2xpY2UoaGFzaEluZGV4KTtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKTtcbiAgaWYgKHF1ZXJ5SW5kZXggPj0gMCkge1xuICAgIHF1ZXJ5ID0gcGF0aC5zbGljZShxdWVyeUluZGV4ICsgMSk7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgcXVlcnlJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGg6IHBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGhhc2g6IGhhc2hcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhblBhdGggKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwvXFwvL2csICcvJylcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlTWFwIChcbiAgcm91dGVzLFxuICBvbGRQYXRoTWFwLFxuICBvbGROYW1lTWFwXG4pIHtcbiAgdmFyIHBhdGhNYXAgPSBvbGRQYXRoTWFwIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBuYW1lTWFwID0gb2xkTmFtZU1hcCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJvdXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgIGFkZFJvdXRlUmVjb3JkKHBhdGhNYXAsIG5hbWVNYXAsIHJvdXRlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoTWFwOiBwYXRoTWFwLFxuICAgIG5hbWVNYXA6IG5hbWVNYXBcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRSb3V0ZVJlY29yZCAoXG4gIHBhdGhNYXAsXG4gIG5hbWVNYXAsXG4gIHJvdXRlLFxuICBwYXJlbnQsXG4gIG1hdGNoQXNcbikge1xuICB2YXIgcGF0aCA9IHJvdXRlLnBhdGg7XG4gIHZhciBuYW1lID0gcm91dGUubmFtZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQocGF0aCAhPSBudWxsLCBcIlxcXCJwYXRoXFxcIiBpcyByZXF1aXJlZCBpbiBhIHJvdXRlIGNvbmZpZ3VyYXRpb24uXCIpO1xuICAgIGFzc2VydChcbiAgICAgIHR5cGVvZiByb3V0ZS5jb21wb25lbnQgIT09ICdzdHJpbmcnLFxuICAgICAgXCJyb3V0ZSBjb25maWcgXFxcImNvbXBvbmVudFxcXCIgZm9yIHBhdGg6IFwiICsgKFN0cmluZyhwYXRoIHx8IG5hbWUpKSArIFwiIGNhbm5vdCBiZSBhIFwiICtcbiAgICAgIFwic3RyaW5nIGlkLiBVc2UgYW4gYWN0dWFsIGNvbXBvbmVudCBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgfVxuXG4gIHZhciByZWNvcmQgPSB7XG4gICAgcGF0aDogbm9ybWFsaXplUGF0aChwYXRoLCBwYXJlbnQpLFxuICAgIGNvbXBvbmVudHM6IHJvdXRlLmNvbXBvbmVudHMgfHwgeyBkZWZhdWx0OiByb3V0ZS5jb21wb25lbnQgfSxcbiAgICBpbnN0YW5jZXM6IHt9LFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgbWF0Y2hBczogbWF0Y2hBcyxcbiAgICByZWRpcmVjdDogcm91dGUucmVkaXJlY3QsXG4gICAgYmVmb3JlRW50ZXI6IHJvdXRlLmJlZm9yZUVudGVyLFxuICAgIG1ldGE6IHJvdXRlLm1ldGEgfHwge30sXG4gICAgcHJvcHM6IHJvdXRlLnByb3BzID09IG51bGxcbiAgICAgID8ge31cbiAgICAgIDogcm91dGUuY29tcG9uZW50c1xuICAgICAgICA/IHJvdXRlLnByb3BzXG4gICAgICAgIDogeyBkZWZhdWx0OiByb3V0ZS5wcm9wcyB9XG4gIH07XG5cbiAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgLy8gV2FybiBpZiByb3V0ZSBpcyBuYW1lZCBhbmQgaGFzIGEgZGVmYXVsdCBjaGlsZCByb3V0ZS5cbiAgICAvLyBJZiB1c2VycyBuYXZpZ2F0ZSB0byB0aGlzIHJvdXRlIGJ5IG5hbWUsIHRoZSBkZWZhdWx0IGNoaWxkIHdpbGxcbiAgICAvLyBub3QgYmUgcmVuZGVyZWQgKEdIIElzc3VlICM2MjkpXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChyb3V0ZS5uYW1lICYmIHJvdXRlLmNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiAvXlxcLz8kLy50ZXN0KGNoaWxkLnBhdGgpOyB9KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiTmFtZWQgUm91dGUgJ1wiICsgKHJvdXRlLm5hbWUpICsgXCInIGhhcyBhIGRlZmF1bHQgY2hpbGQgcm91dGUuIFwiICtcbiAgICAgICAgICBcIldoZW4gbmF2aWdhdGluZyB0byB0aGlzIG5hbWVkIHJvdXRlICg6dG89XFxcIntuYW1lOiAnXCIgKyAocm91dGUubmFtZSkgKyBcIidcXFwiKSwgXCIgK1xuICAgICAgICAgIFwidGhlIGRlZmF1bHQgY2hpbGQgcm91dGUgd2lsbCBub3QgYmUgcmVuZGVyZWQuIFJlbW92ZSB0aGUgbmFtZSBmcm9tIFwiICtcbiAgICAgICAgICBcInRoaXMgcm91dGUgYW5kIHVzZSB0aGUgbmFtZSBvZiB0aGUgZGVmYXVsdCBjaGlsZCByb3V0ZSBmb3IgbmFtZWQgXCIgK1xuICAgICAgICAgIFwibGlua3MgaW5zdGVhZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByb3V0ZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdmFyIGNoaWxkTWF0Y2hBcyA9IG1hdGNoQXNcbiAgICAgICAgPyBjbGVhblBhdGgoKG1hdGNoQXMgKyBcIi9cIiArIChjaGlsZC5wYXRoKSkpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgYWRkUm91dGVSZWNvcmQocGF0aE1hcCwgbmFtZU1hcCwgY2hpbGQsIHJlY29yZCwgY2hpbGRNYXRjaEFzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyb3V0ZS5hbGlhcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocm91dGUuYWxpYXMpKSB7XG4gICAgICByb3V0ZS5hbGlhcy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICB2YXIgYWxpYXNSb3V0ZSA9IHtcbiAgICAgICAgICBwYXRoOiBhbGlhcyxcbiAgICAgICAgICBjaGlsZHJlbjogcm91dGUuY2hpbGRyZW5cbiAgICAgICAgfTtcbiAgICAgICAgYWRkUm91dGVSZWNvcmQocGF0aE1hcCwgbmFtZU1hcCwgYWxpYXNSb3V0ZSwgcGFyZW50LCByZWNvcmQucGF0aCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFsaWFzUm91dGUgPSB7XG4gICAgICAgIHBhdGg6IHJvdXRlLmFsaWFzLFxuICAgICAgICBjaGlsZHJlbjogcm91dGUuY2hpbGRyZW5cbiAgICAgIH07XG4gICAgICBhZGRSb3V0ZVJlY29yZChwYXRoTWFwLCBuYW1lTWFwLCBhbGlhc1JvdXRlLCBwYXJlbnQsIHJlY29yZC5wYXRoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXBhdGhNYXBbcmVjb3JkLnBhdGhdKSB7XG4gICAgcGF0aE1hcFtyZWNvcmQucGF0aF0gPSByZWNvcmQ7XG4gIH1cblxuICBpZiAobmFtZSkge1xuICAgIGlmICghbmFtZU1hcFtuYW1lXSkge1xuICAgICAgbmFtZU1hcFtuYW1lXSA9IHJlY29yZDtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIW1hdGNoQXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcIkR1cGxpY2F0ZSBuYW1lZCByb3V0ZXMgZGVmaW5pdGlvbjogXCIgK1xuICAgICAgICBcInsgbmFtZTogXFxcIlwiICsgbmFtZSArIFwiXFxcIiwgcGF0aDogXFxcIlwiICsgKHJlY29yZC5wYXRoKSArIFwiXFxcIiB9XCJcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGggKHBhdGgsIHBhcmVudCkge1xuICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICBpZiAocGF0aFswXSA9PT0gJy8nKSB7IHJldHVybiBwYXRoIH1cbiAgaWYgKHBhcmVudCA9PSBudWxsKSB7IHJldHVybiBwYXRoIH1cbiAgcmV0dXJuIGNsZWFuUGF0aCgoKHBhcmVudC5wYXRoKSArIFwiL1wiICsgcGF0aCkpXG59XG5cbnZhciBpbmRleCQxID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudmFyIGlzYXJyYXkgPSBpbmRleCQxO1xuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xudmFyIGluZGV4ID0gcGF0aFRvUmVnZXhwO1xudmFyIHBhcnNlXzEgPSBwYXJzZTtcbnZhciBjb21waWxlXzEgPSBjb21waWxlO1xudmFyIHRva2Vuc1RvRnVuY3Rpb25fMSA9IHRva2Vuc1RvRnVuY3Rpb247XG52YXIgdG9rZW5zVG9SZWdFeHBfMSA9IHRva2Vuc1RvUmVnRXhwO1xuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiICA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAvLyBcIi8qXCIgICAgICAgICAgICA9PiBbXCIvXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCIqXCJdXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcbl0uam9pbignfCcpLCAnZycpO1xuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnNcbiAqIEByZXR1cm4geyFBcnJheX1cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHN0ciwgb3B0aW9ucykge1xuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBrZXkgPSAwO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgcGF0aCA9ICcnO1xuICB2YXIgZGVmYXVsdERlbGltaXRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nO1xuICB2YXIgcmVzO1xuXG4gIHdoaWxlICgocmVzID0gUEFUSF9SRUdFWFAuZXhlYyhzdHIpKSAhPSBudWxsKSB7XG4gICAgdmFyIG0gPSByZXNbMF07XG4gICAgdmFyIGVzY2FwZWQgPSByZXNbMV07XG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleDtcbiAgICBwYXRoICs9IHN0ci5zbGljZShpbmRleCwgb2Zmc2V0KTtcbiAgICBpbmRleCA9IG9mZnNldCArIG0ubGVuZ3RoO1xuXG4gICAgLy8gSWdub3JlIGFscmVhZHkgZXNjYXBlZCBzZXF1ZW5jZXMuXG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBzdHJbaW5kZXhdO1xuICAgIHZhciBwcmVmaXggPSByZXNbMl07XG4gICAgdmFyIG5hbWUgPSByZXNbM107XG4gICAgdmFyIGNhcHR1cmUgPSByZXNbNF07XG4gICAgdmFyIGdyb3VwID0gcmVzWzVdO1xuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XTtcbiAgICB2YXIgYXN0ZXJpc2sgPSByZXNbN107XG5cbiAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHBhdGggb250byB0aGUgdG9rZW5zLlxuICAgIGlmIChwYXRoKSB7XG4gICAgICB0b2tlbnMucHVzaChwYXRoKTtcbiAgICAgIHBhdGggPSAnJztcbiAgICB9XG5cbiAgICB2YXIgcGFydGlhbCA9IHByZWZpeCAhPSBudWxsICYmIG5leHQgIT0gbnVsbCAmJiBuZXh0ICE9PSBwcmVmaXg7XG4gICAgdmFyIHJlcGVhdCA9IG1vZGlmaWVyID09PSAnKycgfHwgbW9kaWZpZXIgPT09ICcqJztcbiAgICB2YXIgb3B0aW9uYWwgPSBtb2RpZmllciA9PT0gJz8nIHx8IG1vZGlmaWVyID09PSAnKic7XG4gICAgdmFyIGRlbGltaXRlciA9IHJlc1syXSB8fCBkZWZhdWx0RGVsaW1pdGVyO1xuICAgIHZhciBwYXR0ZXJuID0gY2FwdHVyZSB8fCBncm91cDtcblxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICBwcmVmaXg6IHByZWZpeCB8fCAnJyxcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgYXN0ZXJpc2s6ICEhYXN0ZXJpc2ssXG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuID8gZXNjYXBlR3JvdXAocGF0dGVybikgOiAoYXN0ZXJpc2sgPyAnLionIDogJ1teJyArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpICsgJ10rPycpXG4gICAgfSk7XG4gIH1cblxuICAvLyBNYXRjaCBhbnkgY2hhcmFjdGVycyBzdGlsbCByZW1haW5pbmcuXG4gIGlmIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBwYXRoICs9IHN0ci5zdWJzdHIoaW5kZXgpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHBhdGggZXhpc3RzLCBwdXNoIGl0IG9udG8gdGhlIGVuZC5cbiAgaWYgKHBhdGgpIHtcbiAgICB0b2tlbnMucHVzaChwYXRoKTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucykpXG59XG5cbi8qKlxuICogUHJldHRpZXIgZW5jb2Rpbmcgb2YgVVJJIHBhdGggc2VnbWVudHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvW1xcLz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgdGhlIGFzdGVyaXNrIHBhcmFtZXRlci4gU2ltaWxhciB0byBgcHJldHR5YCwgYnV0IGFsbG93cyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zKSB7XG4gIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKTtcblxuICAvLyBDb21waWxlIGFsbCB0aGUgcGF0dGVybnMgYmVmb3JlIGNvbXBpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgdG9rZW5zW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgbWF0Y2hlc1tpXSA9IG5ldyBSZWdFeHAoJ14oPzonICsgdG9rZW5zW2ldLnBhdHRlcm4gKyAnKSQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuICAgIHZhciBwYXRoID0gJyc7XG4gICAgdmFyIGRhdGEgPSBvYmogfHwge307XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBlbmNvZGUgPSBvcHRpb25zLnByZXR0eSA/IGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSA6IGVuY29kZVVSSUNvbXBvbmVudDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhdGggKz0gdG9rZW47XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gZGF0YVt0b2tlbi5uYW1lXTtcbiAgICAgIHZhciBzZWdtZW50O1xuXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAvLyBQcmVwZW5kIHBhcnRpYWwgc2VnbWVudCBwcmVmaXhlcy5cbiAgICAgICAgICBpZiAodG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIGJlIGRlZmluZWQnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc2FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAoIXRva2VuLnJlcGVhdCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IHJlcGVhdCwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ2AnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgYmUgZW1wdHknKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzZWdtZW50ID0gZW5jb2RlKHZhbHVlW2pdKTtcblxuICAgICAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhbGwgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeShzZWdtZW50KSArICdgJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoICs9IChqID09PSAwID8gdG9rZW4ucHJlZml4IDogdG9rZW4uZGVsaW1pdGVyKSArIHNlZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBzZWdtZW50ID0gdG9rZW4uYXN0ZXJpc2sgPyBlbmNvZGVBc3Rlcmlzayh2YWx1ZSkgOiBlbmNvZGUodmFsdWUpO1xuXG4gICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBcIicgKyBzZWdtZW50ICsgJ1wiJylcbiAgICAgIH1cblxuICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoXG4gIH1cbn1cblxuLyoqXG4gKiBFc2NhcGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXxcXC9cXFxcXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XG4gIHJlLmtleXMgPSBrZXlzO1xuICByZXR1cm4gcmVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmbGFncyAob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJ1xufVxuXG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cCAocGF0aCwga2V5cykge1xuICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZyk7XG5cbiAgaWYgKGdyb3Vwcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiBpLFxuICAgICAgICBwcmVmaXg6IG51bGwsXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxuICAgICAgICBwYXJ0aWFsOiBmYWxzZSxcbiAgICAgICAgYXN0ZXJpc2s6IGZhbHNlLFxuICAgICAgICBwYXR0ZXJuOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChwYXRoVG9SZWdleHAocGF0aFtpXSwga2V5cywgb3B0aW9ucykuc291cmNlKTtcbiAgfVxuXG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSk7XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb1JlZ0V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gICAgICAgICAgdG9rZW5zXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19IGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKTtcbiAgICBrZXlzID0gW107XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2U7XG4gIHZhciByb3V0ZSA9ICcnO1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyh0b2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcodG9rZW4ucHJlZml4KTtcbiAgICAgIHZhciBjYXB0dXJlID0gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJyknO1xuXG4gICAgICBrZXlzLnB1c2godG9rZW4pO1xuXG4gICAgICBpZiAodG9rZW4ucmVwZWF0KSB7XG4gICAgICAgIGNhcHR1cmUgKz0gJyg/OicgKyBwcmVmaXggKyBjYXB0dXJlICsgJykqJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgIGlmICghdG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpPyc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknO1xuICAgICAgfVxuXG4gICAgICByb3V0ZSArPSBjYXB0dXJlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWxpbWl0ZXIgPSBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nKTtcbiAgdmFyIGVuZHNXaXRoRGVsaW1pdGVyID0gcm91dGUuc2xpY2UoLWRlbGltaXRlci5sZW5ndGgpID09PSBkZWxpbWl0ZXI7XG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoRGVsaW1pdGVyID8gcm91dGUuc2xpY2UoMCwgLWRlbGltaXRlci5sZW5ndGgpIDogcm91dGUpICsgJyg/OicgKyBkZWxpbWl0ZXIgKyAnKD89JCkpPyc7XG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgcm91dGUgKz0gJyQnO1xuICB9IGVsc2Uge1xuICAgIC8vIEluIG5vbi1lbmRpbmcgbW9kZSwgd2UgbmVlZCB0aGUgY2FwdHVyaW5nIGdyb3VwcyB0byBtYXRjaCBhcyBtdWNoIGFzXG4gICAgLy8gcG9zc2libGUgYnkgdXNpbmcgYSBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cbiAgICByb3V0ZSArPSBzdHJpY3QgJiYgZW5kc1dpdGhEZWxpbWl0ZXIgPyAnJyA6ICcoPz0nICsgZGVsaW1pdGVyICsgJ3wkKSc7XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoc3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucyk7XG4gICAga2V5cyA9IFtdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSlcbiAgfVxuXG4gIGlmIChpc2FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAoLyoqIEB0eXBlIHshQXJyYXl9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdUb1JlZ2V4cCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxufVxuXG5pbmRleC5wYXJzZSA9IHBhcnNlXzE7XG5pbmRleC5jb21waWxlID0gY29tcGlsZV8xO1xuaW5kZXgudG9rZW5zVG9GdW5jdGlvbiA9IHRva2Vuc1RvRnVuY3Rpb25fMTtcbmluZGV4LnRva2Vuc1RvUmVnRXhwID0gdG9rZW5zVG9SZWdFeHBfMTtcblxuLyogICovXG5cbnZhciByZWdleHBDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIGdldFJvdXRlUmVnZXggKHBhdGgpIHtcbiAgdmFyIGhpdCA9IHJlZ2V4cENhY2hlW3BhdGhdO1xuICB2YXIga2V5cywgcmVnZXhwO1xuXG4gIGlmIChoaXQpIHtcbiAgICBrZXlzID0gaGl0LmtleXM7XG4gICAgcmVnZXhwID0gaGl0LnJlZ2V4cDtcbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gW107XG4gICAgcmVnZXhwID0gaW5kZXgocGF0aCwga2V5cyk7XG4gICAgcmVnZXhwQ2FjaGVbcGF0aF0gPSB7IGtleXM6IGtleXMsIHJlZ2V4cDogcmVnZXhwIH07XG4gIH1cblxuICByZXR1cm4geyBrZXlzOiBrZXlzLCByZWdleHA6IHJlZ2V4cCB9XG59XG5cbnZhciByZWdleHBDb21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBmaWxsUGFyYW1zIChcbiAgcGF0aCxcbiAgcGFyYW1zLFxuICByb3V0ZU1zZ1xuKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZpbGxlciA9XG4gICAgICByZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gfHxcbiAgICAgIChyZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gPSBpbmRleC5jb21waWxlKHBhdGgpKTtcbiAgICByZXR1cm4gZmlsbGVyKHBhcmFtcyB8fCB7fSwgeyBwcmV0dHk6IHRydWUgfSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKGZhbHNlLCAoXCJtaXNzaW5nIHBhcmFtIGZvciBcIiArIHJvdXRlTXNnICsgXCI6IFwiICsgKGUubWVzc2FnZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2F0aW9uIChcbiAgcmF3LFxuICBjdXJyZW50LFxuICBhcHBlbmRcbikge1xuICB2YXIgbmV4dCA9IHR5cGVvZiByYXcgPT09ICdzdHJpbmcnID8geyBwYXRoOiByYXcgfSA6IHJhdztcbiAgLy8gbmFtZWQgdGFyZ2V0XG4gIGlmIChuZXh0Lm5hbWUgfHwgbmV4dC5fbm9ybWFsaXplZCkge1xuICAgIHJldHVybiBuZXh0XG4gIH1cblxuICAvLyByZWxhdGl2ZSBwYXJhbXNcbiAgaWYgKCFuZXh0LnBhdGggJiYgbmV4dC5wYXJhbXMgJiYgY3VycmVudCkge1xuICAgIG5leHQgPSBhc3NpZ24oe30sIG5leHQpO1xuICAgIG5leHQuX25vcm1hbGl6ZWQgPSB0cnVlO1xuICAgIHZhciBwYXJhbXMgPSBhc3NpZ24oYXNzaWduKHt9LCBjdXJyZW50LnBhcmFtcyksIG5leHQucGFyYW1zKTtcbiAgICBpZiAoY3VycmVudC5uYW1lKSB7XG4gICAgICBuZXh0Lm5hbWUgPSBjdXJyZW50Lm5hbWU7XG4gICAgICBuZXh0LnBhcmFtcyA9IHBhcmFtcztcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQubWF0Y2hlZCkge1xuICAgICAgdmFyIHJhd1BhdGggPSBjdXJyZW50Lm1hdGNoZWRbY3VycmVudC5tYXRjaGVkLmxlbmd0aCAtIDFdLnBhdGg7XG4gICAgICBuZXh0LnBhdGggPSBmaWxsUGFyYW1zKHJhd1BhdGgsIHBhcmFtcywgKFwicGF0aCBcIiArIChjdXJyZW50LnBhdGgpKSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKGZhbHNlLCBcInJlbGF0aXZlIHBhcmFtcyBuYXZpZ2F0aW9uIHJlcXVpcmVzIGEgY3VycmVudCByb3V0ZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBuZXh0XG4gIH1cblxuICB2YXIgcGFyc2VkUGF0aCA9IHBhcnNlUGF0aChuZXh0LnBhdGggfHwgJycpO1xuICB2YXIgYmFzZVBhdGggPSAoY3VycmVudCAmJiBjdXJyZW50LnBhdGgpIHx8ICcvJztcbiAgdmFyIHBhdGggPSBwYXJzZWRQYXRoLnBhdGhcbiAgICA/IHJlc29sdmVQYXRoKHBhcnNlZFBhdGgucGF0aCwgYmFzZVBhdGgsIGFwcGVuZCB8fCBuZXh0LmFwcGVuZClcbiAgICA6IChjdXJyZW50ICYmIGN1cnJlbnQucGF0aCkgfHwgJy8nO1xuICB2YXIgcXVlcnkgPSByZXNvbHZlUXVlcnkocGFyc2VkUGF0aC5xdWVyeSwgbmV4dC5xdWVyeSk7XG4gIHZhciBoYXNoID0gbmV4dC5oYXNoIHx8IHBhcnNlZFBhdGguaGFzaDtcbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykge1xuICAgIGhhc2ggPSBcIiNcIiArIGhhc2g7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgIHBhdGg6IHBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGhhc2g6IGhhc2hcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ24gKGEsIGIpIHtcbiAgZm9yICh2YXIga2V5IGluIGIpIHtcbiAgICBhW2tleV0gPSBiW2tleV07XG4gIH1cbiAgcmV0dXJuIGFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoZXIgKHJvdXRlcykge1xuICB2YXIgcmVmID0gY3JlYXRlUm91dGVNYXAocm91dGVzKTtcbiAgdmFyIHBhdGhNYXAgPSByZWYucGF0aE1hcDtcbiAgdmFyIG5hbWVNYXAgPSByZWYubmFtZU1hcDtcblxuICBmdW5jdGlvbiBhZGRSb3V0ZXMgKHJvdXRlcykge1xuICAgIGNyZWF0ZVJvdXRlTWFwKHJvdXRlcywgcGF0aE1hcCwgbmFtZU1hcCk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaCAoXG4gICAgcmF3LFxuICAgIGN1cnJlbnRSb3V0ZSxcbiAgICByZWRpcmVjdGVkRnJvbVxuICApIHtcbiAgICB2YXIgbG9jYXRpb24gPSBub3JtYWxpemVMb2NhdGlvbihyYXcsIGN1cnJlbnRSb3V0ZSk7XG4gICAgdmFyIG5hbWUgPSBsb2NhdGlvbi5uYW1lO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHZhciByZWNvcmQgPSBuYW1lTWFwW25hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihyZWNvcmQsIChcIlJvdXRlIHdpdGggbmFtZSAnXCIgKyBuYW1lICsgXCInIGRvZXMgbm90IGV4aXN0XCIpKTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJhbU5hbWVzID0gZ2V0Um91dGVSZWdleChyZWNvcmQucGF0aCkua2V5c1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICFrZXkub3B0aW9uYWw7IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5Lm5hbWU7IH0pO1xuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uLnBhcmFtcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgbG9jYXRpb24ucGFyYW1zID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50Um91dGUgJiYgdHlwZW9mIGN1cnJlbnRSb3V0ZS5wYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjdXJyZW50Um91dGUucGFyYW1zKSB7XG4gICAgICAgICAgaWYgKCEoa2V5IGluIGxvY2F0aW9uLnBhcmFtcykgJiYgcGFyYW1OYW1lcy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICAgICAgbG9jYXRpb24ucGFyYW1zW2tleV0gPSBjdXJyZW50Um91dGUucGFyYW1zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgbG9jYXRpb24ucGF0aCA9IGZpbGxQYXJhbXMocmVjb3JkLnBhdGgsIGxvY2F0aW9uLnBhcmFtcywgKFwibmFtZWQgcm91dGUgXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSk7XG4gICAgICAgIHJldHVybiBfY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRoKSB7XG4gICAgICBsb2NhdGlvbi5wYXJhbXMgPSB7fTtcbiAgICAgIGZvciAodmFyIHBhdGggaW4gcGF0aE1hcCkge1xuICAgICAgICBpZiAobWF0Y2hSb3V0ZShwYXRoLCBsb2NhdGlvbi5wYXJhbXMsIGxvY2F0aW9uLnBhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShwYXRoTWFwW3BhdGhdLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbm8gbWF0Y2hcbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVkaXJlY3QgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvblxuICApIHtcbiAgICB2YXIgb3JpZ2luYWxSZWRpcmVjdCA9IHJlY29yZC5yZWRpcmVjdDtcbiAgICB2YXIgcmVkaXJlY3QgPSB0eXBlb2Ygb3JpZ2luYWxSZWRpcmVjdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IG9yaWdpbmFsUmVkaXJlY3QoY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbikpXG4gICAgICAgIDogb3JpZ2luYWxSZWRpcmVjdDtcblxuICAgIGlmICh0eXBlb2YgcmVkaXJlY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZWRpcmVjdCA9IHsgcGF0aDogcmVkaXJlY3QgfTtcbiAgICB9XG5cbiAgICBpZiAoIXJlZGlyZWN0IHx8IHR5cGVvZiByZWRpcmVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgZmFsc2UsIChcImludmFsaWQgcmVkaXJlY3Qgb3B0aW9uOiBcIiArIChKU09OLnN0cmluZ2lmeShyZWRpcmVjdCkpKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gICAgfVxuXG4gICAgdmFyIHJlID0gcmVkaXJlY3Q7XG4gICAgdmFyIG5hbWUgPSByZS5uYW1lO1xuICAgIHZhciBwYXRoID0gcmUucGF0aDtcbiAgICB2YXIgcXVlcnkgPSBsb2NhdGlvbi5xdWVyeTtcbiAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gICAgdmFyIHBhcmFtcyA9IGxvY2F0aW9uLnBhcmFtcztcbiAgICBxdWVyeSA9IHJlLmhhc093blByb3BlcnR5KCdxdWVyeScpID8gcmUucXVlcnkgOiBxdWVyeTtcbiAgICBoYXNoID0gcmUuaGFzT3duUHJvcGVydHkoJ2hhc2gnKSA/IHJlLmhhc2ggOiBoYXNoO1xuICAgIHBhcmFtcyA9IHJlLmhhc093blByb3BlcnR5KCdwYXJhbXMnKSA/IHJlLnBhcmFtcyA6IHBhcmFtcztcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICAvLyByZXNvbHZlZCBuYW1lZCBkaXJlY3RcbiAgICAgIHZhciB0YXJnZXRSZWNvcmQgPSBuYW1lTWFwW25hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KHRhcmdldFJlY29yZCwgKFwicmVkaXJlY3QgZmFpbGVkOiBuYW1lZCByb3V0ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIG5vdCBmb3VuZC5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoKHtcbiAgICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgIH0sIHVuZGVmaW5lZCwgbG9jYXRpb24pXG4gICAgfSBlbHNlIGlmIChwYXRoKSB7XG4gICAgICAvLyAxLiByZXNvbHZlIHJlbGF0aXZlIHJlZGlyZWN0XG4gICAgICB2YXIgcmF3UGF0aCA9IHJlc29sdmVSZWNvcmRQYXRoKHBhdGgsIHJlY29yZCk7XG4gICAgICAvLyAyLiByZXNvbHZlIHBhcmFtc1xuICAgICAgdmFyIHJlc29sdmVkUGF0aCA9IGZpbGxQYXJhbXMocmF3UGF0aCwgcGFyYW1zLCAoXCJyZWRpcmVjdCByb3V0ZSB3aXRoIHBhdGggXFxcIlwiICsgcmF3UGF0aCArIFwiXFxcIlwiKSk7XG4gICAgICAvLyAzLiByZW1hdGNoIHdpdGggZXhpc3RpbmcgcXVlcnkgYW5kIGhhc2hcbiAgICAgIHJldHVybiBtYXRjaCh7XG4gICAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICBwYXRoOiByZXNvbHZlZFBhdGgsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaFxuICAgICAgfSwgdW5kZWZpbmVkLCBsb2NhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihmYWxzZSwgKFwiaW52YWxpZCByZWRpcmVjdCBvcHRpb246IFwiICsgKEpTT04uc3RyaW5naWZ5KHJlZGlyZWN0KSkpKTtcbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWxpYXMgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvbixcbiAgICBtYXRjaEFzXG4gICkge1xuICAgIHZhciBhbGlhc2VkUGF0aCA9IGZpbGxQYXJhbXMobWF0Y2hBcywgbG9jYXRpb24ucGFyYW1zLCAoXCJhbGlhc2VkIHJvdXRlIHdpdGggcGF0aCBcXFwiXCIgKyBtYXRjaEFzICsgXCJcXFwiXCIpKTtcbiAgICB2YXIgYWxpYXNlZE1hdGNoID0gbWF0Y2goe1xuICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICBwYXRoOiBhbGlhc2VkUGF0aFxuICAgIH0pO1xuICAgIGlmIChhbGlhc2VkTWF0Y2gpIHtcbiAgICAgIHZhciBtYXRjaGVkID0gYWxpYXNlZE1hdGNoLm1hdGNoZWQ7XG4gICAgICB2YXIgYWxpYXNlZFJlY29yZCA9IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXTtcbiAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IGFsaWFzZWRNYXRjaC5wYXJhbXM7XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKGFsaWFzZWRSZWNvcmQsIGxvY2F0aW9uKVxuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZVJvdXRlIChcbiAgICByZWNvcmQsXG4gICAgbG9jYXRpb24sXG4gICAgcmVkaXJlY3RlZEZyb21cbiAgKSB7XG4gICAgaWYgKHJlY29yZCAmJiByZWNvcmQucmVkaXJlY3QpIHtcbiAgICAgIHJldHVybiByZWRpcmVjdChyZWNvcmQsIHJlZGlyZWN0ZWRGcm9tIHx8IGxvY2F0aW9uKVxuICAgIH1cbiAgICBpZiAocmVjb3JkICYmIHJlY29yZC5tYXRjaEFzKSB7XG4gICAgICByZXR1cm4gYWxpYXMocmVjb3JkLCBsb2NhdGlvbiwgcmVjb3JkLm1hdGNoQXMpXG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSlcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWF0Y2g6IG1hdGNoLFxuICAgIGFkZFJvdXRlczogYWRkUm91dGVzXG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hSb3V0ZSAoXG4gIHBhdGgsXG4gIHBhcmFtcyxcbiAgcGF0aG5hbWVcbikge1xuICB2YXIgcmVmID0gZ2V0Um91dGVSZWdleChwYXRoKTtcbiAgdmFyIHJlZ2V4cCA9IHJlZi5yZWdleHA7XG4gIHZhciBrZXlzID0gcmVmLmtleXM7XG4gIHZhciBtID0gcGF0aG5hbWUubWF0Y2gocmVnZXhwKTtcblxuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBtLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaSAtIDFdO1xuICAgIHZhciB2YWwgPSB0eXBlb2YgbVtpXSA9PT0gJ3N0cmluZycgPyBkZWNvZGVVUklDb21wb25lbnQobVtpXSkgOiBtW2ldO1xuICAgIGlmIChrZXkpIHsgcGFyYW1zW2tleS5uYW1lXSA9IHZhbDsgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJlY29yZFBhdGggKHBhdGgsIHJlY29yZCkge1xuICByZXR1cm4gcmVzb2x2ZVBhdGgocGF0aCwgcmVjb3JkLnBhcmVudCA/IHJlY29yZC5wYXJlbnQucGF0aCA6ICcvJywgdHJ1ZSlcbn1cblxuLyogICovXG5cblxudmFyIHBvc2l0aW9uU3RvcmUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBzZXR1cFNjcm9sbCAoKSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgc2F2ZVNjcm9sbFBvc2l0aW9uKCk7XG4gICAgaWYgKGUuc3RhdGUgJiYgZS5zdGF0ZS5rZXkpIHtcbiAgICAgIHNldFN0YXRlS2V5KGUuc3RhdGUua2V5KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTY3JvbGwgKFxuICByb3V0ZXIsXG4gIHRvLFxuICBmcm9tLFxuICBpc1BvcFxuKSB7XG4gIGlmICghcm91dGVyLmFwcCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJlaGF2aW9yID0gcm91dGVyLm9wdGlvbnMuc2Nyb2xsQmVoYXZpb3I7XG4gIGlmICghYmVoYXZpb3IpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiZWhhdmlvciA9PT0gJ2Z1bmN0aW9uJywgXCJzY3JvbGxCZWhhdmlvciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICAvLyB3YWl0IHVudGlsIHJlLXJlbmRlciBmaW5pc2hlcyBiZWZvcmUgc2Nyb2xsaW5nXG4gIHJvdXRlci5hcHAuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBnZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIHZhciBzaG91bGRTY3JvbGwgPSBiZWhhdmlvcih0bywgZnJvbSwgaXNQb3AgPyBwb3NpdGlvbiA6IG51bGwpO1xuICAgIGlmICghc2hvdWxkU2Nyb2xsKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIGlzT2JqZWN0ID0gdHlwZW9mIHNob3VsZFNjcm9sbCA9PT0gJ29iamVjdCc7XG4gICAgaWYgKGlzT2JqZWN0ICYmIHR5cGVvZiBzaG91bGRTY3JvbGwuc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNob3VsZFNjcm9sbC5zZWxlY3Rvcik7XG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgcG9zaXRpb24gPSBnZXRFbGVtZW50UG9zaXRpb24oZWwpO1xuICAgICAgfSBlbHNlIGlmIChpc1ZhbGlkUG9zaXRpb24oc2hvdWxkU2Nyb2xsKSkge1xuICAgICAgICBwb3NpdGlvbiA9IG5vcm1hbGl6ZVBvc2l0aW9uKHNob3VsZFNjcm9sbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCAmJiBpc1ZhbGlkUG9zaXRpb24oc2hvdWxkU2Nyb2xsKSkge1xuICAgICAgcG9zaXRpb24gPSBub3JtYWxpemVQb3NpdGlvbihzaG91bGRTY3JvbGwpO1xuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgd2luZG93LnNjcm9sbFRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNhdmVTY3JvbGxQb3NpdGlvbiAoKSB7XG4gIHZhciBrZXkgPSBnZXRTdGF0ZUtleSgpO1xuICBpZiAoa2V5KSB7XG4gICAgcG9zaXRpb25TdG9yZVtrZXldID0ge1xuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxQb3NpdGlvbiAoKSB7XG4gIHZhciBrZXkgPSBnZXRTdGF0ZUtleSgpO1xuICBpZiAoa2V5KSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uU3RvcmVba2V5XVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRQb3NpdGlvbiAoZWwpIHtcbiAgdmFyIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgZG9jUmVjdCA9IGRvY0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgeDogZWxSZWN0LmxlZnQgLSBkb2NSZWN0LmxlZnQsXG4gICAgeTogZWxSZWN0LnRvcCAtIGRvY1JlY3QudG9wXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZFBvc2l0aW9uIChvYmopIHtcbiAgcmV0dXJuIGlzTnVtYmVyKG9iai54KSB8fCBpc051bWJlcihvYmoueSlcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUG9zaXRpb24gKG9iaikge1xuICByZXR1cm4ge1xuICAgIHg6IGlzTnVtYmVyKG9iai54KSA/IG9iai54IDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgIHk6IGlzTnVtYmVyKG9iai55KSA/IG9iai55IDogd2luZG93LnBhZ2VZT2Zmc2V0XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIgKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnbnVtYmVyJ1xufVxuXG4vKiAgKi9cblxudmFyIHN1cHBvcnRzUHVzaFN0YXRlID0gaW5Ccm93c2VyICYmIChmdW5jdGlvbiAoKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gIGlmIChcbiAgICAodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiZcbiAgICB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmXG4gICAgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmXG4gICAgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMVxuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeVxufSkoKTtcblxuLy8gdXNlIFVzZXIgVGltaW5nIGFwaSAoaWYgcHJlc2VudCkgZm9yIG1vcmUgYWNjdXJhdGUga2V5IHByZWNpc2lvblxudmFyIFRpbWUgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3dcbiAgPyB3aW5kb3cucGVyZm9ybWFuY2VcbiAgOiBEYXRlO1xuXG52YXIgX2tleSA9IGdlbktleSgpO1xuXG5mdW5jdGlvbiBnZW5LZXkgKCkge1xuICByZXR1cm4gVGltZS5ub3coKS50b0ZpeGVkKDMpXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlS2V5ICgpIHtcbiAgcmV0dXJuIF9rZXlcbn1cblxuZnVuY3Rpb24gc2V0U3RhdGVLZXkgKGtleSkge1xuICBfa2V5ID0ga2V5O1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhdGUgKHVybCwgcmVwbGFjZSkge1xuICBzYXZlU2Nyb2xsUG9zaXRpb24oKTtcbiAgLy8gdHJ5Li4uY2F0Y2ggdGhlIHB1c2hTdGF0ZSBjYWxsIHRvIGdldCBhcm91bmQgU2FmYXJpXG4gIC8vIERPTSBFeGNlcHRpb24gMTggd2hlcmUgaXQgbGltaXRzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHNcbiAgdmFyIGhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdHJ5IHtcbiAgICBpZiAocmVwbGFjZSkge1xuICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXk6IF9rZXkgfSwgJycsIHVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9rZXkgPSBnZW5LZXkoKTtcbiAgICAgIGhpc3RvcnkucHVzaFN0YXRlKHsga2V5OiBfa2V5IH0sICcnLCB1cmwpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHdpbmRvdy5sb2NhdGlvbltyZXBsYWNlID8gJ3JlcGxhY2UnIDogJ2Fzc2lnbiddKHVybCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZVN0YXRlICh1cmwpIHtcbiAgcHVzaFN0YXRlKHVybCwgdHJ1ZSk7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBydW5RdWV1ZSAocXVldWUsIGZuLCBjYikge1xuICB2YXIgc3RlcCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIGlmIChpbmRleCA+PSBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNiKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChxdWV1ZVtpbmRleF0pIHtcbiAgICAgICAgZm4ocXVldWVbaW5kZXhdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RlcChpbmRleCArIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZXAoaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHN0ZXAoMCk7XG59XG5cbi8qICAqL1xuXG5cbnZhciBIaXN0b3J5ID0gZnVuY3Rpb24gSGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gIHRoaXMucm91dGVyID0gcm91dGVyO1xuICB0aGlzLmJhc2UgPSBub3JtYWxpemVCYXNlKGJhc2UpO1xuICAvLyBzdGFydCB3aXRoIGEgcm91dGUgb2JqZWN0IHRoYXQgc3RhbmRzIGZvciBcIm5vd2hlcmVcIlxuICB0aGlzLmN1cnJlbnQgPSBTVEFSVDtcbiAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICB0aGlzLnJlYWR5Q2JzID0gW107XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4gKGNiKSB7XG4gIHRoaXMuY2IgPSBjYjtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLm9uUmVhZHkgPSBmdW5jdGlvbiBvblJlYWR5IChjYikge1xuICBpZiAodGhpcy5yZWFkeSkge1xuICAgIGNiKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZWFkeUNicy5wdXNoKGNiKTtcbiAgfVxufTtcblxuSGlzdG9yeS5wcm90b3R5cGUudHJhbnNpdGlvblRvID0gZnVuY3Rpb24gdHJhbnNpdGlvblRvIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciByb3V0ZSA9IHRoaXMucm91dGVyLm1hdGNoKGxvY2F0aW9uLCB0aGlzLmN1cnJlbnQpO1xuICB0aGlzLmNvbmZpcm1UcmFuc2l0aW9uKHJvdXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcyQxLnVwZGF0ZVJvdXRlKHJvdXRlKTtcbiAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIHRoaXMkMS5lbnN1cmVVUkwoKTtcblxuICAgIC8vIGZpcmUgcmVhZHkgY2JzIG9uY2VcbiAgICBpZiAoIXRoaXMkMS5yZWFkeSkge1xuICAgICAgdGhpcyQxLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMkMS5yZWFkeUNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgICBjYihyb3V0ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIG9uQWJvcnQpO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUuY29uZmlybVRyYW5zaXRpb24gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvbiAocm91dGUsIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKCkgeyBvbkFib3J0ICYmIG9uQWJvcnQoKTsgfTtcbiAgaWYgKFxuICAgIGlzU2FtZVJvdXRlKHJvdXRlLCBjdXJyZW50KSAmJlxuICAgIC8vIGluIHRoZSBjYXNlIHRoZSByb3V0ZSBtYXAgaGFzIGJlZW4gZHluYW1pY2FsbHkgYXBwZW5kZWQgdG9cbiAgICByb3V0ZS5tYXRjaGVkLmxlbmd0aCA9PT0gY3VycmVudC5tYXRjaGVkLmxlbmd0aFxuICApIHtcbiAgICB0aGlzLmVuc3VyZVVSTCgpO1xuICAgIHJldHVybiBhYm9ydCgpXG4gIH1cblxuICB2YXIgcmVmID0gcmVzb2x2ZVF1ZXVlKHRoaXMuY3VycmVudC5tYXRjaGVkLCByb3V0ZS5tYXRjaGVkKTtcbiAgICB2YXIgdXBkYXRlZCA9IHJlZi51cGRhdGVkO1xuICAgIHZhciBkZWFjdGl2YXRlZCA9IHJlZi5kZWFjdGl2YXRlZDtcbiAgICB2YXIgYWN0aXZhdGVkID0gcmVmLmFjdGl2YXRlZDtcblxuICB2YXIgcXVldWUgPSBbXS5jb25jYXQoXG4gICAgLy8gaW4tY29tcG9uZW50IGxlYXZlIGd1YXJkc1xuICAgIGV4dHJhY3RMZWF2ZUd1YXJkcyhkZWFjdGl2YXRlZCksXG4gICAgLy8gZ2xvYmFsIGJlZm9yZSBob29rc1xuICAgIHRoaXMucm91dGVyLmJlZm9yZUhvb2tzLFxuICAgIC8vIGluLWNvbXBvbmVudCB1cGRhdGUgaG9va3NcbiAgICBleHRyYWN0VXBkYXRlSG9va3ModXBkYXRlZCksXG4gICAgLy8gaW4tY29uZmlnIGVudGVyIGd1YXJkc1xuICAgIGFjdGl2YXRlZC5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uYmVmb3JlRW50ZXI7IH0pLFxuICAgIC8vIGFzeW5jIGNvbXBvbmVudHNcbiAgICByZXNvbHZlQXN5bmNDb21wb25lbnRzKGFjdGl2YXRlZClcbiAgKTtcblxuICB0aGlzLnBlbmRpbmcgPSByb3V0ZTtcbiAgdmFyIGl0ZXJhdG9yID0gZnVuY3Rpb24gKGhvb2ssIG5leHQpIHtcbiAgICBpZiAodGhpcyQxLnBlbmRpbmcgIT09IHJvdXRlKSB7XG4gICAgICByZXR1cm4gYWJvcnQoKVxuICAgIH1cbiAgICBob29rKHJvdXRlLCBjdXJyZW50LCBmdW5jdGlvbiAodG8pIHtcbiAgICAgIGlmICh0byA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gbmV4dChmYWxzZSkgLT4gYWJvcnQgbmF2aWdhdGlvbiwgZW5zdXJlIGN1cnJlbnQgVVJMXG4gICAgICAgIHRoaXMkMS5lbnN1cmVVUkwodHJ1ZSk7XG4gICAgICAgIGFib3J0KCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0byA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHRvID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBuZXh0KCcvJykgb3IgbmV4dCh7IHBhdGg6ICcvJyB9KSAtPiByZWRpcmVjdFxuICAgICAgICAodHlwZW9mIHRvID09PSAnb2JqZWN0JyAmJiB0by5yZXBsYWNlKSA/IHRoaXMkMS5yZXBsYWNlKHRvKSA6IHRoaXMkMS5wdXNoKHRvKTtcbiAgICAgICAgYWJvcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbmZpcm0gdHJhbnNpdGlvbiBhbmQgcGFzcyBvbiB0aGUgdmFsdWVcbiAgICAgICAgbmV4dCh0byk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcnVuUXVldWUocXVldWUsIGl0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc3RFbnRlckNicyA9IFtdO1xuICAgIHZhciBpc1ZhbGlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLmN1cnJlbnQgPT09IHJvdXRlOyB9O1xuICAgIHZhciBlbnRlckd1YXJkcyA9IGV4dHJhY3RFbnRlckd1YXJkcyhhY3RpdmF0ZWQsIHBvc3RFbnRlckNicywgaXNWYWxpZCk7XG4gICAgLy8gd2FpdCB1bnRpbCBhc3luYyBjb21wb25lbnRzIGFyZSByZXNvbHZlZCBiZWZvcmVcbiAgICAvLyBleHRyYWN0aW5nIGluLWNvbXBvbmVudCBlbnRlciBndWFyZHNcbiAgICBydW5RdWV1ZShlbnRlckd1YXJkcywgaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzJDEucGVuZGluZyAhPT0gcm91dGUpIHtcbiAgICAgICAgcmV0dXJuIGFib3J0KClcbiAgICAgIH1cbiAgICAgIHRoaXMkMS5wZW5kaW5nID0gbnVsbDtcbiAgICAgIG9uQ29tcGxldGUocm91dGUpO1xuICAgICAgaWYgKHRoaXMkMS5yb3V0ZXIuYXBwKSB7XG4gICAgICAgIHRoaXMkMS5yb3V0ZXIuYXBwLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcG9zdEVudGVyQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYigpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUudXBkYXRlUm91dGUgPSBmdW5jdGlvbiB1cGRhdGVSb3V0ZSAocm91dGUpIHtcbiAgdmFyIHByZXYgPSB0aGlzLmN1cnJlbnQ7XG4gIHRoaXMuY3VycmVudCA9IHJvdXRlO1xuICB0aGlzLmNiICYmIHRoaXMuY2Iocm91dGUpO1xuICB0aGlzLnJvdXRlci5hZnRlckhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICBob29rICYmIGhvb2socm91dGUsIHByZXYpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUJhc2UgKGJhc2UpIHtcbiAgaWYgKCFiYXNlKSB7XG4gICAgaWYgKGluQnJvd3Nlcikge1xuICAgICAgLy8gcmVzcGVjdCA8YmFzZT4gdGFnXG4gICAgICB2YXIgYmFzZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpO1xuICAgICAgYmFzZSA9IChiYXNlRWwgJiYgYmFzZUVsLmdldEF0dHJpYnV0ZSgnaHJlZicpKSB8fCAnLyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSAnLyc7XG4gICAgfVxuICB9XG4gIC8vIG1ha2Ugc3VyZSB0aGVyZSdzIHRoZSBzdGFydGluZyBzbGFzaFxuICBpZiAoYmFzZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgIGJhc2UgPSAnLycgKyBiYXNlO1xuICB9XG4gIC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICByZXR1cm4gYmFzZS5yZXBsYWNlKC9cXC8kLywgJycpXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVRdWV1ZSAoXG4gIGN1cnJlbnQsXG4gIG5leHRcbikge1xuICB2YXIgaTtcbiAgdmFyIG1heCA9IE1hdGgubWF4KGN1cnJlbnQubGVuZ3RoLCBuZXh0Lmxlbmd0aCk7XG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIGlmIChjdXJyZW50W2ldICE9PSBuZXh0W2ldKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHVwZGF0ZWQ6IG5leHQuc2xpY2UoMCwgaSksXG4gICAgYWN0aXZhdGVkOiBuZXh0LnNsaWNlKGkpLFxuICAgIGRlYWN0aXZhdGVkOiBjdXJyZW50LnNsaWNlKGkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEd1YXJkcyAoXG4gIHJlY29yZHMsXG4gIG5hbWUsXG4gIGJpbmQsXG4gIHJldmVyc2Vcbikge1xuICB2YXIgZ3VhcmRzID0gZmxhdE1hcENvbXBvbmVudHMocmVjb3JkcywgZnVuY3Rpb24gKGRlZiwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpIHtcbiAgICB2YXIgZ3VhcmQgPSBleHRyYWN0R3VhcmQoZGVmLCBuYW1lKTtcbiAgICBpZiAoZ3VhcmQpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGd1YXJkKVxuICAgICAgICA/IGd1YXJkLm1hcChmdW5jdGlvbiAoZ3VhcmQpIHsgcmV0dXJuIGJpbmQoZ3VhcmQsIGluc3RhbmNlLCBtYXRjaCwga2V5KTsgfSlcbiAgICAgICAgOiBiaW5kKGd1YXJkLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSlcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZmxhdHRlbihyZXZlcnNlID8gZ3VhcmRzLnJldmVyc2UoKSA6IGd1YXJkcylcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEd1YXJkIChcbiAgZGVmLFxuICBrZXlcbikge1xuICBpZiAodHlwZW9mIGRlZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGV4dGVuZCBub3cgc28gdGhhdCBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkLlxuICAgIGRlZiA9IF9WdWUuZXh0ZW5kKGRlZik7XG4gIH1cbiAgcmV0dXJuIGRlZi5vcHRpb25zW2tleV1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdExlYXZlR3VhcmRzIChkZWFjdGl2YXRlZCkge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyhkZWFjdGl2YXRlZCwgJ2JlZm9yZVJvdXRlTGVhdmUnLCBiaW5kR3VhcmQsIHRydWUpXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RVcGRhdGVIb29rcyAodXBkYXRlZCkge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyh1cGRhdGVkLCAnYmVmb3JlUm91dGVVcGRhdGUnLCBiaW5kR3VhcmQpXG59XG5cbmZ1bmN0aW9uIGJpbmRHdWFyZCAoZ3VhcmQsIGluc3RhbmNlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBib3VuZFJvdXRlR3VhcmQgKCkge1xuICAgIHJldHVybiBndWFyZC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFbnRlckd1YXJkcyAoXG4gIGFjdGl2YXRlZCxcbiAgY2JzLFxuICBpc1ZhbGlkXG4pIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHMoYWN0aXZhdGVkLCAnYmVmb3JlUm91dGVFbnRlcicsIGZ1bmN0aW9uIChndWFyZCwgXywgbWF0Y2gsIGtleSkge1xuICAgIHJldHVybiBiaW5kRW50ZXJHdWFyZChndWFyZCwgbWF0Y2gsIGtleSwgY2JzLCBpc1ZhbGlkKVxuICB9KVxufVxuXG5mdW5jdGlvbiBiaW5kRW50ZXJHdWFyZCAoXG4gIGd1YXJkLFxuICBtYXRjaCxcbiAga2V5LFxuICBjYnMsXG4gIGlzVmFsaWRcbikge1xuICByZXR1cm4gZnVuY3Rpb24gcm91dGVFbnRlckd1YXJkICh0bywgZnJvbSwgbmV4dCkge1xuICAgIHJldHVybiBndWFyZCh0bywgZnJvbSwgZnVuY3Rpb24gKGNiKSB7XG4gICAgICBuZXh0KGNiKTtcbiAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2JzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vICM3NTBcbiAgICAgICAgICAvLyBpZiBhIHJvdXRlci12aWV3IGlzIHdyYXBwZWQgd2l0aCBhbiBvdXQtaW4gdHJhbnNpdGlvbixcbiAgICAgICAgICAvLyB0aGUgaW5zdGFuY2UgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCBhdCB0aGlzIHRpbWUuXG4gICAgICAgICAgLy8gd2Ugd2lsbCBuZWVkIHRvIHBvbGwgZm9yIHJlZ2lzdHJhdGlvbiB1bnRpbCBjdXJyZW50IHJvdXRlXG4gICAgICAgICAgLy8gaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgICAgICAgIHBvbGwoY2IsIG1hdGNoLmluc3RhbmNlcywga2V5LCBpc1ZhbGlkKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwb2xsIChcbiAgY2IsIC8vIHNvbWVob3cgZmxvdyBjYW5ub3QgaW5mZXIgdGhpcyBpcyBhIGZ1bmN0aW9uXG4gIGluc3RhbmNlcyxcbiAga2V5LFxuICBpc1ZhbGlkXG4pIHtcbiAgaWYgKGluc3RhbmNlc1trZXldKSB7XG4gICAgY2IoaW5zdGFuY2VzW2tleV0pO1xuICB9IGVsc2UgaWYgKGlzVmFsaWQoKSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcG9sbChjYiwgaW5zdGFuY2VzLCBrZXksIGlzVmFsaWQpO1xuICAgIH0sIDE2KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnRzIChtYXRjaGVkKSB7XG4gIHJldHVybiBmbGF0TWFwQ29tcG9uZW50cyhtYXRjaGVkLCBmdW5jdGlvbiAoZGVmLCBfLCBtYXRjaCwga2V5KSB7XG4gICAgLy8gaWYgaXQncyBhIGZ1bmN0aW9uIGFuZCBkb2Vzbid0IGhhdmUgVnVlIG9wdGlvbnMgYXR0YWNoZWQsXG4gICAgLy8gYXNzdW1lIGl0J3MgYW4gYXN5bmMgY29tcG9uZW50IHJlc29sdmUgZnVuY3Rpb24uXG4gICAgLy8gd2UgYXJlIG5vdCB1c2luZyBWdWUncyBkZWZhdWx0IGFzeW5jIHJlc29sdmluZyBtZWNoYW5pc20gYmVjYXVzZVxuICAgIC8vIHdlIHdhbnQgdG8gaGFsdCB0aGUgbmF2aWdhdGlvbiB1bnRpbCB0aGUgaW5jb21pbmcgY29tcG9uZW50IGhhcyBiZWVuXG4gICAgLy8gcmVzb2x2ZWQuXG4gICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgIWRlZi5vcHRpb25zKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHRvLCBmcm9tLCBuZXh0KSB7XG4gICAgICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzb2x2ZWREZWYpIHtcbiAgICAgICAgICBtYXRjaC5jb21wb25lbnRzW2tleV0gPSByZXNvbHZlZERlZjtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICB3YXJuKGZhbHNlLCAoXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQgXCIgKyBrZXkgKyBcIjogXCIgKyByZWFzb24pKTtcbiAgICAgICAgICBuZXh0KGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlcyA9IGRlZihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGZsYXRNYXBDb21wb25lbnRzIChcbiAgbWF0Y2hlZCxcbiAgZm5cbikge1xuICByZXR1cm4gZmxhdHRlbihtYXRjaGVkLm1hcChmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhtLmNvbXBvbmVudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBmbihcbiAgICAgIG0uY29tcG9uZW50c1trZXldLFxuICAgICAgbS5pbnN0YW5jZXNba2V5XSxcbiAgICAgIG0sIGtleVxuICAgICk7IH0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuIChhcnIpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycilcbn1cblxuLy8gaW4gV2VicGFjayAyLCByZXF1aXJlLmVuc3VyZSBub3cgYWxzbyByZXR1cm5zIGEgUHJvbWlzZVxuLy8gc28gdGhlIHJlc29sdmUvcmVqZWN0IGZ1bmN0aW9ucyBtYXkgZ2V0IGNhbGxlZCBhbiBleHRyYSB0aW1lXG4vLyBpZiB0aGUgdXNlciB1c2VzIGFuIGFycm93IGZ1bmN0aW9uIHNob3J0aGFuZCB0aGF0IGhhcHBlbnMgdG9cbi8vIHJldHVybiB0aGF0IFByb21pc2UuXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgeyByZXR1cm4gfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxufVxuXG4vKiAgKi9cblxuXG52YXIgSFRNTDVIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEhUTUw1SGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcblxuICAgIHZhciBleHBlY3RTY3JvbGwgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcblxuICAgIGlmIChleHBlY3RTY3JvbGwpIHtcbiAgICAgIHNldHVwU2Nyb2xsKCk7XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMkMS50cmFuc2l0aW9uVG8oZ2V0TG9jYXRpb24odGhpcyQxLmJhc2UpLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgaWYgKGV4cGVjdFNjcm9sbCkge1xuICAgICAgICAgIGhhbmRsZVNjcm9sbChyb3V0ZXIsIHJvdXRlLCB0aGlzJDEuY3VycmVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgSFRNTDVIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIVE1MNUhpc3Rvcnk7XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHB1c2hTdGF0ZShjbGVhblBhdGgodGhpcyQxLmJhc2UgKyByb3V0ZS5mdWxsUGF0aCkpO1xuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCB0aGlzJDEuY3VycmVudCwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmVwbGFjZVN0YXRlKGNsZWFuUGF0aCh0aGlzJDEuYmFzZSArIHJvdXRlLmZ1bGxQYXRoKSk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIHRoaXMkMS5jdXJyZW50LCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMIChwdXNoKSB7XG4gICAgaWYgKGdldExvY2F0aW9uKHRoaXMuYmFzZSkgIT09IHRoaXMuY3VycmVudC5mdWxsUGF0aCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBjbGVhblBhdGgodGhpcy5iYXNlICsgdGhpcy5jdXJyZW50LmZ1bGxQYXRoKTtcbiAgICAgIHB1c2ggPyBwdXNoU3RhdGUoY3VycmVudCkgOiByZXBsYWNlU3RhdGUoY3VycmVudCk7XG4gICAgfVxuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0TG9jYXRpb24odGhpcy5iYXNlKVxuICB9O1xuXG4gIHJldHVybiBIVE1MNUhpc3Rvcnk7XG59KEhpc3RvcnkpKTtcblxuZnVuY3Rpb24gZ2V0TG9jYXRpb24gKGJhc2UpIHtcbiAgdmFyIHBhdGggPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gIGlmIChiYXNlICYmIHBhdGguaW5kZXhPZihiYXNlKSA9PT0gMCkge1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKGJhc2UubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gKHBhdGggfHwgJy8nKSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggKyB3aW5kb3cubG9jYXRpb24uaGFzaFxufVxuXG4vKiAgKi9cblxuXG52YXIgSGFzaEhpc3RvcnkgPSAoZnVuY3Rpb24gKEhpc3RvcnkkJDEpIHtcbiAgZnVuY3Rpb24gSGFzaEhpc3RvcnkgKHJvdXRlciwgYmFzZSwgZmFsbGJhY2spIHtcbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcbiAgICAvLyBjaGVjayBoaXN0b3J5IGZhbGxiYWNrIGRlZXBsaW5raW5nXG4gICAgaWYgKGZhbGxiYWNrICYmIGNoZWNrRmFsbGJhY2sodGhpcy5iYXNlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVuc3VyZVNsYXNoKCk7XG4gIH1cblxuICBpZiAoIEhpc3RvcnkkJDEgKSBIYXNoSGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5JCQxO1xuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhhc2hIaXN0b3J5O1xuXG4gIC8vIHRoaXMgaXMgZGVsYXllZCB1bnRpbCB0aGUgYXBwIG1vdW50c1xuICAvLyB0byBhdm9pZCB0aGUgaGFzaGNoYW5nZSBsaXN0ZW5lciBiZWluZyBmaXJlZCB0b28gZWFybHlcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnNldHVwTGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0dXBMaXN0ZW5lcnMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWVuc3VyZVNsYXNoKCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzJDEudHJhbnNpdGlvblRvKGdldEhhc2goKSwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIHJlcGxhY2VIYXNoKHJvdXRlLmZ1bGxQYXRoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICBwdXNoSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICByZXBsYWNlSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAocHVzaCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50LmZ1bGxQYXRoO1xuICAgIGlmIChnZXRIYXNoKCkgIT09IGN1cnJlbnQpIHtcbiAgICAgIHB1c2ggPyBwdXNoSGFzaChjdXJyZW50KSA6IHJlcGxhY2VIYXNoKGN1cnJlbnQpO1xuICAgIH1cbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0SGFzaCgpXG4gIH07XG5cbiAgcmV0dXJuIEhhc2hIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbmZ1bmN0aW9uIGNoZWNrRmFsbGJhY2sgKGJhc2UpIHtcbiAgdmFyIGxvY2F0aW9uID0gZ2V0TG9jYXRpb24oYmFzZSk7XG4gIGlmICghL15cXC8jLy50ZXN0KGxvY2F0aW9uKSkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKFxuICAgICAgY2xlYW5QYXRoKGJhc2UgKyAnLyMnICsgbG9jYXRpb24pXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVNsYXNoICgpIHtcbiAgdmFyIHBhdGggPSBnZXRIYXNoKCk7XG4gIGlmIChwYXRoLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXBsYWNlSGFzaCgnLycgKyBwYXRoKTtcbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGdldEhhc2ggKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBpbmRleCA9IGhyZWYuaW5kZXhPZignIycpO1xuICByZXR1cm4gaW5kZXggPT09IC0xID8gJycgOiBocmVmLnNsaWNlKGluZGV4ICsgMSlcbn1cblxuZnVuY3Rpb24gcHVzaEhhc2ggKHBhdGgpIHtcbiAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlSGFzaCAocGF0aCkge1xuICB2YXIgaSA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJyMnKTtcbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoXG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYuc2xpY2UoMCwgaSA+PSAwID8gaSA6IDApICsgJyMnICsgcGF0aFxuICApO1xufVxuXG4vKiAgKi9cblxuXG52YXIgQWJzdHJhY3RIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEFic3RyYWN0SGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgfVxuXG4gIGlmICggSGlzdG9yeSQkMSApIEFic3RyYWN0SGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5JCQxO1xuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSQkMSAmJiBIaXN0b3J5JCQxLnByb3RvdHlwZSApO1xuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWJzdHJhY3RIaXN0b3J5O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICB0aGlzJDEuc3RhY2sgPSB0aGlzJDEuc3RhY2suc2xpY2UoMCwgdGhpcyQxLmluZGV4ICsgMSkuY29uY2F0KHJvdXRlKTtcbiAgICAgIHRoaXMkMS5pbmRleCsrO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgdGhpcyQxLnN0YWNrID0gdGhpcyQxLnN0YWNrLnNsaWNlKDAsIHRoaXMkMS5pbmRleCkuY29uY2F0KHJvdXRlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdGFyZ2V0SW5kZXggPSB0aGlzLmluZGV4ICsgbjtcbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwIHx8IHRhcmdldEluZGV4ID49IHRoaXMuc3RhY2subGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHJvdXRlID0gdGhpcy5zdGFja1t0YXJnZXRJbmRleF07XG4gICAgdGhpcy5jb25maXJtVHJhbnNpdGlvbihyb3V0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcyQxLmluZGV4ID0gdGFyZ2V0SW5kZXg7XG4gICAgICB0aGlzJDEudXBkYXRlUm91dGUocm91dGUpO1xuICAgIH0pO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gY3VycmVudCA/IGN1cnJlbnQuZnVsbFBhdGggOiAnLydcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAoKSB7XG4gICAgLy8gbm9vcFxuICB9O1xuXG4gIHJldHVybiBBYnN0cmFjdEhpc3Rvcnk7XG59KEhpc3RvcnkpKTtcblxuLyogICovXG5cbnZhciBWdWVSb3V0ZXIgPSBmdW5jdGlvbiBWdWVSb3V0ZXIgKG9wdGlvbnMpIHtcbiAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgdGhpcy5hcHAgPSBudWxsO1xuICB0aGlzLmFwcHMgPSBbXTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5iZWZvcmVIb29rcyA9IFtdO1xuICB0aGlzLmFmdGVySG9va3MgPSBbXTtcbiAgdGhpcy5tYXRjaGVyID0gY3JlYXRlTWF0Y2hlcihvcHRpb25zLnJvdXRlcyB8fCBbXSk7XG5cbiAgdmFyIG1vZGUgPSBvcHRpb25zLm1vZGUgfHwgJ2hhc2gnO1xuICB0aGlzLmZhbGxiYWNrID0gbW9kZSA9PT0gJ2hpc3RvcnknICYmICFzdXBwb3J0c1B1c2hTdGF0ZTtcbiAgaWYgKHRoaXMuZmFsbGJhY2spIHtcbiAgICBtb2RlID0gJ2hhc2gnO1xuICB9XG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgbW9kZSA9ICdhYnN0cmFjdCc7XG4gIH1cbiAgdGhpcy5tb2RlID0gbW9kZTtcblxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlICdoaXN0b3J5JzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIVE1MNUhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSGFzaEhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlLCB0aGlzLmZhbGxiYWNrKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYWJzdHJhY3QnOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEFic3RyYWN0SGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UpO1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCAoXCJpbnZhbGlkIG1vZGU6IFwiICsgbW9kZSkpO1xuICAgICAgfVxuICB9XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjdXJyZW50Um91dGU6IHt9IH07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCAoXG4gIHJhdyxcbiAgY3VycmVudCxcbiAgcmVkaXJlY3RlZEZyb21cbikge1xuICByZXR1cm4gdGhpcy5tYXRjaGVyLm1hdGNoKHJhdywgY3VycmVudCwgcmVkaXJlY3RlZEZyb20pXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuY3VycmVudFJvdXRlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaGlzdG9yeSAmJiB0aGlzLmhpc3RvcnkuY3VycmVudFxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoYXBwIC8qIFZ1ZSBjb21wb25lbnQgaW5zdGFuY2UgKi8pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydChcbiAgICBpbnN0YWxsLmluc3RhbGxlZCxcbiAgICBcIm5vdCBpbnN0YWxsZWQuIE1ha2Ugc3VyZSB0byBjYWxsIGBWdWUudXNlKFZ1ZVJvdXRlcilgIFwiICtcbiAgICBcImJlZm9yZSBjcmVhdGluZyByb290IGluc3RhbmNlLlwiXG4gICk7XG5cbiAgdGhpcy5hcHBzLnB1c2goYXBwKTtcblxuICAvLyBtYWluIGFwcCBhbHJlYWR5IGluaXRpYWxpemVkLlxuICBpZiAodGhpcy5hcHApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMuYXBwID0gYXBwO1xuXG4gIHZhciBoaXN0b3J5ID0gdGhpcy5oaXN0b3J5O1xuXG4gIGlmIChoaXN0b3J5IGluc3RhbmNlb2YgSFRNTDVIaXN0b3J5KSB7XG4gICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gIH0gZWxzZSBpZiAoaGlzdG9yeSBpbnN0YW5jZW9mIEhhc2hIaXN0b3J5KSB7XG4gICAgdmFyIHNldHVwSGFzaExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgaGlzdG9yeS5zZXR1cExpc3RlbmVycygpO1xuICAgIH07XG4gICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oXG4gICAgICBoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpLFxuICAgICAgc2V0dXBIYXNoTGlzdGVuZXIsXG4gICAgICBzZXR1cEhhc2hMaXN0ZW5lclxuICAgICk7XG4gIH1cblxuICBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAocm91dGUpIHtcbiAgICB0aGlzJDEuYXBwcy5mb3JFYWNoKGZ1bmN0aW9uIChhcHApIHtcbiAgICAgIGFwcC5fcm91dGUgPSByb3V0ZTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmJlZm9yZUVhY2ggPSBmdW5jdGlvbiBiZWZvcmVFYWNoIChmbikge1xuICB0aGlzLmJlZm9yZUhvb2tzLnB1c2goZm4pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5hZnRlckVhY2ggPSBmdW5jdGlvbiBhZnRlckVhY2ggKGZuKSB7XG4gIHRoaXMuYWZ0ZXJIb29rcy5wdXNoKGZuKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkgKGNiKSB7XG4gIHRoaXMuaGlzdG9yeS5vblJlYWR5KGNiKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gIHRoaXMuaGlzdG9yeS5wdXNoKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gIHRoaXMuaGlzdG9yeS5yZXBsYWNlKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICB0aGlzLmhpc3RvcnkuZ28obik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbiBiYWNrICgpIHtcbiAgdGhpcy5nbygtMSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiBmb3J3YXJkICgpIHtcbiAgdGhpcy5nbygxKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuZ2V0TWF0Y2hlZENvbXBvbmVudHMgPSBmdW5jdGlvbiBnZXRNYXRjaGVkQ29tcG9uZW50cyAodG8pIHtcbiAgdmFyIHJvdXRlID0gdG9cbiAgICA/IHRoaXMucmVzb2x2ZSh0bykucm91dGVcbiAgICA6IHRoaXMuY3VycmVudFJvdXRlO1xuICBpZiAoIXJvdXRlKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgcm91dGUubWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobS5jb21wb25lbnRzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIG0uY29tcG9uZW50c1trZXldXG4gICAgfSlcbiAgfSkpXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlIChcbiAgdG8sXG4gIGN1cnJlbnQsXG4gIGFwcGVuZFxuKSB7XG4gIHZhciBsb2NhdGlvbiA9IG5vcm1hbGl6ZUxvY2F0aW9uKHRvLCBjdXJyZW50IHx8IHRoaXMuaGlzdG9yeS5jdXJyZW50LCBhcHBlbmQpO1xuICB2YXIgcm91dGUgPSB0aGlzLm1hdGNoKGxvY2F0aW9uLCBjdXJyZW50KTtcbiAgdmFyIGZ1bGxQYXRoID0gcm91dGUucmVkaXJlY3RlZEZyb20gfHwgcm91dGUuZnVsbFBhdGg7XG4gIHZhciBiYXNlID0gdGhpcy5oaXN0b3J5LmJhc2U7XG4gIHZhciBocmVmID0gY3JlYXRlSHJlZihiYXNlLCBmdWxsUGF0aCwgdGhpcy5tb2RlKTtcbiAgcmV0dXJuIHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgcm91dGU6IHJvdXRlLFxuICAgIGhyZWY6IGhyZWYsXG4gICAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICBub3JtYWxpemVkVG86IGxvY2F0aW9uLFxuICAgIHJlc29sdmVkOiByb3V0ZVxuICB9XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmFkZFJvdXRlcyA9IGZ1bmN0aW9uIGFkZFJvdXRlcyAocm91dGVzKSB7XG4gIHRoaXMubWF0Y2hlci5hZGRSb3V0ZXMocm91dGVzKTtcbiAgaWYgKHRoaXMuaGlzdG9yeS5jdXJyZW50ICE9PSBTVEFSVCkge1xuICAgIHRoaXMuaGlzdG9yeS50cmFuc2l0aW9uVG8odGhpcy5oaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZ1ZVJvdXRlci5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG5mdW5jdGlvbiBjcmVhdGVIcmVmIChiYXNlLCBmdWxsUGF0aCwgbW9kZSkge1xuICB2YXIgcGF0aCA9IG1vZGUgPT09ICdoYXNoJyA/ICcjJyArIGZ1bGxQYXRoIDogZnVsbFBhdGg7XG4gIHJldHVybiBiYXNlID8gY2xlYW5QYXRoKGJhc2UgKyAnLycgKyBwYXRoKSA6IHBhdGhcbn1cblxuVnVlUm91dGVyLmluc3RhbGwgPSBpbnN0YWxsO1xuVnVlUm91dGVyLnZlcnNpb24gPSAnMi4yLjEnO1xuXG5pZiAoaW5Ccm93c2VyICYmIHdpbmRvdy5WdWUpIHtcbiAgd2luZG93LlZ1ZS51c2UoVnVlUm91dGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVnVlUm91dGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi92dWUtcm91dGVyL2Rpc3QvdnVlLXJvdXRlci5lc20uanMiLCIvKiFcbiAqIFZ1ZS5qcyB2Mi4yLjRcbiAqIChjKSAyMDE0LTIwMTcgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuLyogICovXG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIF90b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvKFteLV0pKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHJcbiAgICAucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJylcbiAgICAucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJylcbiAgICAudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuICovXG5mdW5jdGlvbiBiaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIGZuIGxlbmd0aFxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIE9CSkVDVF9TVFJJTkcgPSAnW29iamVjdCBPYmplY3RdJztcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSBPQkpFQ1RfU1RSSU5HXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogUmV0dXJuIHNhbWUgdmFsdWVcbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHBvc3NpYmxlIGNpcmN1bGFyIHJlZmVyZW5jZVxuICAgICAgcmV0dXJuIGEgPT09IGJcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4oKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBjb25maWcgPSB7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXNzZXQgdHlwZXMgdGhhdCBhIGNvbXBvbmVudCBjYW4gb3duLlxuICAgKi9cbiAgX2Fzc2V0VHlwZXM6IFtcbiAgICAnY29tcG9uZW50JyxcbiAgICAnZGlyZWN0aXZlJyxcbiAgICAnZmlsdGVyJ1xuICBdLFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGxpZmVjeWNsZSBob29rcy5cbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogW1xuICAgICdiZWZvcmVDcmVhdGUnLFxuICAgICdjcmVhdGVkJyxcbiAgICAnYmVmb3JlTW91bnQnLFxuICAgICdtb3VudGVkJyxcbiAgICAnYmVmb3JlVXBkYXRlJyxcbiAgICAndXBkYXRlZCcsXG4gICAgJ2JlZm9yZURlc3Ryb3knLFxuICAgICdkZXN0cm95ZWQnLFxuICAgICdhY3RpdmF0ZWQnLFxuICAgICdkZWFjdGl2YXRlZCdcbiAgXSxcblxuICAvKipcbiAgICogTWF4IGNpcmN1bGFyIHVwZGF0ZXMgYWxsb3dlZCBpbiBhIHNjaGVkdWxlciBmbHVzaCBjeWNsZS5cbiAgICovXG4gIF9tYXhVcGRhdGVDb3VudDogMTAwXG59O1xuXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cbi8qIGdsb2JhbHMgTXV0YXRpb25PYnNlcnZlciAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbnZhciBpc0FuZHJvaWQgPSBVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwO1xudmFyIGlzSU9TID0gVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxuLyoqXG4gKiBEZWZlciBhIHRhc2sgdG8gZXhlY3V0ZSBpdCBhc3luY2hyb25vdXNseS5cbiAqL1xudmFyIG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgdGltZXJGdW5jO1xuXG4gIGZ1bmN0aW9uIG5leHRUaWNrSGFuZGxlciAoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG4gIC8vIHZpYSBlaXRoZXIgbmF0aXZlIFByb21pc2UudGhlbiBvciBNdXRhdGlvbk9ic2VydmVyLlxuICAvLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbiAgLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcbiAgLy8gY29tcGxldGVseSBzdG9wcyB3b3JraW5nIGFmdGVyIHRyaWdnZXJpbmcgYSBmZXcgdGltZXMuLi4gc28sIGlmIG5hdGl2ZVxuICAvLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB2YXIgbG9nRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgfTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwLnRoZW4obmV4dFRpY2tIYW5kbGVyKS5jYXRjaChsb2dFcnJvcik7XG4gICAgICAvLyBpbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAgIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICAgIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSdcbiAgKSkge1xuICAgIC8vIHVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gICAgLy8gZS5nLiBQaGFudG9tSlMgSUUxMSwgaU9TNywgQW5kcm9pZCA0LjRcbiAgICB2YXIgY291bnRlciA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobmV4dFRpY2tIYW5kbGVyKTtcbiAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICAgIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gc2V0VGltZW91dFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChuZXh0VGlja0hhbmRsZXIsIDApO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcXVldWVOZXh0VGljayAoY2IsIGN0eCkge1xuICAgIHZhciBfcmVzb2x2ZTtcbiAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY2IpIHsgY2IuY2FsbChjdHgpOyB9XG4gICAgICBpZiAoX3Jlc29sdmUpIHsgX3Jlc29sdmUoY3R4KTsgfVxuICAgIH0pO1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICB0aW1lckZ1bmMoKTtcbiAgICB9XG4gICAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB9KVxuICAgIH1cbiAgfVxufSkoKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBmb3JtYXRDb21wb25lbnROYW1lO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIFwiIFwiICsgKFxuICAgICAgICB2bSA/IGZvcm1hdExvY2F0aW9uKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgXCIgXCIgKyAoXG4gICAgICAgIHZtID8gZm9ybWF0TG9jYXRpb24oZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5vcHRpb25zXG4gICAgICA/IHZtLm9wdGlvbnMubmFtZVxuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucy5uYW1lIHx8IHZtLiRvcHRpb25zLl9jb21wb25lbnRUYWdcbiAgICAgICAgOiB2bS5uYW1lO1xuXG4gICAgdmFyIGZpbGUgPSB2bS5faXNWdWUgJiYgdm0uJG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgZm9ybWF0TG9jYXRpb24gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gXCI8QW5vbnltb3VzPlwiKSB7XG4gICAgICBzdHIgKz0gXCIgLSB1c2UgdGhlIFxcXCJuYW1lXFxcIiBvcHRpb24gZm9yIGJldHRlciBkZWJ1Z2dpbmcgbWVzc2FnZXMuXCI7XG4gICAgfVxuICAgIHJldHVybiAoXCJcXG4oZm91bmQgaW4gXCIgKyBzdHIgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cblxudmFyIHVpZCQxID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkJDErKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXVxuLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIC8vIGF2b2lkIGxlYWtpbmcgYXJndW1lbnRzOlxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb3N1cmUtd2l0aC1hcmd1bWVudHNcbiAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50cyQxW2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcbiAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciB3aGVuIHBhc3NpbmcgZG93biBwcm9wcyxcbiAqIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvbiBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYmUgYSBuZXN0ZWQgdmFsdWVcbiAqIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLiBDb252ZXJ0aW5nIGl0IHdvdWxkIGRlZmVhdCB0aGUgb3B0aW1pemF0aW9uLlxuICovXG52YXIgb2JzZXJ2ZXJTdGF0ZSA9IHtcbiAgc2hvdWxkQ29udmVydDogdHJ1ZSxcbiAgaXNTZXR0aW5nUHJvcHM6IGZhbHNlXG59O1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyXG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gIHZhciBjaGlsZE9iID0gb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSB0YXJnZXQuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9IHRhcmdldC5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICBjaGlsZFZhbC5jYWxsKHRoaXMpLFxuICAgICAgICBwYXJlbnRWYWwuY2FsbCh0aGlzKVxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJlbnRWYWwgfHwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWxcbn1cblxuY29uZmlnLl9saWZlY3ljbGVIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gICAgOiByZXNcbn1cblxuY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG59KTtcblxuLyoqXG4gKiBXYXRjaGVycy5cbiAqXG4gKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAqL1xuc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleV07XG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5XTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5XSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGV4dGVuZChyZXQsIGNoaWxkVmFsKTtcbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFyIGxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGlzQnVpbHRJblRhZyhsb3dlcikgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobG93ZXIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2lkOiAnICsga2V5XG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMpIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBpLCB2YWwsIG5hbWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG4gIHZhciBleHRlbmRzRnJvbSA9IGNoaWxkLmV4dGVuZHM7XG4gIGlmIChleHRlbmRzRnJvbSkge1xuICAgIHBhcmVudCA9IHR5cGVvZiBleHRlbmRzRnJvbSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbS5vcHRpb25zLCB2bSlcbiAgICAgIDogbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgbWl4aW4gPSBjaGlsZC5taXhpbnNbaV07XG4gICAgICBpZiAobWl4aW4ucHJvdG90eXBlIGluc3RhbmNlb2YgVnVlJDMpIHtcbiAgICAgICAgbWl4aW4gPSBtaXhpbi5vcHRpb25zO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgbWl4aW4sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gaGFuZGxlIGJvb2xlYW4gcHJvcHNcbiAgaWYgKGlzVHlwZShCb29sZWFuLCBwcm9wLnR5cGUpKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaXNUeXBlKFN0cmluZywgcHJvcC50eXBlKSAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRDb252ZXJ0ID0gb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0O1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gcHJldlNob3VsZENvbnZlcnQ7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicgK1xuICAgICAgJyBFeHBlY3RlZCAnICsgZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSArXG4gICAgICAnLCBnb3QgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpICsgJy4nLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhlIHR5cGUgb2YgYSB2YWx1ZVxuICovXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSAnU3RyaW5nJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ3N0cmluZycpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdudW1iZXInKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdCb29sZWFuJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ2Jvb2xlYW4nKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdGdW5jdGlvbicpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdmdW5jdGlvbicpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV1cbn1cblxuZnVuY3Rpb24gaXNUeXBlICh0eXBlLCBmbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZm4pKSB7XG4gICAgcmV0dXJuIGdldFR5cGUoZm4pID09PSBnZXRUeXBlKHR5cGUpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGdldFR5cGUoZm5baV0pID09PSBnZXRUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6XCIpLCB2bSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG52YXIgaW5pdFByb3h5O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgIFwicmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdG8gZGVjbGFyZSByZWFjdGl2ZSBkYXRhIFwiICtcbiAgICAgIFwicHJvcGVydGllcyBpbiB0aGUgZGF0YSBvcHRpb24uXCIsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIFByb3h5LnRvU3RyaW5nKCkubWF0Y2goL25hdGl2ZSBjb2RlLyk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YScpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gJ18nO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpO1xuICAgIH07XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zXG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZnVuY3Rpb25hbENvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDoge30gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9ICcnO1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnNcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbmZ1bmN0aW9uIGNsb25lVk5vZGVzICh2bm9kZXMpIHtcbiAgdmFyIGxlbiA9IHZub2Rlcy5sZW5ndGg7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc1tpXSA9IGNsb25lVk5vZGUodm5vZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZuc1tpXS5hcHBseShudWxsLCBhcmd1bWVudHMkMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGN1ciwgb2xkLCBldmVudDtcbiAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgY3VyID0gb25bbmFtZV07XG4gICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICBpZiAoIWN1cikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghb2xkKSB7XG4gICAgICBpZiAoIWN1ci5mbnMpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyKTtcbiAgICAgIH1cbiAgICAgIGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50Lm9uY2UsIGV2ZW50LmNhcHR1cmUpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKCFvbltuYW1lXSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIHZhciBpbnZva2VyO1xuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKCFvbGRIb29rKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKG9sZEhvb2suZm5zICYmIG9sZEhvb2subWVyZ2VkKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGksIGMsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoYyA9PSBudWxsIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpIHsgY29udGludWUgfVxuICAgIGxhc3QgPSByZXNbcmVzLmxlbmd0aCAtIDFdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSkpO1xuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcbiAgICAgIGlmIChsYXN0ICYmIGxhc3QudGV4dCkge1xuICAgICAgICBsYXN0LnRleHQgKz0gU3RyaW5nKGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYy50ZXh0ICYmIGxhc3QgJiYgbGFzdC50ZXh0KSB7XG4gICAgICAgIHJlc1tyZXMubGVuZ3RoIC0gMV0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChjLnRhZyAmJiBjLmtleSA9PSBudWxsICYmIG5lc3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgJiYgYy5jb21wb25lbnRPcHRpb25zOyB9KVswXVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuLCBvbmNlJCQxKSB7XG4gIGlmIChvbmNlJCQxKSB7XG4gICAgdGFyZ2V0LiRvbmNlKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgdm0pO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICB0aGlzJDEuJG9mZihldmVudFtpJDFdLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY2JzW2ldLmFwcGx5KHZtLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICB2YXIgZGVmYXVsdFNsb3QgPSBbXTtcbiAgdmFyIG5hbWUsIGNoaWxkO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mdW5jdGlvbmFsQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgICAgY2hpbGQuZGF0YSAmJiAobmFtZSA9IGNoaWxkLmRhdGEuc2xvdCkpIHtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWZhdWx0U2xvdC5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHdoaXRlc3BhY2VcbiAgaWYgKCFkZWZhdWx0U2xvdC5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgc2xvdHMuZGVmYXVsdCA9IGRlZmF1bHRTbG90O1xuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50IHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gIGZuc1xuKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICByZXNbZm5zW2ldWzBdXSA9IGZuc1tpXVsxXTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgobmFtZSArIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICB2bS5fd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3ApO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlblxuICB2YXIgaGFzQ2hpbGRyZW4gPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgLy8gaGFzIG5ldyBzY29wZWQgc2xvdHNcbiAgICB2bS4kc2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0IC8vIGhhcyBvbGQgc2NvcGVkIHNsb3RzXG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgb2JzZXJ2ZXJTdGF0ZS5pc1NldHRpbmdQcm9wcyA9IHRydWU7XG4gICAgfVxuICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHZtLiRvcHRpb25zLnByb3BzLCBwcm9wc0RhdGEsIHZtKTtcbiAgICB9XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgb2JzZXJ2ZXJTdGF0ZS5pc1NldHRpbmdQcm9wcyA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG4gIH1cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHZtKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChob29rICsgXCIgaG9va1wiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIHF1ZXVlLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8qKlxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xuICBmbHVzaGluZyA9IHRydWU7XG4gIHZhciB3YXRjaGVyLCBpZCwgdm07XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBjb25maWcuX21heFVwZGF0ZUNvdW50KSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGNhbGwgdXBkYXRlZCBob29rc1xuICBpbmRleCA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPj0gMCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKE1hdGgubWF4KGksIGluZGV4KSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnNcbikge1xuICB0aGlzLnZtID0gdm07XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KCk7XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgcHVzaFRhcmdldCh0aGlzKTtcbiAgdmFyIHZhbHVlO1xuICB2YXIgdm0gPSB0aGlzLnZtO1xuICBpZiAodGhpcy51c2VyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgfVxuICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gIGlmICh0aGlzLmRlZXApIHtcbiAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gIH1cbiAgcG9wVGFyZ2V0KCk7XG4gIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgcmV0dXJuIHZhbHVlXG59O1xuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZDtcbiAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuY2xlYW51cERlcHMgPSBmdW5jdGlvbiBjbGVhbnVwRGVwcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMkMS5kZXBzW2ldO1xuICAgIGlmICghdGhpcyQxLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcyQxLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzJDEuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG4gIH07XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XG4gIGlmIChvcHRzLmRhdGEpIHtcbiAgICBpbml0RGF0YSh2bSk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICB9XG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgaWYgKG9wdHMud2F0Y2gpIHsgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTsgfVxufVxuXG52YXIgaXNSZXNlcnZlZFByb3AgPSB7IGtleTogMSwgcmVmOiAxLCBzbG90OiAxIH07XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGlzUm9vdDtcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJvcFtrZXldKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bS4kcGFyZW50ICYmICFvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGRhdGEuY2FsbCh2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5c1tpXSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyAoa2V5c1tpXSkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5c1tpXSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleXNbaV0pO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcih2bSwgZ2V0dGVyLCBub29wLCBjb21wdXRlZFdhdGNoZXJPcHRpb25zKTtcblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKHRhcmdldCwga2V5LCB1c2VyRGVmKSB7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiB1c2VyRGVmLmdldFxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgPyB1c2VyRGVmLnNldFxuICAgICAgOiBub29wO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgdm1ba2V5XSA9IG1ldGhvZHNba2V5XSA9PSBudWxsID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAodm0sIGtleSwgaGFuZGxlcikge1xuICB2YXIgb3B0aW9ucztcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgdm0uJHdhdGNoKGtleSwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuLy8gaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuICAgIHZub2RlLFxuICAgIGh5ZHJhdGluZyxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtXG4gICkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50RWxtLFxuICAgICAgICByZWZFbG1cbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2sodm5vZGUuY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm5vZGUuY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmICghQ3Rvcikge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgaWYgKCFDdG9yLmNpZCkge1xuICAgIGlmIChDdG9yLnJlc29sdmVkKSB7XG4gICAgICBDdG9yID0gQ3Rvci5yZXNvbHZlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChDdG9yLCBiYXNlQ3RvciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBpdCdzIG9rIHRvIHF1ZXVlIHRoaXMgb24gZXZlcnkgcmVuZGVyIGJlY2F1c2VcbiAgICAgICAgLy8gJGZvcmNlVXBkYXRlIGlzIGJ1ZmZlcmVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gICAgICAgIGNvbnRleHQuJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIGlmICghQ3Rvcikge1xuICAgICAgICAvLyByZXR1cm4gbm90aGluZyBpZiB0aGlzIGlzIGluZGVlZCBhbiBhc3luYyBjb21wb25lbnRcbiAgICAgICAgLy8gd2FpdCBmb3IgdGhlIGNhbGxiYWNrIHRvIHRyaWdnZXIgcGFyZW50IHVwZGF0ZS5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChkYXRhLm1vZGVsKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wcyhkYXRhLCBDdG9yKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChDdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVyc1xuICAgIGRhdGEgPSB7fTtcbiAgfVxuXG4gIC8vIG1lcmdlIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgbWVyZ2VIb29rcyhkYXRhKTtcblxuICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxuICB2YXIgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcbiAgdmFyIHZub2RlID0gbmV3IFZOb2RlKFxuICAgIChcInZ1ZS1jb21wb25lbnQtXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXCItXCIgKyBuYW1lKSA6ICcnKSksXG4gICAgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9XG4gICk7XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChwcm9wT3B0aW9ucykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEpO1xuICAgIH1cbiAgfVxuICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gIC8vIGdldHMgYSB1bmlxdWUgY29udGV4dCAtIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjb3JyZWN0IG5hbWVkIHNsb3QgY2hlY2tcbiAgdmFyIF9jb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShjb250ZXh0KTtcbiAgdmFyIGggPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChfY29udGV4dCwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG4gIHZhciB2bm9kZSA9IEN0b3Iub3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCBoLCB7XG4gICAgcHJvcHM6IHByb3BzLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgcGFyZW50OiBjb250ZXh0LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBzbG90czogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBjb250ZXh0KTsgfVxuICB9KTtcbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICB2bm9kZS5mdW5jdGlvbmFsQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgaWYgKGRhdGEuc2xvdCkge1xuICAgICAgKHZub2RlLmRhdGEgfHwgKHZub2RlLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgfVxuICB9XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRFbG0sXG4gIHJlZkVsbVxuKSB7XG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgcHJvcHNEYXRhOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhLFxuICAgIF9jb21wb25lbnRUYWc6IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWcsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBfcGFyZW50TGlzdGVuZXJzOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzLFxuICAgIF9yZW5kZXJDaGlsZHJlbjogdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuLFxuICAgIF9wYXJlbnRFbG06IHBhcmVudEVsbSB8fCBudWxsLFxuICAgIF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGVDb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNiXG4pIHtcbiAgaWYgKGZhY3RvcnkucmVxdWVzdGVkKSB7XG4gICAgLy8gcG9vbCBjYWxsYmFja3NcbiAgICBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MucHVzaChjYik7XG4gIH0gZWxzZSB7XG4gICAgZmFjdG9yeS5yZXF1ZXN0ZWQgPSB0cnVlO1xuICAgIHZhciBjYnMgPSBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MgPSBbY2JdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcblxuICAgIHZhciByZXNvbHZlID0gZnVuY3Rpb24gKHJlcykge1xuICAgICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgICAgcmVzID0gYmFzZUN0b3IuZXh0ZW5kKHJlcyk7XG4gICAgICB9XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IHJlcztcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNic1tpXShyZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgLy8gaGFuZGxlIHByb21pc2VcbiAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJiAhZmFjdG9yeS5yZXNvbHZlZCkge1xuICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzIChkYXRhLCBDdG9yKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BPcHRpb25zKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICB2YXIgZG9tUHJvcHMgPSBkYXRhLmRvbVByb3BzO1xuICBpZiAoYXR0cnMgfHwgcHJvcHMgfHwgZG9tUHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuICAgICAgICAgIGF0dHJzICYmIGF0dHJzLmhhc093blByb3BlcnR5KGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIG5vdCBkZWNsYXJlZCBpbiBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUoQ3RvcikpICsgXCIuIE5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIFwiICtcbiAgICAgICAgICAgIFwiY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIFwiICtcbiAgICAgICAgICAgIFwiZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcIiArXG4gICAgICAgICAgICBcIlxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGRvbVByb3BzLCBrZXksIGFsdEtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaGFzaCkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9va3MgKGRhdGEpIHtcbiAgaWYgKCFkYXRhLmhvb2spIHtcbiAgICBkYXRhLmhvb2sgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGZyb21QYXJlbnQgPSBkYXRhLmhvb2tba2V5XTtcbiAgICB2YXIgb3VycyA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBkYXRhLmhvb2tba2V5XSA9IGZyb21QYXJlbnQgPyBtZXJnZUhvb2skMShvdXJzLCBmcm9tUGFyZW50KSA6IG91cnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgIG9uZShhLCBiLCBjLCBkKTtcbiAgICB0d28oYSwgYiwgYywgZCk7XG4gIH1cbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBpZiAob25bZXZlbnRdKSB7XG4gICAgb25bZXZlbnRdID0gW2RhdGEubW9kZWwuY2FsbGJhY2tdLmNvbmNhdChvbltldmVudF0pO1xuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxuICBhbHdheXNOb3JtYWxpemVcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGFsd2F5c05vcm1hbGl6ZSkgeyBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7IH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGRhdGEgJiYgZGF0YS5fX29iX18pIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgaWYgKCF0YWcpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICB2YXIgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgQ3RvcjtcbiAgICBucyA9IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAodm5vZGUpIHtcbiAgICBpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucykge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm5vZGUuY2hpbGRyZW4pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQudGFnICYmICFjaGlsZC5ucykge1xuICAgICAgICBhcHBseU5TKGNoaWxkLCBucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuICB2YWwsXG4gIHJlbmRlclxuKSB7XG4gIHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGV4dGVuZChwcm9wcywgYmluZE9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3ROb2RlcyA9IHRoaXMuJHNsb3RzW25hbWVdO1xuICAgIC8vIHdhcm4gZHVwbGljYXRlIHNsb3QgdXNhZ2VcbiAgICBpZiAoc2xvdE5vZGVzICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHNsb3ROb2Rlcy5fcmVuZGVyZWQgJiYgd2FybihcbiAgICAgICAgXCJEdXBsaWNhdGUgcHJlc2VuY2Ugb2Ygc2xvdCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGZvdW5kIGluIHRoZSBzYW1lIHJlbmRlciB0cmVlIFwiICtcbiAgICAgICAgXCItIHRoaXMgd2lsbCBsaWtlbHkgY2F1c2UgcmVuZGVyIGVycm9ycy5cIixcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICAgIHNsb3ROb2Rlcy5fcmVuZGVyZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc2xvdE5vZGVzIHx8IGZhbGxiYWNrXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIgKGlkKSB7XG4gIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHlcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5BbGlhc1xuKSB7XG4gIHZhciBrZXlDb2RlcyA9IGNvbmZpZy5rZXlDb2Rlc1trZXldIHx8IGJ1aWx0SW5BbGlhcztcbiAgaWYgKEFycmF5LmlzQXJyYXkoa2V5Q29kZXMpKSB7XG4gICAgcmV0dXJuIGtleUNvZGVzLmluZGV4T2YoZXZlbnRLZXlDb2RlKSA9PT0gLTFcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ga2V5Q29kZXMgIT09IGV2ZW50S2V5Q29kZVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIHYtYmluZD1cIm9iamVjdFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGJpbmRPYmplY3RQcm9wcyAoXG4gIGRhdGEsXG4gIHRhZyxcbiAgdmFsdWUsXG4gIGFzUHJvcFxuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoO1xuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgdmFyIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZSBieSBkb2luZyBhIHNoYWxsb3cgY2xvbmUuXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodHJlZSlcbiAgICAgID8gY2xvbmVWTm9kZXModHJlZSlcbiAgICAgIDogY2xvbmVWTm9kZSh0cmVlKVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XSA9XG4gICAgdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwodGhpcy5fcmVuZGVyUHJveHkpO1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICByZXR1cm4gdHJlZVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAqL1xuZnVuY3Rpb24gbWFya09uY2UgKFxuICB0cmVlLFxuICBpbmRleCxcbiAga2V5XG4pIHtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICB0cmVlLFxuICBrZXksXG4gIGlzT25jZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLmlzT25jZSA9IGlzT25jZTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLiR2bm9kZSA9IG51bGw7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7XG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHModm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XG5cbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgLy8gY2xvbmUgc2xvdCBub2RlcyBvbiByZS1yZW5kZXJzXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdm0uJHNsb3RzKSB7XG4gICAgICAgIHZtLiRzbG90c1trZXldID0gY2xvbmVWTm9kZXModm0uJHNsb3RzW2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZtLiRzY29wZWRTbG90cyA9IChfcGFyZW50Vm5vZGUgJiYgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMpIHx8IGVtcHR5T2JqZWN0O1xuXG4gICAgaWYgKHN0YXRpY1JlbmRlckZucyAmJiAhdm0uX3N0YXRpY1RyZWVzKSB7XG4gICAgICB2bS5fc3RhdGljVHJlZXMgPSBbXTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIHZhciB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXIgZnVuY3Rpb25cIik7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvclxuICAgICAgICAgID8gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKVxuICAgICAgICAgIDogdm0uX3Zub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudFxuICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfTtcblxuICAvLyBpbnRlcm5hbCByZW5kZXIgaGVscGVycy5cbiAgLy8gdGhlc2UgYXJlIGV4cG9zZWQgb24gdGhlIGluc3RhbmNlIHByb3RvdHlwZSB0byByZWR1Y2UgZ2VuZXJhdGVkIHJlbmRlclxuICAvLyBjb2RlIHNpemUuXG4gIFZ1ZS5wcm90b3R5cGUuX28gPSBtYXJrT25jZTtcbiAgVnVlLnByb3RvdHlwZS5fbiA9IHRvTnVtYmVyO1xuICBWdWUucHJvdG90eXBlLl9zID0gX3RvU3RyaW5nO1xuICBWdWUucHJvdG90eXBlLl9sID0gcmVuZGVyTGlzdDtcbiAgVnVlLnByb3RvdHlwZS5fdCA9IHJlbmRlclNsb3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3EgPSBsb29zZUVxdWFsO1xuICBWdWUucHJvdG90eXBlLl9pID0gbG9vc2VJbmRleE9mO1xuICBWdWUucHJvdG90eXBlLl9tID0gcmVuZGVyU3RhdGljO1xuICBWdWUucHJvdG90eXBlLl9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgVnVlLnByb3RvdHlwZS5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIFZ1ZS5wcm90b3R5cGUuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIFZ1ZS5wcm90b3R5cGUuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIFZ1ZS5wcm90b3R5cGUuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICBWdWUucHJvdG90eXBlLl91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIHZhciBpbmplY3QgPSB2bS4kb3B0aW9ucy5pbmplY3Q7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIC8vIGlzQXJyYXkgaGVyZVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShpbmplY3QpO1xuICAgIHZhciBrZXlzID0gaXNBcnJheVxuICAgICAgPyBpbmplY3RcbiAgICAgIDogaGFzU3ltYm9sXG4gICAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaXNBcnJheSA/IGtleSA6IGluamVjdFtrZXldO1xuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBwcm92aWRlS2V5IGluIHNvdXJjZS5fcHJvdmlkZWQpIHtcbiAgICAgICAgICB2bVtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBtYXJrKCd2dWUtcGVyZi1pbml0Jyk7XG4gICAgfVxuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQrKztcbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyaygndnVlLXBlcmYtaW5pdC1lbmQnKTtcbiAgICAgIG1lYXN1cmUoKCh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCAndnVlLXBlcmYtaW5pdCcsICd2dWUtcGVyZi1pbml0LWVuZCcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMucHJvcHNEYXRhID0gb3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSBvcHRpb25zLl9yZW5kZXJDaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICBvcHRzLl9wYXJlbnRFbG0gPSBvcHRpb25zLl9wYXJlbnRFbG07XG4gIG9wdHMuX3JlZkVsbSA9IG9wdGlvbnMuX3JlZkVsbTtcbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBzZWFsZWRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgc2VhbGVkKSB7XG4gIC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXG4gIC8vIGJldHdlZW4gbWVyZ2VzXG4gIGlmIChBcnJheS5pc0FycmF5KGxhdGVzdCkpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzZWFsZWQuaW5kZXhPZihsYXRlc3RbaV0pIDwgMCkge1xuICAgICAgICByZXMucHVzaChsYXRlc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhdGVzdFxuICB9XG59XG5cbmZ1bmN0aW9uIFZ1ZSQzIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlJDMpKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUkMyk7XG5zdGF0ZU1peGluKFZ1ZSQzKTtcbmV2ZW50c01peGluKFZ1ZSQzKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSQzKTtcbnJlbmRlck1peGluKFZ1ZSQzKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwbHVnaW4uaW5zdGFsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAgICAgJ2FuZCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgY29uZmlnLmlzUmVzZXJ2ZWRUYWcoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAgICAgJ2lkOiAnICsgaWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cF07XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoY2FjaGUsIGZpbHRlcikge1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGVkTm9kZSk7XG4gICAgICAgIGNhY2hlW2tleV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKHZub2RlKSB7XG4gIGlmICh2bm9kZSkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2luYWN0aXZlKSB7XG4gICAgICBjYWxsSG9vayh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSwgJ2RlYWN0aXZhdGVkJyk7XG4gICAgfVxuICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbn1cblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXNcbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlW2tleV0pO1xuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGluY2x1ZGU6IGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9LFxuICAgIGV4Y2x1ZGU6IGZ1bmN0aW9uIGV4Y2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgKFxuICAgICAgICAodGhpcy5pbmNsdWRlICYmICFtYXRjaGVzKHRoaXMuaW5jbHVkZSwgbmFtZSkpIHx8XG4gICAgICAgICh0aGlzLmV4Y2x1ZGUgJiYgbWF0Y2hlcyh0aGlzLmV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmICh0aGlzLmNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLmNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgIH1cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUkMyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5WdWUkMy52ZXJzaW9uID0gJzIuMi40JztcblxuLyogICovXG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ2VuQ2xhc3NGcm9tRGF0YShkYXRhKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGNoaWxkLmNsYXNzXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5DbGFzc0Zyb21EYXRhIChkYXRhKSB7XG4gIHZhciBkeW5hbWljQ2xhc3MgPSBkYXRhLmNsYXNzO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBkYXRhLnN0YXRpY0NsYXNzO1xuICBpZiAoc3RhdGljQ2xhc3MgfHwgZHluYW1pY0NsYXNzKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgc3RyaW5naWZpZWQ7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZVtpXSkge1xuICAgICAgICBpZiAoKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSkge1xuICAgICAgICAgIHJlcyArPSBzdHJpbmdpZmllZCArICcgJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtrZXldKSB7IHJlcyArPSBrZXkgKyAnICc7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG52YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcgPT09ICdwcmUnOyB9O1xuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5vZGUsIGtleSwgdmFsKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbn1cblxuXG52YXIgbm9kZU9wcyA9IE9iamVjdC5mcmVlemUoe1xuXHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG5cdGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG5cdGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG5cdGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuXHRyZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG5cdGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcblx0cGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcblx0bmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuXHR0YWdOYW1lOiB0YWdOYW1lLFxuXHRzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG5cdHNldEF0dHJpYnV0ZTogc2V0QXR0cmlidXRlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICgha2V5KSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSAmJiByZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuXG4vKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIGlzVW5kZWYgKHMpIHtcbiAgcmV0dXJuIHMgPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAocykge1xuICByZXR1cm4gcyAhPSBudWxsXG59XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAodm5vZGUxLCB2bm9kZTIpIHtcbiAgcmV0dXJuIChcbiAgICB2bm9kZTEua2V5ID09PSB2bm9kZTIua2V5ICYmXG4gICAgdm5vZGUxLnRhZyA9PT0gdm5vZGUyLnRhZyAmJlxuICAgIHZub2RlMS5pc0NvbW1lbnQgPT09IHZub2RlMi5pc0NvbW1lbnQgJiZcbiAgICAhdm5vZGUxLmRhdGEgPT09ICF2bm9kZTIuZGF0YVxuICApXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICB2YXIgaSwga2V5O1xuICB2YXIgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICB2YXIgaSwgajtcbiAgdmFyIGNicyA9IHt9O1xuXG4gIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChtb2R1bGVzW2pdW2hvb2tzW2ldXSAhPT0gdW5kZWZpbmVkKSB7IGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZSQkMSAoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUkJDEubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmUkJDFcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5QcmUgPSAwO1xuICBmdW5jdGlvbiBjcmVhdGVFbG0gKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQpIHtcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBpblByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaW5QcmUgJiZcbiAgICAgICAgICAhdm5vZGUubnMgJiZcbiAgICAgICAgICAhKGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuaW5kZXhPZih0YWcpID4gLTEpICYmXG4gICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodGFnKVxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgaW5QcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZub2RlLmlzQ29tbWVudCkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzUmVhY3RpdmF0ZWQpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYpIHtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpLmNyZWF0ZSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGkuaW5zZXJ0KSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICAgIH1cbiAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgIH1cbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChybSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmICghcm0pIHtcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgZWxtVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldIDogbnVsbDtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsbVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhZWxtVG9Nb3ZlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnSXQgc2VlbXMgdGhlcmUgYXJlIGR1cGxpY2F0ZSBrZXlzIHRoYXQgaXMgY2F1c2luZyBhbiB1cGRhdGUgZXJyb3IuICcgK1xuICAgICAgICAgICAgICAnTWFrZSBzdXJlIGVhY2ggdi1mb3IgaXRlbSBoYXMgYSB1bmlxdWUga2V5LidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzYW1lVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgbmV3U3RhcnRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKHZub2RlLmlzU3RhdGljICYmXG4gICAgICAgIG9sZFZub2RlLmlzU3RhdGljICYmXG4gICAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAgICh2bm9kZS5pc0Nsb25lZCB8fCB2bm9kZS5pc09uY2UpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgaGFzRGF0YSA9IGlzRGVmKGRhdGEpO1xuICAgIGlmIChoYXNEYXRhICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChoYXNEYXRhICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaGFzRGF0YSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaW5pdGlhbCAmJiB2bm9kZS5wYXJlbnQpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsc3R5bGUsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cbiAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cbiAgZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICB2bm9kZS5lbG0gPSBlbG07XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWJhaWxlZCkge1xuICAgICAgICAgICAgICBiYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHxcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoIXZub2RlKSB7XG4gICAgICBpZiAob2xkVm5vZGUpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoIW9sZFZub2RlKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoJ3NlcnZlci1yZW5kZXJlZCcpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3NlcnZlci1yZW5kZXJlZCcpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGh5ZHJhdGluZykge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodm5vZGUucGFyZW50KSB7XG4gICAgICAgICAgLy8gY29tcG9uZW50IHJvb3QgZWxlbWVudCByZXBsYWNlZC5cbiAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZS5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJlbnRFbG0kMSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0kMSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKCFvbGRWbm9kZS5kYXRhLmF0dHJzICYmICF2bm9kZS5kYXRhLmF0dHJzKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoYXR0cnMuX19vYl9fKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRTkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChhdHRyc1trZXldID09IG51bGwpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwga2V5KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoIWRhdGEuc3RhdGljQ2xhc3MgJiYgIWRhdGEuY2xhc3MgJiZcbiAgICAgICghb2xkRGF0YSB8fCAoIW9sZERhdGEuc3RhdGljQ2xhc3MgJiYgIW9sZERhdGEuY2xhc3MpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKHRyYW5zaXRpb25DbGFzcykge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIFwiLFwiICsgYXJncylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZykge1xuICBjb25zb2xlLmVycm9yKChcIltWdWUgY29tcGlsZXJdOiBcIiArIG1zZykpO1xufVxuXG5mdW5jdGlvbiBwbHVja01vZHVsZUZ1bmN0aW9uIChcbiAgbW9kdWxlcyxcbiAga2V5XG4pIHtcbiAgcmV0dXJuIG1vZHVsZXNcbiAgICA/IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtW2tleV07IH0pLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfSlcbiAgICA6IFtdXG59XG5cbmZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwucHJvcHMgfHwgKGVsLnByb3BzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgcmF3TmFtZTogcmF3TmFtZSwgdmFsdWU6IHZhbHVlLCBhcmc6IGFyZywgbW9kaWZpZXJzOiBtb2RpZmllcnMgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICBlbCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIG1vZGlmaWVycyxcbiAgaW1wb3J0YW50XG4pIHtcbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSAnIScgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxuICB9XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9ICd+JyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIG9uY2VcbiAgfVxuICB2YXIgZXZlbnRzO1xuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcbiAgfVxuICB2YXIgbmV3SGFuZGxlciA9IHsgdmFsdWU6IHZhbHVlLCBtb2RpZmllcnM6IG1vZGlmaWVycyB9O1xuICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgZ2V0U3RhdGljXG4pIHtcbiAgdmFyIGR5bmFtaWNWYWx1ZSA9XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHxcbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1iaW5kOicgKyBuYW1lKTtcbiAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpXG4gIH0gZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xuICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIgKGVsLCBuYW1lKSB7XG4gIHZhciB2YWw7XG4gIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcbiAgICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAobGlzdFtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9XG4gICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgICBcIj8gXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIudHJpbSgpXCIgK1xuICAgICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICB2YXIgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG4gIGVsLm1vZGVsID0ge1xuICAgIHZhbHVlOiAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSxcbiAgICBleHByZXNzaW9uOiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSxcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG4gIH07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcbiAgdmFsdWUsXG4gIGFzc2lnbm1lbnRcbikge1xuICB2YXIgbW9kZWxScyA9IHBhcnNlTW9kZWwodmFsdWUpO1xuICBpZiAobW9kZWxScy5pZHggPT09IG51bGwpIHtcbiAgICByZXR1cm4gKHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcInZhciAkJGV4cCA9IFwiICsgKG1vZGVsUnMuZXhwKSArIFwiLCAkJGlkeCA9IFwiICsgKG1vZGVsUnMuaWR4KSArIFwiO1wiICtcbiAgICAgIFwiaWYgKCFBcnJheS5pc0FycmF5KCQkZXhwKSl7XCIgK1xuICAgICAgICB2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudCArIFwifVwiICtcbiAgICAgIFwiZWxzZXskJGV4cC5zcGxpY2UoJCRpZHgsIDEsIFwiICsgYXNzaWdubWVudCArIFwiKX1cIlxuICB9XG59XG5cbi8qKlxuICogcGFyc2UgZGlyZWN0aXZlIG1vZGVsIHRvIGRvIHRoZSBhcnJheSB1cGRhdGUgdHJhbnNmb3JtLiBhW2lkeF0gPSB2YWwgPT4gJCRhLnNwbGljZSgkJGlkeCwgMSwgdmFsKVxuICpcbiAqIGZvciBsb29wIHBvc3NpYmxlIGNhc2VzOlxuICpcbiAqIC0gdGVzdFxuICogLSB0ZXN0W2lkeF1cbiAqIC0gdGVzdFt0ZXN0MVtpZHhdXVxuICogLSB0ZXN0W1wiYVwiXVtpZHhdXG4gKiAtIHh4eC50ZXN0W2FbYV0udGVzdDFbaWR4XV1cbiAqIC0gdGVzdC54eHguYVtcImFzYVwiXVt0ZXN0MVtpZHhdXVxuICpcbiAqL1xuXG52YXIgbGVuO1xudmFyIHN0cjtcbnZhciBjaHI7XG52YXIgaW5kZXgkMTtcbnZhciBleHByZXNzaW9uUG9zO1xudmFyIGV4cHJlc3Npb25FbmRQb3M7XG5cbmZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuICBzdHIgPSB2YWw7XG4gIGxlbiA9IHN0ci5sZW5ndGg7XG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgaWYgKHZhbC5pbmRleE9mKCdbJykgPCAwIHx8IHZhbC5sYXN0SW5kZXhPZignXScpIDwgbGVuIC0gMSkge1xuICAgIHJldHVybiB7XG4gICAgICBleHA6IHZhbCxcbiAgICAgIGlkeDogbnVsbFxuICAgIH1cbiAgfVxuXG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICB9IGVsc2UgaWYgKGNociA9PT0gMHg1Qikge1xuICAgICAgcGFyc2VCcmFja2V0KGNocik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHA6IHZhbC5zdWJzdHJpbmcoMCwgZXhwcmVzc2lvblBvcyksXG4gICAgaWR4OiB2YWwuc3Vic3RyaW5nKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHQgKCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxufVxuXG5mdW5jdGlvbiBlb2YgKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIHZhciBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cbiAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcbiAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbmZ1bmN0aW9uIG1vZGVsIChcbiAgZWwsXG4gIGRpcixcbiAgX3dhcm5cbikge1xuICB3YXJuJDEgPSBfd2FybjtcbiAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgdmFyIHRhZyA9IGVsLnRhZztcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGR5bmFtaWNUeXBlID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiBkeW5hbWljVHlwZSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxpbnB1dCA6dHlwZT1cXFwiXCIgKyBkeW5hbWljVHlwZSArIFwiXFxcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjpcXG5cIiArXG4gICAgICAgIFwidi1tb2RlbCBkb2VzIG5vdCBzdXBwb3J0IGR5bmFtaWMgaW5wdXQgdHlwZXMuIFVzZSB2LWlmIGJyYW5jaGVzIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuICAgIC8vIHZhbHVlIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnZmlsZScpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgdHlwZT1cXFwiZmlsZVxcXCI+OlxcblwiICtcbiAgICAgICAgXCJGaWxlIGlucHV0cyBhcmUgcmVhZCBvbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAoIWNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQxKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICBcInYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gXCIgK1xuICAgICAgJ0lmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXRcXCdzIHJlY29tbWVuZGVkIHRvICcgK1xuICAgICAgJ3dyYXAgYSBsaWJyYXJ5IGRlZGljYXRlZCBmb3IgdGhhdCBwdXJwb3NlIGluc2lkZSBhIGN1c3RvbSBjb21wb25lbnQuJ1xuICAgICk7XG4gIH1cblxuICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gIHZhciBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG4gICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXG4gICAgICApXG4gICk7XG4gIGFkZEhhbmRsZXIoZWwsIENIRUNLQk9YX1JBRElPX1RPS0VOLFxuICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xuICAgICAgICAnJCRlbD0kZXZlbnQudGFyZ2V0LCcgK1xuICAgICAgICBcIiQkYz0kJGVsLmNoZWNrZWQ/KFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKTooXCIgKyBmYWxzZVZhbHVlQmluZGluZyArIFwiKTtcIiArXG4gICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG4gICAgICBcInZhciAkJHY9XCIgKyAobnVtYmVyID8gJ19uKCcgKyB2YWx1ZUJpbmRpbmcgKyAnKScgOiB2YWx1ZUJpbmRpbmcpICsgXCIsXCIgK1xuICAgICAgICAgICckJGk9X2koJCRhLCQkdik7JyArXG4gICAgICBcImlmKCQkYyl7JCRpPDAmJihcIiArIHZhbHVlICsgXCI9JCRhLmNvbmNhdCgkJHYpKX1cIiArXG4gICAgICBcImVsc2V7JCRpPi0xJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpKX1cIiArXG4gICAgXCJ9ZWxzZXtcIiArIHZhbHVlICsgXCI9JCRjfVwiLFxuICAgIG51bGwsIHRydWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2VuUmFkaW9Nb2RlbCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gKFwiX24oXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikgOiB2YWx1ZUJpbmRpbmc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgQ0hFQ0tCT1hfUkFESU9fVE9LRU4sIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICBcIi5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pXCIgK1xuICAgIFwiLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXFxcIl92YWx1ZVxcXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gIHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XG4gIHZhciBjb2RlID0gXCJ2YXIgJCRzZWxlY3RlZFZhbCA9IFwiICsgc2VsZWN0ZWRWYWwgKyBcIjtcIjtcbiAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbGF6eSA9IHJlZi5sYXp5O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcbiAgdmFyIG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcbiAgdmFyIGV2ZW50ID0gbGF6eVxuICAgID8gJ2NoYW5nZSdcbiAgICA6IHR5cGUgPT09ICdyYW5nZSdcbiAgICAgID8gUkFOR0VfVE9LRU5cbiAgICAgIDogJ2lucHV0JztcblxuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gJyRldmVudC50YXJnZXQudmFsdWUnO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG5cbiAgdmFyIGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcbiAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgY29kZSA9IFwiaWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpcmV0dXJuO1wiICsgY29kZTtcbiAgfVxuXG4gIGFkZFByb3AoZWwsICd2YWx1ZScsIChcIihcIiArIHZhbHVlICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xuICBpZiAodHJpbSB8fCBudW1iZXIgfHwgdHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICB9XG59XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICB2YXIgZXZlbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAob25bUkFOR0VfVE9LRU5dKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gIH1cbiAgaWYgKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkge1xuICAgIC8vIENocm9tZSBmaXJlcyBtaWNyb3Rhc2tzIGluIGJldHdlZW4gY2xpY2svY2hhbmdlLCBsZWFkcyB0byAjNDUyMVxuICAgIGV2ZW50ID0gaXNDaHJvbWUgPyAnY2xpY2snIDogJ2NoYW5nZSc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gYWRkJDEgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgb25jZSxcbiAgY2FwdHVyZVxuKSB7XG4gIGlmIChvbmNlKSB7XG4gICAgdmFyIG9sZEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gICAgaGFuZGxlciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICAgICAgPyBvbGRIYW5kbGVyKGV2KVxuICAgICAgICA6IG9sZEhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlJDIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmICghb2xkVm5vZGUuZGF0YS5vbiAmJiAhdm5vZGUuZGF0YS5vbikge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIHZub2RlLmNvbnRleHQpO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmICghb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyAmJiAhdm5vZGUuZGF0YS5kb21Qcm9wcykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChwcm9wcy5fX29iX18pIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKHByb3BzW2tleV0gPT0gbnVsbCkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGN1ciA9PSBudWxsID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHZub2RlLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChcbiAgZWxtLFxuICB2bm9kZSxcbiAgY2hlY2tWYWxcbikge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICB2bm9kZS50YWcgPT09ICdvcHRpb24nIHx8XG4gICAgaXNEaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzSW5wdXRDaGFuZ2VkKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpcyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbSAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzSW5wdXRDaGFuZ2VkIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoKG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyKSB8fCBlbG0udHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gIH1cbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMudHJpbSkge1xuICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn07XG5cbi8qICAqL1xuXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICA6IHN0eWxlXG59XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChjaGlsZE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSkpIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5zdHlsZVtub3JtYWxpemUobmFtZSldID0gdmFsO1xuICB9XG59O1xuXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIHRlc3RFbDtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgdGVzdEVsID0gdGVzdEVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiB0ZXN0RWwuc3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgdXBwZXIgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgdXBwZXI7XG4gICAgaWYgKHByZWZpeGVkIGluIHRlc3RFbC5zdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVkXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoIWRhdGEuc3RhdGljU3R5bGUgJiYgIWRhdGEuc3R5bGUgJiZcbiAgICAgICFvbGREYXRhLnN0YXRpY1N0eWxlICYmICFvbGREYXRhLnN0eWxlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZFZub2RlLmRhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGRWbm9kZS5kYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgdm5vZGUuZGF0YS5zdHlsZSA9IHN0eWxlLl9fb2JfXyA/IGV4dGVuZCh7fSwgc3R5bGUpIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChuZXdTdHlsZVtuYW1lXSA9PSBudWxsKSB7XG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBzdHlsZSA9IHtcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxufTtcblxuLyogICovXG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyLnRyaW0oKSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICB9XG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICA6IHNldFRpbWVvdXQ7XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKSkucHVzaChjbHMpO1xuICBhZGRDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICBlbCxcbiAgZXhwZWN0ZWRUeXBlLFxuICBjYlxuKSB7XG4gIHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcbiAgdmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgdmFyIGVuZGVkID0gMDtcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoZWwuX2xlYXZlQ2IpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbC5fZW50ZXJDYiB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gIH1cblxuICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzXG4gICAgPyBhcHBlYXJUb0NsYXNzXG4gICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcbiAgICA6IGVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG4gICAgOiBhZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYikge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoZWwuX2VudGVyQ2IpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsLl9sZWF2ZUNiIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpW3Zub2RlLmtleV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgaWYgKCFmbikgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGludm9rZXJGbnMpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufSA6IHt9O1xuXG52YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICBhdHRycyxcbiAga2xhc3MsXG4gIGV2ZW50cyxcbiAgZG9tUHJvcHMsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uXG5dO1xuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxudmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgbW9kZWwkMSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgY2IoKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoY2IsIDApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGVsLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBpZiAoIWlzQW5kcm9pZCkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgZWwub3B0aW9ucyk7IH0pXG4gICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGVsLm9wdGlvbnMpO1xuICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBvcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbnNbaV0pLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiAmJiAhaXNJRTkpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBtb2RlbCQxLFxuICBzaG93OiBzaG93XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cbi8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgcmV0dXJuIC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKVxuICAgID8gaCgna2VlcC1hbGl2ZScpXG4gICAgOiBudWxsXG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWc7IH0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9sZENoaWxkICYmIG9sZENoaWxkLmRhdGEgJiYgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkpIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZCAmJiAob2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcbi8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXG4vLyBpbnRvIHRoZSBmaW5hbCBkZXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgdGhpcy5fdm5vZGUsXG4gICAgICB0aGlzLmtlcHQsXG4gICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgdmFyIGYgPSBib2R5Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZSQzLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlJDMuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZSQzLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlJDMub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlJDMucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUkMyk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzQ2hyb21lKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgIGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICk7XG4gIH1cbn0sIDApO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbmZ1bmN0aW9uIHNob3VsZERlY29kZSAoY29udGVudCwgZW5jb2RlZCkge1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgYT1cXFwiXCIgKyBjb250ZW50ICsgXCJcXFwiPlwiO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKGVuY29kZWQpID4gMFxufVxuXG4vLyAjMzY2M1xuLy8gSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gc2hvdWxkRGVjb2RlKCdcXG4nLCAnJiMxMDsnKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qICAqL1xuXG52YXIgZGVjb2RlcjtcblxuZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG59XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLyohXG4gKiBIVE1MIFBhcnNlciBCeSBKb2huIFJlc2lnIChlam9obi5vcmcpXG4gKiBNb2RpZmllZCBieSBKdXJpeSBcImthbmdheFwiIFpheXRzZXZcbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgc2luZ2xlQXR0cklkZW50aWZpZXIgPSAvKFteXFxzXCInPD4vPV0rKS87XG52YXIgc2luZ2xlQXR0ckFzc2lnbiA9IC8oPzo9KS87XG52YXIgc2luZ2xlQXR0clZhbHVlcyA9IFtcbiAgLy8gYXR0ciB2YWx1ZSBkb3VibGUgcXVvdGVzXG4gIC9cIihbXlwiXSopXCIrLy5zb3VyY2UsXG4gIC8vIGF0dHIgdmFsdWUsIHNpbmdsZSBxdW90ZXNcbiAgLycoW14nXSopJysvLnNvdXJjZSxcbiAgLy8gYXR0ciB2YWx1ZSwgbm8gcXVvdGVzXG4gIC8oW15cXHNcIic9PD5gXSspLy5zb3VyY2Vcbl07XG52YXIgYXR0cmlidXRlID0gbmV3IFJlZ0V4cChcbiAgJ15cXFxccyonICsgc2luZ2xlQXR0cklkZW50aWZpZXIuc291cmNlICtcbiAgJyg/OlxcXFxzKignICsgc2luZ2xlQXR0ckFzc2lnbi5zb3VyY2UgKyAnKScgK1xuICAnXFxcXHMqKD86JyArIHNpbmdsZUF0dHJWYWx1ZXMuam9pbignfCcpICsgJykpPydcbik7XG5cbi8vIGNvdWxkIHVzZSBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9SRUMteG1sLW5hbWVzLTE5OTkwMTE0LyNOVC1RTmFtZVxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcbnZhciBuY25hbWUgPSAnW2EtekEtWl9dW1xcXFx3XFxcXC1cXFxcLl0qJztcbnZhciBxbmFtZUNhcHR1cmUgPSAnKCg/OicgKyBuY25hbWUgKyAnXFxcXDopPycgKyBuY25hbWUgKyAnKSc7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgnXjwnICsgcW5hbWVDYXB0dXJlKTtcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgnXjxcXFxcLycgKyBxbmFtZUNhcHR1cmUgKyAnW14+XSo+Jyk7XG52YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xudmFyIGNvbW1lbnQgPSAvXjwhLS0vO1xudmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG52YXIgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGZhbHNlO1xuJ3gnLnJlcGxhY2UoL3goLik/L2csIGZ1bmN0aW9uIChtLCBnKSB7XG4gIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBnID09PSAnJztcbn0pO1xuXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbnZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciByZUNhY2hlID0ge307XG5cbnZhciBkZWNvZGluZ01hcCA9IHtcbiAgJyZsdDsnOiAnPCcsXG4gICcmZ3Q7JzogJz4nLFxuICAnJnF1b3Q7JzogJ1wiJyxcbiAgJyZhbXA7JzogJyYnLFxuICAnJiMxMDsnOiAnXFxuJ1xufTtcbnZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXApOy9nO1xudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMTApOy9nO1xuXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcbiAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBkZWNvZGluZ01hcFttYXRjaF07IH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbmRpdGlvbmFsRW5kID0gaHRtbC5pbmRleE9mKCddPicpO1xuXG4gICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcbiAgICAgICAgICAgIGFkdmFuY2UoY29uZGl0aW9uYWxFbmQgKyAyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9jdHlwZTpcbiAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgIGlmIChkb2N0eXBlTWF0Y2gpIHtcbiAgICAgICAgICBhZHZhbmNlKGRvY3R5cGVNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmQgdGFnOlxuICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xuICAgICAgICAgIHZhciBjdXJJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFsxXSwgY3VySW5kZXgsIGluZGV4KTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgdGFnOlxuICAgICAgICB2YXIgc3RhcnRUYWdNYXRjaCA9IHBhcnNlU3RhcnRUYWcoKTtcbiAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICBoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QkMSA9ICh2b2lkIDApLCBuZXh0ID0gKHZvaWQgMCk7XG4gICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgIHJlc3QkMSA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCQxKSAmJlxuICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0JDEpICYmXG4gICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0JDEpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QkMSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICBuZXh0ID0gcmVzdCQxLmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICBpZiAobmV4dCA8IDApIHsgYnJlYWsgfVxuICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcbiAgICAgICAgICByZXN0JDEgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgICAgYWR2YW5jZSh0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgICBodG1sID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fCAocmVDYWNoZVtzdGFja2VkVGFnXSA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZyArICdbXj5dKj4pJywgJ2knKSk7XG4gICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgIHZhciByZXN0ID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XG4gICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH0pO1xuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0Lmxlbmd0aDtcbiAgICAgIGh0bWwgPSByZXN0O1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgb3B0aW9ucy53YXJuKChcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiICsgaHRtbCArIFwiXFxcIlwiKSk7XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICBwYXJzZUVuZFRhZygpO1xuXG4gIGZ1bmN0aW9uIGFkdmFuY2UgKG4pIHtcbiAgICBpbmRleCArPSBuO1xuICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcgKCkge1xuICAgIHZhciBzdGFydCA9IGh0bWwubWF0Y2goc3RhcnRUYWdPcGVuKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHZhciBtYXRjaCA9IHtcbiAgICAgICAgdGFnTmFtZTogc3RhcnRbMV0sXG4gICAgICAgIGF0dHJzOiBbXSxcbiAgICAgICAgc3RhcnQ6IGluZGV4XG4gICAgICB9O1xuICAgICAgYWR2YW5jZShzdGFydFswXS5sZW5ndGgpO1xuICAgICAgdmFyIGVuZCwgYXR0cjtcbiAgICAgIHdoaWxlICghKGVuZCA9IGh0bWwubWF0Y2goc3RhcnRUYWdDbG9zZSkpICYmIChhdHRyID0gaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcbiAgICB2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cbiAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWcodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICBwYXJzZUVuZFRhZyh0YWdOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8IHRhZ05hbWUgPT09ICdodG1sJyAmJiBsYXN0VGFnID09PSAnaGVhZCcgfHwgISF1bmFyeVNsYXNoO1xuXG4gICAgdmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgLy8gaGFja2lzaCB3b3JrIGFyb3VuZCBGRiBidWcgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MzY5Nzc4XG4gICAgICBpZiAoSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiAmJiBhcmdzWzBdLmluZGV4T2YoJ1wiXCInKSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKGFyZ3NbM10gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzNdOyB9XG4gICAgICAgIGlmIChhcmdzWzRdID09PSAnJykgeyBkZWxldGUgYXJnc1s0XTsgfVxuICAgICAgICBpZiAoYXJnc1s1XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNV07IH1cbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMV0sXG4gICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNcbiAgICAgICAgKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICBzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzOiBhdHRycyB9KTtcbiAgICAgIGxhc3RUYWcgPSB0YWdOYW1lO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbmRUYWcgKHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBzdGFydCA9IGluZGV4OyB9XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7IGVuZCA9IGluZGV4OyB9XG5cbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgZm9yIChwb3MgPSBzdGFjay5sZW5ndGggLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vIHRhZyBuYW1lIGlzIHByb3ZpZGVkLCBjbGVhbiBzaG9wXG4gICAgICBwb3MgPSAwO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAoaSA+IHBvcyB8fCAhdGFnTmFtZSkgJiZcbiAgICAgICAgICAgIG9wdGlvbnMud2Fybikge1xuICAgICAgICAgIG9wdGlvbnMud2FybihcbiAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAncCcpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkZWZhdWx0VGFnUkUgPSAvXFx7XFx7KCg/Oi58XFxuKSs/KVxcfVxcfS9nO1xudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuXG52YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xuICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgdGV4dCxcbiAgZGVsaW1pdGVyc1xuKSB7XG4gIHZhciB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICB2YXIgbWF0Y2gsIGluZGV4O1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgdG9rZW5zLnB1c2goKFwiX3MoXCIgKyBleHAgKyBcIilcIikpO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4KSkpO1xuICB9XG4gIHJldHVybiB0b2tlbnMuam9pbignKycpXG59XG5cbi8qICAqL1xuXG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xudmFyIGRpclJFID0gL152LXxeQHxeOi87XG52YXIgZm9yQWxpYXNSRSA9IC8oLio/KVxccysoPzppbnxvZilcXHMrKC4qKS87XG52YXIgZm9ySXRlcmF0b3JSRSA9IC9cXCgoXFx7W159XSpcXH18W14sXSopLChbXixdKikoPzosKFteLF0qKSk/XFwpLztcblxudmFyIGFyZ1JFID0gLzooLiopJC87XG52YXIgYmluZFJFID0gL146fF52LWJpbmQ6LztcbnZhciBtb2RpZmllclJFID0gL1xcLlteLl0rL2c7XG5cbnZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGRlY29kZSk7XG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMjtcbnZhciBkZWxpbWl0ZXJzO1xudmFyIHRyYW5zZm9ybXM7XG52YXIgcHJlVHJhbnNmb3JtcztcbnZhciBwb3N0VHJhbnNmb3JtcztcbnZhciBwbGF0Zm9ybUlzUHJlVGFnO1xudmFyIHBsYXRmb3JtTXVzdFVzZVByb3A7XG52YXIgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XG5cbi8qKlxuICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG4gIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICB0cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Ob2RlJyk7XG4gIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICB2YXIgcm9vdDtcbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XG4gIHZhciBpblZQcmUgPSBmYWxzZTtcbiAgdmFyIGluUHJlID0gZmFsc2U7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3YXJuT25jZSAobXNnKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB3YXJuJDIobXNnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmRQcmUgKGVsZW1lbnQpIHtcbiAgICAvLyBjaGVjayBwcmUgc3RhdGVcbiAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgIGluUHJlID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgd2Fybjogd2FybiQyLFxuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcbiAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIHRhZzogdGFnLFxuICAgICAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgICAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcbiAgICAgICAgcGFyZW50OiBjdXJyZW50UGFyZW50LFxuICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgIH07XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xuXG4gICAgICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IGFmdGVyXG4gICAgICAgIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xuICAgICAgICBlbGVtZW50LnBsYWluID0gIWVsZW1lbnQua2V5ICYmICFhdHRycy5sZW5ndGg7XG5cbiAgICAgICAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc1Nsb3QoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NDb21wb25lbnQoZWxlbWVudCk7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgIHRyYW5zZm9ybXNbaSQxXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICBcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXG4gICAgICAgICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgfSBlbHNlIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxuICAgICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgICBibG9jazogZWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcbiAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHsgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnBsYWluID0gZmFsc2U7XG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJzsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmRQcmUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgcG9zdFRyYW5zZm9ybXNbaSQyXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQgKCkge1xuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICB2YXIgbGFzdE5vZGUgPSBlbGVtZW50LmNoaWxkcmVuW2VsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdE5vZGUgJiYgbGFzdE5vZGUudHlwZSA9PT0gMyAmJiBsYXN0Tm9kZS50ZXh0ID09PSAnICcgJiYgIWluUHJlKSB7XG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgICAvLyBwb3Agc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgZW5kUHJlKGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBjaGFyczogZnVuY3Rpb24gY2hhcnMgKHRleHQpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuICAgICAgdGV4dCA9IGluUHJlIHx8IHRleHQudHJpbSgpXG4gICAgICAgID8gZGVjb2RlSFRNTENhY2hlZCh0ZXh0KVxuICAgICAgICAvLyBvbmx5IHByZXNlcnZlIHdoaXRlc3BhY2UgaWYgaXRzIG5vdCByaWdodCBhZnRlciBhIHN0YXJ0aW5nIHRhZ1xuICAgICAgICA6IHByZXNlcnZlV2hpdGVzcGFjZSAmJiBjaGlsZHJlbi5sZW5ndGggPyAnICcgOiAnJztcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uO1xuICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKGV4cHJlc3Npb24gPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICB2YXIgbCA9IGVsLmF0dHJzTGlzdC5sZW5ndGg7XG4gIGlmIChsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBlbC5hdHRyc0xpc3RbaV0ubmFtZSxcbiAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGVsLmF0dHJzTGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuJDIoXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICB2YXIgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICAgIGlmICghaW5NYXRjaCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgIChcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApXG4gICAgICApO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVsLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICAgIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpO1xuICAgIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICAgIGVsLmFsaWFzID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgICBlbC5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIGlmIChpdGVyYXRvck1hdGNoWzNdKSB7XG4gICAgICAgIGVsLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbM10udHJpbSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5hbGlhcyA9IGFsaWFzO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMihcbiAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiICsgKGVsLnRhZykgKyBcIj4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuXCJcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcbiAgdmFyIGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0ZXh0IFxcXCJcIiArIChjaGlsZHJlbltpXS50ZXh0LnRyaW0oKSkgKyBcIlxcXCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBcIiArXG4gICAgICAgICAgXCJ3aWxsIGJlIGlnbm9yZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xuICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xuICB9XG4gIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NPbmNlIChlbCkge1xuICB2YXIgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xuICAgIGVsLm9uY2UgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90IChlbCkge1xuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmtleSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xuICAgICAgICBcImFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIFwiICtcbiAgICAgICAgXCJVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgICBpZiAoc2xvdFRhcmdldCkge1xuICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgIH1cbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICBlbC5zbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgdmFyIGJpbmRpbmc7XG4gIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICB9XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgaXNQcm9wO1xuICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICB2YWx1ZSA9IGxpc3RbaV0udmFsdWU7XG4gICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAvLyBtb2RpZmllcnNcbiAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpO1xuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc1Byb3AgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCkge1xuICAgICAgICAgICAgaXNQcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaW5uZXJIdG1sJykgeyBuYW1lID0gJ2lubmVySFRNTCc7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5jYW1lbCkge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcm9wIHx8IHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7IC8vIHYtb25cbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XG4gICAgICAgIGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgdmFyIHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSkge1xuICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gaXNGb3JiaWRkZW5UYWcgKGVsKSB7XG4gIHJldHVybiAoXG4gICAgZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgKGVsLnRhZyA9PT0gJ3NjcmlwdCcgJiYgKFxuICAgICAgIWVsLmF0dHJzTWFwLnR5cGUgfHxcbiAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgKSlcbiAgKVxufVxuXG52YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcbnZhciBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgaWYgKCFpZU5TQnVnLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgcmVzLnB1c2goYXR0cik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgdmFyIF9lbCA9IGVsO1xuICB3aGlsZSAoX2VsKSB7XG4gICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xuICAgICAgICBcIlRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIFwiICtcbiAgICAgICAgXCJ3cml0aW5nIHRvIHRoZSBhbGlhcyBpcyBsaWtlIG1vZGlmeWluZyBhIGZ1bmN0aW9uIGxvY2FsIHZhcmlhYmxlLiBcIiArXG4gICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIF9lbCA9IF9lbC5wYXJlbnQ7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBpc1N0YXRpY0tleTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbnZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzJyArXG4gICAgKGtleXMgPyAnLCcgKyBrZXlzIDogJycpXG4gIClcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyQxIChub2RlKSB7XG4gIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAvLyBkbyBub3QgbWFrZSBjb21wb25lbnQgc2xvdCBjb250ZW50IHN0YXRpYy4gdGhpcyBhdm9pZHNcbiAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXG4gICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgIGlmIChcbiAgICAgICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXG4gICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgICBub2RlLmF0dHJzTWFwWydpbmxpbmUtdGVtcGxhdGUnXSA9PSBudWxsXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIG1hcmtTdGF0aWMkMShjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xuICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIHdhbGtUaHJvdWdoQ29uZGl0aW9uc0Jsb2Nrcyhub2RlLmlmQ29uZGl0aW9ucywgaXNJbkZvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhbGtUaHJvdWdoQ29uZGl0aW9uc0Jsb2NrcyAoY29uZGl0aW9uQmxvY2tzLCBpc0luRm9yKSB7XG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBjb25kaXRpb25CbG9ja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBtYXJrU3RhdGljUm9vdHMoY29uZGl0aW9uQmxvY2tzW2ldLmJsb2NrLCBpc0luRm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0YXRpYyAobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSAyKSB7IC8vIGV4cHJlc3Npb25cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAzKSB7IC8vIHRleHRcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiAhIShub2RlLnByZSB8fCAoXG4gICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xuICAgICFub2RlLmlmICYmICFub2RlLmZvciAmJiAvLyBub3Qgdi1pZiBvciB2LWZvciBvciB2LWVsc2VcbiAgICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XG4gICAgIWlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yKG5vZGUpICYmXG4gICAgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XG4gIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICBpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobm9kZS5mb3IpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxudmFyIGZuRXhwUkUgPSAvXlxccyooW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqXFwoLztcbnZhciBzaW1wbGVQYXRoUkUgPSAvXlxccypbQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWycuKj8nXXxcXFtcIi4qP1wiXXxcXFtcXGQrXXxcXFtbQS1aYS16XyRdW1xcdyRdKl0pKlxccyokLztcblxuLy8ga2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gICdkZWxldGUnOiBbOCwgNDZdXG59O1xuXG4vLyAjNDg2ODogbW9kaWZpZXJzIHRoYXQgcHJldmVudCB0aGUgZXhlY3V0aW9uIG9mIHRoZSBsaXN0ZW5lclxuLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxuLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxudmFyIGdlbkd1YXJkID0gZnVuY3Rpb24gKGNvbmRpdGlvbikgeyByZXR1cm4gKFwiaWYoXCIgKyBjb25kaXRpb24gKyBcIilyZXR1cm4gbnVsbDtcIik7IH07XG5cbnZhciBtb2RpZmllckNvZGUgPSB7XG4gIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgcHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXG4gIHNlbGY6IGdlbkd1YXJkKFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcIiksXG4gIGN0cmw6IGdlbkd1YXJkKFwiISRldmVudC5jdHJsS2V5XCIpLFxuICBzaGlmdDogZ2VuR3VhcmQoXCIhJGV2ZW50LnNoaWZ0S2V5XCIpLFxuICBhbHQ6IGdlbkd1YXJkKFwiISRldmVudC5hbHRLZXlcIiksXG4gIG1ldGE6IGdlbkd1YXJkKFwiISRldmVudC5tZXRhS2V5XCIpLFxuICBsZWZ0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwXCIpLFxuICBtaWRkbGU6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcIiksXG4gIHJpZ2h0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpXG59O1xuXG5mdW5jdGlvbiBnZW5IYW5kbGVycyAoZXZlbnRzLCBuYXRpdmUpIHtcbiAgdmFyIHJlcyA9IG5hdGl2ZSA/ICduYXRpdmVPbjp7JyA6ICdvbjp7JztcbiAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICByZXMgKz0gXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiOlwiICsgKGdlbkhhbmRsZXIobmFtZSwgZXZlbnRzW25hbWVdKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICd9J1xufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChcbiAgbmFtZSxcbiAgaGFuZGxlclxuKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH1cblxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcblxuICBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgcmV0dXJuIGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgPyBoYW5kbGVyLnZhbHVlXG4gICAgICA6IChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxuICB9IGVsc2Uge1xuICAgIHZhciBjb2RlID0gJyc7XG4gICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgID8gaGFuZGxlci52YWx1ZSArICcoJGV2ZW50KSdcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCIoXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIikoJGV2ZW50KVwiKVxuICAgICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgcmV0dXJuIChcImlmKCEoJ2J1dHRvbicgaW4gJGV2ZW50KSYmXCIgKyAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIilcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICB9XG4gIHZhciBhbGlhcyA9IGtleUNvZGVzW2tleV07XG4gIHJldHVybiAoXCJfaygkZXZlbnQua2V5Q29kZSxcIiArIChKU09OLnN0cmluZ2lmeShrZXkpKSArIChhbGlhcyA/ICcsJyArIEpTT04uc3RyaW5naWZ5KGFsaWFzKSA6ICcnKSArIFwiKVwiKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZCQxIChlbCwgZGlyKSB7XG4gIGVsLndyYXBEYXRhID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gKFwiX2IoXCIgKyBjb2RlICsgXCIsJ1wiICsgKGVsLnRhZykgKyBcIicsXCIgKyAoZGlyLnZhbHVlKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgYmluZDogYmluZCQxLFxuICBjbG9hazogbm9vcFxufTtcblxuLyogICovXG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMztcbnZhciB0cmFuc2Zvcm1zJDE7XG52YXIgZGF0YUdlbkZucztcbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMkMTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMTtcbnZhciBzdGF0aWNSZW5kZXJGbnM7XG52YXIgb25jZUNvdW50O1xudmFyIGN1cnJlbnRPcHRpb25zO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZSAoXG4gIGFzdCxcbiAgb3B0aW9uc1xuKSB7XG4gIC8vIHNhdmUgcHJldmlvdXMgc3RhdGljUmVuZGVyRm5zIHNvIGdlbmVyYXRlIGNhbGxzIGNhbiBiZSBuZXN0ZWRcbiAgdmFyIHByZXZTdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG4gIHZhciBjdXJyZW50U3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zID0gW107XG4gIHZhciBwcmV2T25jZUNvdW50ID0gb25jZUNvdW50O1xuICBvbmNlQ291bnQgPSAwO1xuICBjdXJyZW50T3B0aW9ucyA9IG9wdGlvbnM7XG4gIHdhcm4kMyA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdHJhbnNmb3JtcyQxID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gIGRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgcGxhdGZvcm1EaXJlY3RpdmVzJDEgPSBvcHRpb25zLmRpcmVjdGl2ZXMgfHwge307XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyQxID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0KSA6ICdfYyhcImRpdlwiKSc7XG4gIHN0YXRpY1JlbmRlckZucyA9IHByZXZTdGF0aWNSZW5kZXJGbnM7XG4gIG9uY2VDb3VudCA9IHByZXZPbmNlQ291bnQ7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXG4gICAgc3RhdGljUmVuZGVyRm5zOiBjdXJyZW50U3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwpIHtcbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwpXG4gIH0gZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5PbmNlKGVsKVxuICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbClcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwpXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0KSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsKSB8fCAndm9pZCAwJ1xuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgcmV0dXJuIGdlblNsb3QoZWwpXG4gIH0gZWxzZSB7XG4gICAgLy8gY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICB2YXIgY29kZTtcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YSA9IGVsLnBsYWluID8gdW5kZWZpbmVkIDogZ2VuRGF0YShlbCk7XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zJDEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvZGUgPSB0cmFuc2Zvcm1zJDFbaV0oZWwsIGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG5cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIHN0YXRpY1JlbmRlckZucy5wdXNoKChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwpKSArIFwifVwiKSk7XG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwpIHtcbiAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwpXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcbiAgICB2YXIga2V5ID0gJyc7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQzKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsKVxuICAgIH1cbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCkpICsgXCIsXCIgKyAob25jZUNvdW50KyspICsgKGtleSA/IChcIixcIiArIGtleSkgOiBcIlwiKSArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKGVsKSB7XG4gIGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCkpXG59XG5cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoY29uZGl0aW9ucykge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICdfZSgpJ1xuICB9XG5cbiAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucykpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpKVxuICB9XG5cbiAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xuICAgIHJldHVybiBlbC5vbmNlID8gZ2VuT25jZShlbCkgOiBnZW5FbGVtZW50KGVsKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkZvciAoZWwpIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgbWF5YmVDb21wb25lbnQoZWwpICYmIGVsLnRhZyAhPT0gJ3Nsb3QnICYmIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJiAhZWwua2V5XG4gICkge1xuICAgIHdhcm4kMyhcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LWZvcj1cXFwiXCIgKyBhbGlhcyArIFwiIGluIFwiICsgZXhwICsgXCJcXFwiPjogY29tcG9uZW50IGxpc3RzIHJlbmRlcmVkIHdpdGggXCIgK1xuICAgICAgXCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcIiArXG4gICAgICBcIlNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uXCIsXG4gICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICk7XG4gIH1cblxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIFwiX2woKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEgKGVsKSB7XG4gIHZhciBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCk7XG4gIGlmIChkaXJzKSB7IGRhdGEgKz0gZGlycyArICcsJzsgfVxuXG4gIC8vIGtleVxuICBpZiAoZWwua2V5KSB7XG4gICAgZGF0YSArPSBcImtleTpcIiArIChlbC5rZXkpICsgXCIsXCI7XG4gIH1cbiAgLy8gcmVmXG4gIGlmIChlbC5yZWYpIHtcbiAgICBkYXRhICs9IFwicmVmOlwiICsgKGVsLnJlZikgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgfVxuICAvLyBwcmVcbiAgaWYgKGVsLnByZSkge1xuICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZGF0YSArPSBcInRhZzpcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIjtcbiAgfVxuICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcbiAgICBkYXRhICs9IGRhdGFHZW5GbnNbaV0oZWwpO1xuICB9XG4gIC8vIGF0dHJpYnV0ZXNcbiAgaWYgKGVsLmF0dHJzKSB7XG4gICAgZGF0YSArPSBcImF0dHJzOntcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIERPTSBwcm9wc1xuICBpZiAoZWwucHJvcHMpIHtcbiAgICBkYXRhICs9IFwiZG9tUHJvcHM6e1wiICsgKGdlblByb3BzKGVsLnByb3BzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cykpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLm5hdGl2ZUV2ZW50cywgdHJ1ZSkpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2xvdCB0YXJnZXRcbiAgaWYgKGVsLnNsb3RUYXJnZXQpIHtcbiAgICBkYXRhICs9IFwic2xvdDpcIiArIChlbC5zbG90VGFyZ2V0KSArIFwiLFwiO1xuICB9XG4gIC8vIHNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICBkYXRhICs9IChnZW5TY29wZWRTbG90cyhlbC5zY29wZWRTbG90cykpICsgXCIsXCI7XG4gIH1cbiAgLy8gY29tcG9uZW50IHYtbW9kZWxcbiAgaWYgKGVsLm1vZGVsKSB7XG4gICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCk7XG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgICBkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCkge1xuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICB2YXIgZ2VuID0gcGxhdGZvcm1EaXJlY3RpdmVzJDFbZGlyLm5hbWVdIHx8IGJhc2VEaXJlY3RpdmVzW2Rpci5uYW1lXTtcbiAgICBpZiAoZ2VuKSB7XG4gICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCB3YXJuJDMpO1xuICAgIH1cbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiICsgKGRpci5uYW1lKSArIFwiXFxcIixyYXdOYW1lOlxcXCJcIiArIChkaXIucmF3TmFtZSkgKyBcIlxcXCJcIiArIChkaXIudmFsdWUgPyAoXCIsdmFsdWU6KFwiICsgKGRpci52YWx1ZSkgKyBcIiksZXhwcmVzc2lvbjpcIiArIChKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpKSkgOiAnJykgKyAoZGlyLmFyZyA/IChcIixhcmc6XFxcIlwiICsgKGRpci5hcmcpICsgXCJcXFwiXCIpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwpIHtcbiAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoXG4gICAgZWwuY2hpbGRyZW4ubGVuZ3RoID4gMSB8fCBhc3QudHlwZSAhPT0gMVxuICApKSB7XG4gICAgd2FybiQzKCdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nKTtcbiAgfVxuICBpZiAoYXN0LnR5cGUgPT09IDEpIHtcbiAgICB2YXIgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBjdXJyZW50T3B0aW9ucyk7XG4gICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoc2xvdHMpIHtcbiAgcmV0dXJuIChcInNjb3BlZFNsb3RzOl91KFtcIiArIChPYmplY3Qua2V5cyhzbG90cykubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGdlblNjb3BlZFNsb3Qoa2V5LCBzbG90c1trZXldKTsgfSkuam9pbignLCcpKSArIFwiXSlcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoa2V5LCBlbCkge1xuICByZXR1cm4gXCJbXCIgKyBrZXkgKyBcIixmdW5jdGlvbihcIiArIChTdHJpbmcoZWwuYXR0cnNNYXAuc2NvcGUpKSArIFwiKXtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGdlbkNoaWxkcmVuKGVsKSB8fCAndm9pZCAwJ1xuICAgICAgOiBnZW5FbGVtZW50KGVsKSkgKyBcIn1dXCJcbn1cblxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKGVsLCBjaGVja1NraXApIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgZWwkMS5mb3IgJiZcbiAgICAgICAgZWwkMS50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgICAgZWwkMS50YWcgIT09ICdzbG90Jykge1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwkMSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4pIDogMDtcbiAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChnZW5Ob2RlKS5qb2luKCcsJykpICsgXCJdXCIgKyAobm9ybWFsaXphdGlvblR5cGUgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChjaGlsZHJlbikge1xuICB2YXIgcmVzID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChlbC50eXBlICE9PSAxKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbWF5YmVDb21wb25lbnQoYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24gKGVsKSB7XG4gIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcbn1cblxuZnVuY3Rpb24gbWF5YmVDb21wb25lbnQgKGVsKSB7XG4gIHJldHVybiAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDEoZWwudGFnKVxufVxuXG5mdW5jdGlvbiBnZW5Ob2RlIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCkge1xuICB2YXIgc2xvdE5hbWUgPSBlbC5zbG90TmFtZSB8fCAnXCJkZWZhdWx0XCInO1xuICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCk7XG4gIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XG4gIHZhciBhdHRycyA9IGVsLmF0dHJzICYmIChcIntcIiArIChlbC5hdHRycy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgoY2FtZWxpemUoYS5uYW1lKSkgKyBcIjpcIiArIChhLnZhbHVlKSk7IH0pLmpvaW4oJywnKSkgKyBcIn1cIik7XG4gIHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBcIixudWxsXCI7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gIH1cbiAgaWYgKGJpbmQkJDEpIHtcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoY29tcG9uZW50TmFtZSwgZWwpIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHRydWUpO1xuICByZXR1cm4gKFwiX2MoXCIgKyBjb21wb25lbnROYW1lICsgXCIsXCIgKyAoZ2VuRGF0YShlbCkpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIHJlcyArPSBcIlxcXCJcIiArIChwcm9wLm5hbWUpICsgXCJcXFwiOlwiICsgKHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxufVxuXG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxufVxuXG4vKiAgKi9cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gY2hlY2sgdmFsaWQgaWRlbnRpZmllciBmb3Igdi1mb3JcbnZhciBpZGVudFJFID0gL1tBLVphLXpfJF1bXFx3JF0qLztcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0KSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYgKGFzdCkge1xuICAgIGNoZWNrTm9kZShhc3QsIGVycm9ycyk7XG4gIH1cbiAgcmV0dXJuIGVycm9yc1xufVxuXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIGVycm9ycykge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XG4gICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgZXJyb3JzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCBlcnJvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICBlcnJvcnMucHVzaChcbiAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpXG4gICAgKTtcbiAgfVxuICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgZXJyb3JzKSB7XG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKGlkZW50LCB0eXBlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycgJiYgIWlkZW50UkUudGVzdChpZGVudCkpIHtcbiAgICBlcnJvcnMucHVzaCgoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIFwiICsgZXhwKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG4gIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3Q6IGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICB2YXIgZnVuY3Rpb25Db21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgdGlwcyA9IFtdO1xuICAgIGZpbmFsT3B0aW9ucy53YXJuID0gZnVuY3Rpb24gKG1zZywgdGlwJCQxKSB7XG4gICAgICAodGlwJCQxID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPSAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICB9XG4gICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zLmRpcmVjdGl2ZXMpLFxuICAgICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8gY29weSBvdGhlciBvcHRpb25zXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLCBmaW5hbE9wdGlvbnMpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QpKTtcbiAgICB9XG4gICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgIHJldHVybiBjb21waWxlZFxuICB9XG5cbiAgZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xuICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuICAgICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcbiAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FjaGVcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgIDogdGVtcGxhdGU7XG4gICAgaWYgKGZ1bmN0aW9uQ29tcGlsZUNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbkNvbXBpbGVDYWNoZVtrZXldXG4gICAgfVxuXG4gICAgLy8gY29tcGlsZVxuICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNvbXBpbGVkLmVycm9ycyAmJiBjb21waWxlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyB0ZW1wbGF0ZSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChcIi0gXCIgKyBlKTsgfSkuam9pbignXFxuJykgKyAnXFxuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcbiAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBmbkdlbkVycm9ycyA9IFtdO1xuICAgIHJlcy5yZW5kZXIgPSBtYWtlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgdmFyIGwgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJlcy5zdGF0aWNSZW5kZXJGbnNbaV0gPSBtYWtlRnVuY3Rpb24oY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zW2ldLCBmbkdlbkVycm9ycyk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXG4gICAgLy8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUgaXMgYSBidWcgaW4gdGhlIGNvbXBpbGVyIGl0c2VsZi5cbiAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmVuZGVyIGZ1bmN0aW9uOlxcblxcblwiICtcbiAgICAgICAgICBmbkdlbkVycm9ycy5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIGVyciA9IHJlZi5lcnI7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHJlZi5jb2RlO1xuXG4gICAgICAgICAgICByZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xuICAgICAgICB9KS5qb2luKCdcXG4nKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoZnVuY3Rpb25Db21waWxlQ2FjaGVba2V5XSA9IHJlcylcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tcGlsZTogY29tcGlsZSxcbiAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNvbXBpbGVUb0Z1bmN0aW9uc1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRpY0NsYXNzKSB7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiY2xhc3M9XFxcIlwiICsgc3RhdGljQ2xhc3MgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgdmFyIGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBrbGFzcyQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMlxufTtcblxudmFyIG1vZHVsZXMkMSA9IFtcbiAga2xhc3MkMSxcbiAgc3R5bGUkMVxuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWw6IG1vZGVsLFxuICB0ZXh0OiB0ZXh0LFxuICBodG1sOiBodG1sXG59O1xuXG4vKiAgKi9cblxudmFyIGJhc2VPcHRpb25zID0ge1xuICBleHBlY3RIVE1MOiB0cnVlLFxuICBtb2R1bGVzOiBtb2R1bGVzJDEsXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcbiAgaXNQcmVUYWc6IGlzUHJlVGFnLFxuICBpc1VuYXJ5VGFnOiBpc1VuYXJ5VGFnLFxuICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXG4gIGlzUmVzZXJ2ZWRUYWc6IGlzUmVzZXJ2ZWRUYWcsXG4gIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxuICBzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSlcbn07XG5cbnZhciByZWYkMSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcbnZhciBjb21waWxlVG9GdW5jdGlvbnMgPSByZWYkMS5jb21waWxlVG9GdW5jdGlvbnM7XG5cbi8qICAqL1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG52YXIgbW91bnQgPSBWdWUkMy5wcm90b3R5cGUuJG1vdW50O1xuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZSgoKHRoaXMuX25hbWUpICsgXCIgY29tcGlsZVwiKSwgJ2NvbXBpbGUnLCAnY29tcGlsZSBlbmQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8qKlxuICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcbiAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICovXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwgKGVsKSB7XG4gIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXG4gIH1cbn1cblxuVnVlJDMuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuZXhwb3J0IGRlZmF1bHQgVnVlJDM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3Z1ZS9kaXN0L3Z1ZS5lc20uanMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwicmVxdWlyZSgnLi4vLi4vc3JjL3N0eWxlcy9tYWluLnNjc3MnKTtcblxuLy8gTG9hZCBsaWJyYXJ5XG5INVAuRmVlZGJhY2sgPSByZXF1aXJlKCcuLi9zY3JpcHRzL2ZlZWRiYWNrJykuZGVmYXVsdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZW50cmllcy9kaXN0LmpzIiwidmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vRmluYWwudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi01YzJiYjExMVxcXCIsXFxcInByZXNlcnZlV2hpdGVzcGFjZVxcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9GaW5hbC52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIi9ob21lL3RvbWFqL2NvZGUvam91YmVsL2NvbnRlbnQtdHlwZXMvaDVwLWZlZWRiYWNrL3NyYy9zY3JpcHRzL3ZpZXdzL0ZpbmFsLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5ICE9PSBcIl9fZXNNb2R1bGVcIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIEZpbmFsLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi01YzJiYjExMVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTVjMmJiMTExXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zY3JpcHRzL3ZpZXdzL0ZpbmFsLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vU2NvcmVJbnB1dC52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTQ5MDNkY2NkXFxcIixcXFwicHJlc2VydmVXaGl0ZXNwYWNlXFxcIjpmYWxzZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL1Njb3JlSW5wdXQudnVlXCIpLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIGNzc01vZHVsZXMgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCIvaG9tZS90b21hai9jb2RlL2pvdWJlbC9jb250ZW50LXR5cGVzL2g1cC1mZWVkYmFjay9zcmMvc2NyaXB0cy92aWV3cy9TY29yZUlucHV0LnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5ICE9PSBcIl9fZXNNb2R1bGVcIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIFNjb3JlSW5wdXQudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTQ5MDNkY2NkXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNDkwM2RjY2RcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NjcmlwdHMvdmlld3MvU2NvcmVJbnB1dC52dWVcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL1RleHRJbnB1dC52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTYzMTVhMTM4XFxcIixcXFwicHJlc2VydmVXaGl0ZXNwYWNlXFxcIjpmYWxzZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL1RleHRJbnB1dC52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIi9ob21lL3RvbWFqL2NvZGUvam91YmVsL2NvbnRlbnQtdHlwZXMvaDVwLWZlZWRiYWNrL3NyYy9zY3JpcHRzL3ZpZXdzL1RleHRJbnB1dC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleSAhPT0gXCJfX2VzTW9kdWxlXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBUZXh0SW5wdXQudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTYzMTVhMTM4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNjMxNWExMzhcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NjcmlwdHMvdmlld3MvVGV4dElucHV0LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiaDVwLWZlZWRiYWNrLXNjb3JlXCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwicm9sZVwiOiBcInJlZ2lvblwiXG4gICAgfVxuICB9LCBbX2MoJ2gzJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZlZWRiYWNrLXRpdGxlXCIsXG4gICAgZG9tUHJvcHM6IHtcbiAgICAgIFwiaW5uZXJIVE1MXCI6IF92bS5fcyhfdm0ubWVzc2FnZSlcbiAgICB9XG4gIH0pLCBfYygndWwnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZmVlZGJhY2stc2NvcmUtaW5wdXRcIlxuICB9LCBfdm0uX2woKF92bS5hbHRlcm5hdGl2ZXMpLCBmdW5jdGlvbihhbHRlcm5hdGl2ZSkge1xuICAgIHJldHVybiBfYygnbGknLCBbX2MoJ2RpdicsIHtcbiAgICAgIGNsYXNzOiBhbHRlcm5hdGl2ZS5jbHMsXG4gICAgICBhdHRyczoge1xuICAgICAgICBcInJvbGVcIjogXCJidXR0b25cIlxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgX3ZtLnNlbmRTY29yZShhbHRlcm5hdGl2ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtfYygnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwiZmVlZGJhY2stc2NvcmUtdGl0bGVcIlxuICAgIH0sIFtfdm0uX3YoX3ZtLl9zKGFsdGVybmF0aXZlLnRpdGxlKSldKV0pXSlcbiAgfSkpXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtNDkwM2RjY2RcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00OTAzZGNjZFwiLFwicHJlc2VydmVXaGl0ZXNwYWNlXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvc2NyaXB0cy92aWV3cy9TY29yZUlucHV0LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF92bS5fbSgwKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiaDVwLWZlZWRiYWNrLWZpbmFsXCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwicm9sZVwiOiBcInJlZ2lvblwiXG4gICAgfVxuICB9LCBbX2MoJ3AnLCBbX3ZtLl92KFwiV2UgcHV0IGEgbG90IG9mIGVmZm9ydCBpbnRvIG1ha2luZyBINVAgZWFzeSB0byB1c2UgZm9yIGFsbCFcIildKSwgX2MoJ2gzJywgW192bS5fdihcIllvdXIgZmVlZGJhY2sgaXMgaGlnaGx5IGFwcHJlY2lhdGVkIVwiKV0pXSlcbn1dfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi01YzJiYjExMVwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTVjMmJiMTExXCIsXCJwcmVzZXJ2ZVdoaXRlc3BhY2VcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9zY3JpcHRzL3ZpZXdzL0ZpbmFsLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiaDVwLWZlZWRiYWNrLXRleHRcIixcbiAgICBhdHRyczoge1xuICAgICAgXCJyb2xlXCI6IFwicmVnaW9uXCJcbiAgICB9XG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZlZWRiYWNrLXNjb3JlXCIsXG4gICAgY2xhc3M6IF92bS5hbHRlcm5hdGl2ZS5jbHNcbiAgfSksIF9jKCdwJywgW192bS5fdihfdm0uX3ModGhpcy5hbHRlcm5hdGl2ZS50aXRsZSkpXSksIF9jKCdyb3V0ZXItbGluaycsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJ0b1wiOiBcIi9zY29yZS1pbnB1dFwiXG4gICAgfVxuICB9LCBbX3ZtLl92KFwiQ2hhbmdlXCIpXSksIF9jKCdoMycsIFtfdm0uX3YoXCJUaGFua3MgZm9yIHRoZSByYXRpbmchXCIpXSksIF92bS5fbSgwKSwgX2MoJ3RleHRhcmVhJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcInJvd3NcIjogXCI0XCIsXG4gICAgICBcInBsYWNlaG9sZGVyXCI6IFwiWW91ciBGZWVkYmFja1wiXG4gICAgfVxuICB9KSwgX2MoJ2J1dHRvbicsIHtcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgX3ZtLnNlbmRUZXh0KClcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJTZW5kXCIpXSldLCAxKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdwJywgW192bS5fdihcIkxldCB1cyBrbm93IGhvdyB3ZSBjYW4gaW1wcm92ZSB5b3VyIGV4cGVyaWVuY2Ugd2l0aCB0aGUgXCIpLCBfYygnc3Ryb25nJywgW192bS5fdihcIkRyYWcgVGV4dFwiKV0pLCBfdm0uX3YoXCIgYXV0aG9yaW5nIHRvb2wuXCIpXSlcbn1dfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi02MzE1YTEzOFwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTYzMTVhMTM4XCIsXCJwcmVzZXJ2ZVdoaXRlc3BhY2VcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9zY3JpcHRzL3ZpZXdzL1RleHRJbnB1dC52dWVcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=