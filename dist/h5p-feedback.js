/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 10);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

// this module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  scopeId,
  cssModules
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  // inject cssModules
  if (cssModules) {
    var computed = Object.create(options.computed || null)
    Object.keys(cssModules).forEach(function (key) {
      var module = cssModules[key]
      computed[key] = function () { return module }
    })
    options.computed = computed
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vue = __webpack_require__(8);

var _vue2 = _interopRequireDefault(_vue);

var _vueRouter = __webpack_require__(7);

var _vueRouter2 = _interopRequireDefault(_vueRouter);

var _ScoreInput = __webpack_require__(12);

var _ScoreInput2 = _interopRequireDefault(_ScoreInput);

var _TextInput = __webpack_require__(13);

var _TextInput2 = _interopRequireDefault(_TextInput);

var _Final = __webpack_require__(11);

var _Final2 = _interopRequireDefault(_Final);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

_vue2.default.use(_vueRouter2.default);

var Feedback = function (_H5P$EventDispatcher) {
  _inherits(Feedback, _H5P$EventDispatcher);

  /**
   * @constructor
   *
   * @param {object} config
   * @param {string} contentId
   * @param {object} contentData
   */
  function Feedback(config, contentId) {
    var contentData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, Feedback);

    var _this = _possibleConstructorReturn(this, (Feedback.__proto__ || Object.getPrototypeOf(Feedback)).call(this));

    _this.contentId = contentId;

    var alternatives = [{
      title: 'Very Satisfied',
      cls: 'feedback-score-4',
      score: '4'
    }, {
      title: 'Satisfied',
      cls: 'feedback-score-3',
      score: '3'
    }, {
      title: 'Neutral',
      cls: 'feedback-score-2',
      score: '2'
    }, {
      title: 'Unsatisfied',
      cls: 'feedback-score-1',
      score: '1'
    }];

    // set data on score input view
    _ScoreInput2.default.data = function () {
      return {
        message: config.title,
        score: '0',
        alternatives: alternatives
      };
    };

    // set data on text input view
    _TextInput2.default.data = function () {
      return {
        alternatives: alternatives,
        text: ''
      };
    };

    // crate router
    var router = new _vueRouter2.default({
      mode: 'abstract',
      routes: [{ path: '/score-input', component: _ScoreInput2.default }, { path: '/text-input/:score', component: _TextInput2.default, props: true }, { path: '/final', component: _Final2.default }, { path: '/', redirect: '/score-input' }]
    });

    // trigger resize when switching views
    router.beforeEach(function (to, from, next) {
      next();
      _this.trigger('resize');
    });

    // create view model
    _this.viewModel = new _vue2.default({ router: router });

    /**
     * Attach library to wrapper
     *
     * @param {jQuery} $wrapper
     * @public
     */
    _this.attach = function ($wrapper) {
      var id = 'h5p-feedback-content-' + _this.contentId;
      $wrapper.get(0).appendChild(_this.createRootElement(id));
      _this.viewModel.$mount('#' + id);
      router.push('score-input');
    };

    /**
     * Creates the root element that vue will render into
     *
     * @param {string} id
     *
     * @return {Element}
     */
    _this.createRootElement = function (id) {
      var element = document.createElement('div');
      element.id = id;
      element.className = 'h5p-feedback';
      element.innerHTML = '<router-view></router-view>';
      return element;
    };
    return _this;
  }

  return Feedback;
}(H5P.EventDispatcher);

exports.default = Feedback;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//

exports.default = {
  name: 'final-view'
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'score-input-view',

  methods: {
    sendScore: function sendScore(alternative) {
      this.score = alternative.score;

      this.$router.push('text-input/' + alternative.score);
    }
  }
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'text-input-view',
  props: ['score'],

  computed: {
    alternative: function alternative() {
      var _this = this;

      return this.alternatives.filter(function (alternative) {
        return alternative.score === _this.score;
      })[0];
    }
  },

  methods: {
    sendText: function sendText(text) {
      console.log('sendtext', text);
      // TODO Fire xAPI
      this.$router.push('/final');
    }
  }
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
  * vue-router v2.2.1
  * (c) 2017 Evan You
  * @license MIT
  */
/*  */

function assert(condition, message) {
  if (!condition) {
    throw new Error("[vue-router] " + message);
  }
}

function warn(condition, message) {
  if (!condition) {
    typeof console !== 'undefined' && console.warn("[vue-router] " + message);
  }
}

var View = {
  name: 'router-view',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render(h, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;

    data.routerView = true;

    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {});

    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    var depth = 0;
    var inactive = false;
    while (parent) {
      if (parent.$vnode && parent.$vnode.data.routerView) {
        depth++;
      }
      if (parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      return h(cache[name], data, children);
    }

    var matched = route.matched[depth];
    // render empty node if no matched route
    if (!matched) {
      cache[name] = null;
      return h();
    }

    var component = cache[name] = matched.components[name];

    // inject instance registration hooks
    var hooks = data.hook || (data.hook = {});
    hooks.init = function (vnode) {
      matched.instances[name] = vnode.child;
    };
    hooks.prepatch = function (oldVnode, vnode) {
      matched.instances[name] = vnode.child;
    };
    hooks.destroy = function (vnode) {
      if (matched.instances[name] === vnode.child) {
        matched.instances[name] = undefined;
      }
    };

    // resolve props
    data.props = resolveProps(route, matched.props && matched.props[name]);

    return h(component, data, children);
  }
};

function resolveProps(route, config) {
  switch (typeof config === "undefined" ? "undefined" : _typeof(config)) {
    case 'undefined':
      return;
    case 'object':
      return config;
    case 'function':
      return config(route);
    case 'boolean':
      return config ? route.params : undefined;
    default:
      warn(false, "props in \"" + route.path + "\" is a " + (typeof config === "undefined" ? "undefined" : _typeof(config)) + ", expecting an object, function or boolean.");
  }
}

/*  */

var encodeReserveRE = /[!'()*]/g;
var encodeReserveReplacer = function encodeReserveReplacer(c) {
  return '%' + c.charCodeAt(0).toString(16);
};
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more comformant to RFC3986:
// - escapes [!'()*]
// - preserve commas
var encode = function encode(str) {
  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');
};

var decode = decodeURIComponent;

function resolveQuery(query, extraQuery) {
  if (extraQuery === void 0) extraQuery = {};

  if (query) {
    var parsedQuery;
    try {
      parsedQuery = parseQuery(query);
    } catch (e) {
      process.env.NODE_ENV !== 'production' && warn(false, e.message);
      parsedQuery = {};
    }
    for (var key in extraQuery) {
      parsedQuery[key] = extraQuery[key];
    }
    return parsedQuery;
  } else {
    return extraQuery;
  }
}

function parseQuery(query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res;
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0 ? decode(parts.join('=')) : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });

  return res;
}

function stringifyQuery(obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return '';
    }

    if (val === null) {
      return encode(key);
    }

    if (Array.isArray(val)) {
      var result = [];
      val.slice().forEach(function (val2) {
        if (val2 === undefined) {
          return;
        }
        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&');
    }

    return encode(key) + '=' + encode(val);
  }).filter(function (x) {
    return x.length > 0;
  }).join('&') : null;
  return res ? "?" + res : '';
}

/*  */

var trailingSlashRE = /\/?$/;

function createRoute(record, location, redirectedFrom) {
  var route = {
    name: location.name || record && record.name,
    meta: record && record.meta || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: location.query || {},
    params: location.params || {},
    fullPath: getFullPath(location),
    matched: record ? formatMatch(record) : []
  };
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom);
  }
  return Object.freeze(route);
}

// the starting route that represents the initial state
var START = createRoute(null, {
  path: '/'
});

function formatMatch(record) {
  var res = [];
  while (record) {
    res.unshift(record);
    record = record.parent;
  }
  return res;
}

function getFullPath(ref) {
  var path = ref.path;
  var query = ref.query;if (query === void 0) query = {};
  var hash = ref.hash;if (hash === void 0) hash = '';

  return (path || '/') + stringifyQuery(query) + hash;
}

function isSameRoute(a, b) {
  if (b === START) {
    return a === b;
  } else if (!b) {
    return false;
  } else if (a.path && b.path) {
    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);
  } else if (a.name && b.name) {
    return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);
  } else {
    return false;
  }
}

function isObjectEqual(a, b) {
  if (a === void 0) a = {};
  if (b === void 0) b = {};

  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false;
  }
  return aKeys.every(function (key) {
    return String(a[key]) === String(b[key]);
  });
}

function isIncludedRoute(current, target) {
  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);
}

function queryIncludes(current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false;
    }
  }
  return true;
}

/*  */

// work around weird flow bug
var toTypes = [String, Object];
var eventTypes = [String, Array];

var Link = {
  name: 'router-link',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render(h) {
    var this$1 = this;

    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;
    var classes = {};
    var activeClass = this.activeClass || router.options.linkActiveClass || 'router-link-active';
    var compareTarget = location.path ? createRoute(null, location) : route;
    classes[activeClass] = this.exact ? isSameRoute(current, compareTarget) : isIncludedRoute(current, compareTarget);

    var handler = function handler(e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location);
        } else {
          router.push(location);
        }
      }
    };

    var on = { click: guardEvent };
    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) {
        on[e] = handler;
      });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = { href: href };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);
      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var extend = _Vue.util.extend;
        var aData = a.data = extend({}, a.data);
        aData.on = on;
        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default);
  }
};

function guardEvent(e) {
  // don't redirect with control keys
  if (e.metaKey || e.ctrlKey || e.shiftKey) {
    return;
  }
  // don't redirect when preventDefault called
  if (e.defaultPrevented) {
    return;
  }
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) {
    return;
  }
  // don't redirect if `target="_blank"`
  if (e.target && e.target.getAttribute) {
    var target = e.target.getAttribute('target');
    if (/\b_blank\b/i.test(target)) {
      return;
    }
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault();
  }
  return true;
}

function findAnchor(children) {
  if (children) {
    var child;
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      if (child.tag === 'a') {
        return child;
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child;
      }
    }
  }
}

var _Vue;

function install(Vue) {
  if (install.installed) {
    return;
  }
  install.installed = true;

  _Vue = Vue;

  Object.defineProperty(Vue.prototype, '$router', {
    get: function get() {
      return this.$root._router;
    }
  });

  Object.defineProperty(Vue.prototype, '$route', {
    get: function get() {
      return this.$root._route;
    }
  });

  Vue.mixin({
    beforeCreate: function beforeCreate() {
      if (this.$options.router) {
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, '_route', this._router.history.current);
      }
    }
  });

  Vue.component('router-view', View);
  Vue.component('router-link', Link);

  var strats = Vue.config.optionMergeStrategies;
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created;
}

/*  */

var inBrowser = typeof window !== 'undefined';

/*  */

function resolvePath(relative, base, append) {
  if (relative.charAt(0) === '/') {
    return relative;
  }

  if (relative.charAt(0) === '?' || relative.charAt(0) === '#') {
    return base + relative;
  }

  var stack = base.split('/');

  // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  }

  // resolve relative path
  var segments = relative.replace(/^\//, '').split('/');
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment === '.') {
      continue;
    } else if (segment === '..') {
      stack.pop();
    } else {
      stack.push(segment);
    }
  }

  // ensure leading slash
  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/');
}

function parsePath(path) {
  var hash = '';
  var query = '';

  var hashIndex = path.indexOf('#');
  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');
  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  };
}

function cleanPath(path) {
  return path.replace(/\/\//g, '/');
}

/*  */

function createRouteMap(routes, oldPathMap, oldNameMap) {
  var pathMap = oldPathMap || Object.create(null);
  var nameMap = oldNameMap || Object.create(null);

  routes.forEach(function (route) {
    addRouteRecord(pathMap, nameMap, route);
  });

  return {
    pathMap: pathMap,
    nameMap: nameMap
  };
}

function addRouteRecord(pathMap, nameMap, route, parent, matchAs) {
  var path = route.path;
  var name = route.name;
  if (process.env.NODE_ENV !== 'production') {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(typeof route.component !== 'string', "route config \"component\" for path: " + String(path || name) + " cannot be a " + "string id. Use an actual component instead.");
  }

  var record = {
    path: normalizePath(path, parent),
    components: route.components || { default: route.component },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null ? {} : route.components ? route.props : { default: route.props }
  };

  if (route.children) {
    // Warn if route is named and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (process.env.NODE_ENV !== 'production') {
      if (route.name && route.children.some(function (child) {
        return (/^\/?$/.test(child.path)
        );
      })) {
        warn(false, "Named Route '" + route.name + "' has a default child route. " + "When navigating to this named route (:to=\"{name: '" + route.name + "'\"), " + "the default child route will not be rendered. Remove the name from " + "this route and use the name of the default child route for named " + "links instead.");
      }
    }
    route.children.forEach(function (child) {
      var childMatchAs = matchAs ? cleanPath(matchAs + "/" + child.path) : undefined;
      addRouteRecord(pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (route.alias !== undefined) {
    if (Array.isArray(route.alias)) {
      route.alias.forEach(function (alias) {
        var aliasRoute = {
          path: alias,
          children: route.children
        };
        addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);
      });
    } else {
      var aliasRoute = {
        path: route.alias,
        children: route.children
      };
      addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);
    }
  }

  if (!pathMap[record.path]) {
    pathMap[record.path] = record;
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {
      warn(false, "Duplicate named routes definition: " + "{ name: \"" + name + "\", path: \"" + record.path + "\" }");
    }
  }
}

function normalizePath(path, parent) {
  path = path.replace(/\/$/, '');
  if (path[0] === '/') {
    return path;
  }
  if (parent == null) {
    return path;
  }
  return cleanPath(parent.path + "/" + path);
}

var index$1 = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

var isarray = index$1;

/**
 * Expose `pathToRegexp`.
 */
var index = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)',
// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens;
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile(str, options) {
  return tokensToFunction(parse(str, options));
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (_typeof(tokens[i]) === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags(options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys);
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp(path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */keys);
  }

  if (isarray(path)) {
    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);
  }

  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);
}

index.parse = parse_1;
index.compile = compile_1;
index.tokensToFunction = tokensToFunction_1;
index.tokensToRegExp = tokensToRegExp_1;

/*  */

var regexpCache = Object.create(null);

function getRouteRegex(path) {
  var hit = regexpCache[path];
  var keys, regexp;

  if (hit) {
    keys = hit.keys;
    regexp = hit.regexp;
  } else {
    keys = [];
    regexp = index(path, keys);
    regexpCache[path] = { keys: keys, regexp: regexp };
  }

  return { keys: keys, regexp: regexp };
}

var regexpCompileCache = Object.create(null);

function fillParams(path, params, routeMsg) {
  try {
    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = index.compile(path));
    return filler(params || {}, { pretty: true });
  } catch (e) {
    if (process.env.NODE_ENV !== 'production') {
      warn(false, "missing param for " + routeMsg + ": " + e.message);
    }
    return '';
  }
}

/*  */

function normalizeLocation(raw, current, append) {
  var next = typeof raw === 'string' ? { path: raw } : raw;
  // named target
  if (next.name || next._normalized) {
    return next;
  }

  // relative params
  if (!next.path && next.params && current) {
    next = assign({}, next);
    next._normalized = true;
    var params = assign(assign({}, current.params), next.params);
    if (current.name) {
      next.name = current.name;
      next.params = params;
    } else if (current.matched) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params, "path " + current.path);
    } else if (process.env.NODE_ENV !== 'production') {
      warn(false, "relative params navigation requires a current route.");
    }
    return next;
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = current && current.path || '/';
  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : current && current.path || '/';
  var query = resolveQuery(parsedPath.query, next.query);
  var hash = next.hash || parsedPath.hash;
  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  };
}

function assign(a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a;
}

/*  */

function createMatcher(routes) {
  var ref = createRouteMap(routes);
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes(routes) {
    createRouteMap(routes, pathMap, nameMap);
  }

  function match(raw, currentRoute, redirectedFrom) {
    var location = normalizeLocation(raw, currentRoute);
    var name = location.name;

    if (name) {
      var record = nameMap[name];
      if (process.env.NODE_ENV !== 'production') {
        warn(record, "Route with name '" + name + "' does not exist");
      }
      var paramNames = getRouteRegex(record.path).keys.filter(function (key) {
        return !key.optional;
      }).map(function (key) {
        return key.name;
      });

      if (_typeof(location.params) !== 'object') {
        location.params = {};
      }

      if (currentRoute && _typeof(currentRoute.params) === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, "named route \"" + name + "\"");
        return _createRoute(record, location, redirectedFrom);
      }
    } else if (location.path) {
      location.params = {};
      for (var path in pathMap) {
        if (matchRoute(path, location.params, location.path)) {
          return _createRoute(pathMap[path], location, redirectedFrom);
        }
      }
    }
    // no match
    return _createRoute(null, location);
  }

  function redirect(record, location) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location)) : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = { path: redirect };
    }

    if (!redirect || (typeof redirect === "undefined" ? "undefined" : _typeof(redirect)) !== 'object') {
      process.env.NODE_ENV !== 'production' && warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      return _createRoute(null, location);
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];
      if (process.env.NODE_ENV !== 'production') {
        assert(targetRecord, "redirect failed: named route \"" + name + "\" not found.");
      }
      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location);
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record);
      // 2. resolve params
      var resolvedPath = fillParams(rawPath, params, "redirect route with path \"" + rawPath + "\"");
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location);
    } else {
      warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      return _createRoute(null, location);
    }
  }

  function alias(record, location, matchAs) {
    var aliasedPath = fillParams(matchAs, location.params, "aliased route with path \"" + matchAs + "\"");
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });
    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location);
    }
    return _createRoute(null, location);
  }

  function _createRoute(record, location, redirectedFrom) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location);
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs);
    }
    return createRoute(record, location, redirectedFrom);
  }

  return {
    match: match,
    addRoutes: addRoutes
  };
}

function matchRoute(path, params, pathname) {
  var ref = getRouteRegex(path);
  var regexp = ref.regexp;
  var keys = ref.keys;
  var m = pathname.match(regexp);

  if (!m) {
    return false;
  } else if (!params) {
    return true;
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
    if (key) {
      params[key.name] = val;
    }
  }

  return true;
}

function resolveRecordPath(path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true);
}

/*  */

var positionStore = Object.create(null);

function setupScroll() {
  window.addEventListener('popstate', function (e) {
    saveScrollPosition();
    if (e.state && e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll(router, to, from, isPop) {
  if (!router.app) {
    return;
  }

  var behavior = router.options.scrollBehavior;
  if (!behavior) {
    return;
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  }

  // wait until re-render finishes before scrolling
  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior(to, from, isPop ? position : null);
    if (!shouldScroll) {
      return;
    }
    var isObject = (typeof shouldScroll === "undefined" ? "undefined" : _typeof(shouldScroll)) === 'object';
    if (isObject && typeof shouldScroll.selector === 'string') {
      var el = document.querySelector(shouldScroll.selector);
      if (el) {
        position = getElementPosition(el);
      } else if (isValidPosition(shouldScroll)) {
        position = normalizePosition(shouldScroll);
      }
    } else if (isObject && isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }

    if (position) {
      window.scrollTo(position.x, position.y);
    }
  });
}

function saveScrollPosition() {
  var key = getStateKey();
  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition() {
  var key = getStateKey();
  if (key) {
    return positionStore[key];
  }
}

function getElementPosition(el) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left,
    y: elRect.top - docRect.top
  };
}

function isValidPosition(obj) {
  return isNumber(obj.x) || isNumber(obj.y);
}

function normalizePosition(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  };
}

function isNumber(v) {
  return typeof v === 'number';
}

/*  */

var supportsPushState = inBrowser && function () {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
    return false;
  }

  return window.history && 'pushState' in window.history;
}();

// use User Timing api (if present) for more accurate key precision
var Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;

var _key = genKey();

function genKey() {
  return Time.now().toFixed(3);
}

function getStateKey() {
  return _key;
}

function setStateKey(key) {
  _key = key;
}

function pushState(url, replace) {
  saveScrollPosition();
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  var history = window.history;
  try {
    if (replace) {
      history.replaceState({ key: _key }, '', url);
    } else {
      _key = genKey();
      history.pushState({ key: _key }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState(url) {
  pushState(url, true);
}

/*  */

function runQueue(queue, fn, cb) {
  var step = function step(index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/*  */

var History = function History(router, base) {
  this.router = router;
  this.base = normalizeBase(base);
  // start with a route object that stands for "nowhere"
  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
};

History.prototype.listen = function listen(cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady(cb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);
  }
};

History.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {
  var this$1 = this;

  var route = this.router.match(location, this.current);
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete && onComplete(route);
    this$1.ensureURL();

    // fire ready cbs once
    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) {
        cb(route);
      });
    }
  }, onAbort);
};

History.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {
  var this$1 = this;

  var current = this.current;
  var abort = function abort() {
    onAbort && onAbort();
  };
  if (isSameRoute(route, current) &&
  // in the case the route map has been dynamically appended to
  route.matched.length === current.matched.length) {
    this.ensureURL();
    return abort();
  }

  var ref = resolveQueue(this.current.matched, route.matched);
  var updated = ref.updated;
  var deactivated = ref.deactivated;
  var activated = ref.activated;

  var queue = [].concat(
  // in-component leave guards
  extractLeaveGuards(deactivated),
  // global before hooks
  this.router.beforeHooks,
  // in-component update hooks
  extractUpdateHooks(updated),
  // in-config enter guards
  activated.map(function (m) {
    return m.beforeEnter;
  }),
  // async components
  resolveAsyncComponents(activated));

  this.pending = route;
  var iterator = function iterator(hook, next) {
    if (this$1.pending !== route) {
      return abort();
    }
    hook(route, current, function (to) {
      if (to === false) {
        // next(false) -> abort navigation, ensure current URL
        this$1.ensureURL(true);
        abort();
      } else if (typeof to === 'string' || (typeof to === "undefined" ? "undefined" : _typeof(to)) === 'object') {
        // next('/') or next({ path: '/' }) -> redirect
        (typeof to === "undefined" ? "undefined" : _typeof(to)) === 'object' && to.replace ? this$1.replace(to) : this$1.push(to);
        abort();
      } else {
        // confirm transition and pass on the value
        next(to);
      }
    });
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];
    var isValid = function isValid() {
      return this$1.current === route;
    };
    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    // wait until async components are resolved before
    // extracting in-component enter guards
    runQueue(enterGuards, iterator, function () {
      if (this$1.pending !== route) {
        return abort();
      }
      this$1.pending = null;
      onComplete(route);
      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) {
            return cb();
          });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute(route) {
  var prev = this.current;
  this.current = route;
  this.cb && this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook && hook(route, prev);
  });
};

function normalizeBase(base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = baseEl && baseEl.getAttribute('href') || '/';
    } else {
      base = '/';
    }
  }
  // make sure there's the starting slash
  if (base.charAt(0) !== '/') {
    base = '/' + base;
  }
  // remove trailing slash
  return base.replace(/\/$/, '');
}

function resolveQueue(current, next) {
  var i;
  var max = Math.max(current.length, next.length);
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break;
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  };
}

function extractGuards(records, name, bind, reverse) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);
    if (guard) {
      return Array.isArray(guard) ? guard.map(function (guard) {
        return bind(guard, instance, match, key);
      }) : bind(guard, instance, match, key);
    }
  });
  return flatten(reverse ? guards.reverse() : guards);
}

function extractGuard(def, key) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }
  return def.options[key];
}

function extractLeaveGuards(deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);
}

function extractUpdateHooks(updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard);
}

function bindGuard(guard, instance) {
  return function boundRouteGuard() {
    return guard.apply(instance, arguments);
  };
}

function extractEnterGuards(activated, cbs, isValid) {
  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key, cbs, isValid);
  });
}

function bindEnterGuard(guard, match, key, cbs, isValid) {
  return function routeEnterGuard(to, from, next) {
    return guard(to, from, function (cb) {
      next(cb);
      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
    });
  };
}

function poll(cb, // somehow flow cannot infer this is a function
instances, key, isValid) {
  if (instances[key]) {
    cb(instances[key]);
  } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}

function resolveAsyncComponents(matched) {
  return flatMapComponents(matched, function (def, _, match, key) {
    // if it's a function and doesn't have Vue options attached,
    // assume it's an async component resolve function.
    // we are not using Vue's default async resolving mechanism because
    // we want to halt the navigation until the incoming component has been
    // resolved.
    if (typeof def === 'function' && !def.options) {
      return function (to, from, next) {
        var resolve = once(function (resolvedDef) {
          match.components[key] = resolvedDef;
          next();
        });

        var reject = once(function (reason) {
          warn(false, "Failed to resolve async component " + key + ": " + reason);
          next(false);
        });

        var res = def(resolve, reject);
        if (res && typeof res.then === 'function') {
          res.then(resolve, reject);
        }
      };
    }
  });
}

function flatMapComponents(matched, fn) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return fn(m.components[key], m.instances[key], m, key);
    });
  }));
}

function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}

// in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.
function once(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    return fn.apply(this, arguments);
  };
}

/*  */

var HTML5History = function (History$$1) {
  function HTML5History(router, base) {
    var this$1 = this;

    History$$1.call(this, router, base);

    var expectScroll = router.options.scrollBehavior;

    if (expectScroll) {
      setupScroll();
    }

    window.addEventListener('popstate', function (e) {
      this$1.transitionTo(getLocation(this$1.base), function (route) {
        if (expectScroll) {
          handleScroll(router, route, this$1.current, true);
        }
      });
    });
  }

  if (History$$1) HTML5History.__proto__ = History$$1;
  HTML5History.prototype = Object.create(History$$1 && History$$1.prototype);
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go(n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, this$1.current, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, this$1.current, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL(push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {
    return getLocation(this.base);
  };

  return HTML5History;
}(History);

function getLocation(base) {
  var path = window.location.pathname;
  if (base && path.indexOf(base) === 0) {
    path = path.slice(base.length);
  }
  return (path || '/') + window.location.search + window.location.hash;
}

/*  */

var HashHistory = function (History$$1) {
  function HashHistory(router, base, fallback) {
    History$$1.call(this, router, base);
    // check history fallback deeplinking
    if (fallback && checkFallback(this.base)) {
      return;
    }
    ensureSlash();
  }

  if (History$$1) HashHistory.__proto__ = History$$1;
  HashHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  HashHistory.prototype.constructor = HashHistory;

  // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early
  HashHistory.prototype.setupListeners = function setupListeners() {
    var this$1 = this;

    window.addEventListener('hashchange', function () {
      if (!ensureSlash()) {
        return;
      }
      this$1.transitionTo(getHash(), function (route) {
        replaceHash(route.fullPath);
      });
    });
  };

  HashHistory.prototype.push = function push(location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go(n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL(push) {
    var current = this.current.fullPath;
    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    return getHash();
  };

  return HashHistory;
}(History);

function checkFallback(base) {
  var location = getLocation(base);
  if (!/^\/#/.test(location)) {
    window.location.replace(cleanPath(base + '/#' + location));
    return true;
  }
}

function ensureSlash() {
  var path = getHash();
  if (path.charAt(0) === '/') {
    return true;
  }
  replaceHash('/' + path);
  return false;
}

function getHash() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : href.slice(index + 1);
}

function pushHash(path) {
  window.location.hash = path;
}

function replaceHash(path) {
  var i = window.location.href.indexOf('#');
  window.location.replace(window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path);
}

/*  */

var AbstractHistory = function (History$$1) {
  function AbstractHistory(router, base) {
    History$$1.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if (History$$1) AbstractHistory.__proto__ = History$$1;
  AbstractHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go(n) {
    var this$1 = this;

    var targetIndex = this.index + n;
    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return;
    }
    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      this$1.index = targetIndex;
      this$1.updateRoute(route);
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/';
  };

  AbstractHistory.prototype.ensureURL = function ensureURL() {
    // noop
  };

  return AbstractHistory;
}(History);

/*  */

var VueRouter = function VueRouter(options) {
  if (options === void 0) options = {};

  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || []);

  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState;
  if (this.fallback) {
    mode = 'hash';
  }
  if (!inBrowser) {
    mode = 'abstract';
  }
  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break;
    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break;
    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break;
    default:
      if (process.env.NODE_ENV !== 'production') {
        assert(false, "invalid mode: " + mode);
      }
  }
};

var prototypeAccessors = { currentRoute: {} };

VueRouter.prototype.match = function match(raw, current, redirectedFrom) {
  return this.matcher.match(raw, current, redirectedFrom);
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current;
};

VueRouter.prototype.init = function init(app /* Vue component instance */) {
  var this$1 = this;

  process.env.NODE_ENV !== 'production' && assert(install.installed, "not installed. Make sure to call `Vue.use(VueRouter)` " + "before creating root instance.");

  this.apps.push(app);

  // main app already initialized.
  if (this.app) {
    return;
  }

  this.app = app;

  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function setupHashListener() {
      history.setupListeners();
    };
    history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach(fn) {
  this.beforeHooks.push(fn);
};

VueRouter.prototype.afterEach = function afterEach(fn) {
  this.afterHooks.push(fn);
};

VueRouter.prototype.onReady = function onReady(cb) {
  this.history.onReady(cb);
};

VueRouter.prototype.push = function push(location, onComplete, onAbort) {
  this.history.push(location, onComplete, onAbort);
};

VueRouter.prototype.replace = function replace(location, onComplete, onAbort) {
  this.history.replace(location, onComplete, onAbort);
};

VueRouter.prototype.go = function go(n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back() {
  this.go(-1);
};

VueRouter.prototype.forward = function forward() {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {
  var route = to ? this.resolve(to).route : this.currentRoute;
  if (!route) {
    return [];
  }
  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key];
    });
  }));
};

VueRouter.prototype.resolve = function resolve(to, current, append) {
  var location = normalizeLocation(to, current || this.history.current, append);
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  };
};

VueRouter.prototype.addRoutes = function addRoutes(routes) {
  this.matcher.addRoutes(routes);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties(VueRouter.prototype, prototypeAccessors);

function createHref(base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path;
}

VueRouter.install = install;
VueRouter.version = '2.2.1';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

exports.default = VueRouter;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Vue.js v2.2.4
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
/*  */

/**
 * Convert a value to a string that is actually rendered.
 */
function _toString(val) {
  return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Remove an item from an array
 */
function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

/**
 * Check if value is primitive
 */
function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number';
}

/**
 * Create a cached version of a pure function.
 */
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /([^-])([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();
});

/**
 * Simple bind, faster than native
 */
function bind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn;
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret;
}

/**
 * Mix properties into target object.
 */
function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject(obj) {
  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
var toString = Object.prototype.toString;
var OBJECT_STRING = '[object Object]';
function isPlainObject(obj) {
  return toString.call(obj) === OBJECT_STRING;
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}

/**
 * Perform no operation.
 */
function noop() {}

/**
 * Always return false.
 */
var no = function no() {
  return false;
};

/**
 * Return same value
 */
var identity = function identity(_) {
  return _;
};

/**
 * Generate a static keys string from compiler modules.
 */
function genStaticKeys(modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || []);
  }, []).join(',');
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual(a, b) {
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      return JSON.stringify(a) === JSON.stringify(b);
    } catch (e) {
      // possible circular reference
      return a === b;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}

function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }
  return -1;
}

/**
 * Ensure a function is called only once.
 */
function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn();
    }
  };
}

/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: process.env.NODE_ENV !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: process.env.NODE_ENV !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * List of asset types that a component can own.
   */
  _assetTypes: ['component', 'directive', 'filter'],

  /**
   * List of lifecycle hooks.
   */
  _lifecycleHooks: ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'],

  /**
   * Max circular updates allowed in a scheduler flush cycle.
   */
  _maxUpdateCount: 100
};

/*  */

var emptyObject = Object.freeze({});

/**
 * Check if a string starts with $ or _
 */
function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}

/**
 * Define a property.
 */
function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }
      obj = obj[segments[i]];
    }
    return obj;
  };
}

/*  */
/* globals MutationObserver */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function isServerRendering() {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer;
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative(Ctor) {
  return (/native code/.test(Ctor.toString())
  );
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

/**
 * Defer a task to execute it asynchronously.
 */
var nextTick = function () {
  var callbacks = [];
  var pending = false;
  var timerFunc;

  function nextTickHandler() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // the nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore if */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    var logError = function logError(err) {
      console.error(err);
    };
    timerFunc = function timerFunc() {
      p.then(nextTickHandler).catch(logError);
      // in problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) {
        setTimeout(noop);
      }
    };
  } else if (typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]')) {
    // use MutationObserver where native Promise is not available,
    // e.g. PhantomJS IE11, iOS7, Android 4.4
    var counter = 1;
    var observer = new MutationObserver(nextTickHandler);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function timerFunc() {
      counter = (counter + 1) % 2;
      textNode.data = String(counter);
    };
  } else {
    // fallback to setTimeout
    /* istanbul ignore next */
    timerFunc = function timerFunc() {
      setTimeout(nextTickHandler, 0);
    };
  }

  return function queueNextTick(cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        cb.call(ctx);
      }
      if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      timerFunc();
    }
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve) {
        _resolve = resolve;
      });
    }
  };
}();

var _Set;
/* istanbul ignore if */
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = function () {
    function Set() {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };
    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}

var warn = noop;
var tip = noop;
var formatComponentName;

if (process.env.NODE_ENV !== 'production') {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function classify(str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function warn(msg, vm) {
    if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + " " + (vm ? formatLocation(formatComponentName(vm)) : ''));
    }
  };

  tip = function tip(msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + " " + (vm ? formatLocation(formatComponentName(vm)) : ''));
    }
  };

  formatComponentName = function formatComponentName(vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }
    var name = typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;

    var file = vm._isVue && vm.$options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var formatLocation = function formatLocation(str) {
    if (str === "<Anonymous>") {
      str += " - use the \"name\" option for better debugging messages.";
    }
    return "\n(found in " + str + ")";
  };
}

/*  */

var uid$1 = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep() {
  this.id = uid$1++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget(_target) {
  if (Dep.target) {
    targetStack.push(Dep.target);
  }
  Dep.target = _target;
}

function popTarget() {
  Dep.target = targetStack.pop();
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var arguments$1 = arguments;

    // avoid leaking arguments:
    // http://jsperf.com/closure-with-arguments
    var i = arguments.length;
    var args = new Array(i);
    while (i--) {
      args[i] = arguments$1[i];
    }
    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
        inserted = args;
        break;
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    if (inserted) {
      ob.observeArray(inserted);
    }
    // notify change
    ob.dep.notify();
    return result;
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true,
  isSettingProps: false
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto ? protoAugment : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe(value, asRootData) {
  if (!isObject(value)) {
    return;
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob;
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1(obj, key, val, customSetter) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return;
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
        }
        if (Array.isArray(value)) {
          dependArray(value);
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set(target, key, val) {
  if (Array.isArray(target)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  if (hasOwn(target, key)) {
    target[key] = val;
    return val;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    process.env.NODE_ENV !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }
  if (!ob) {
    target[key] = val;
    return val;
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}

/**
 * Delete a property and trigger change if necessary.
 */
function del(target, key) {
  if (Array.isArray(target)) {
    target.splice(key, 1);
    return;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    process.env.NODE_ENV !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }
  if (!hasOwn(target, key)) {
    return;
  }
  delete target[key];
  if (!ob) {
    return;
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (process.env.NODE_ENV !== 'production') {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }
    return defaultStrat(parent, child);
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData(to, from) {
  if (!from) {
    return to;
  }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to;
}

/**
 * Data
 */
strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }
    if (typeof childVal !== 'function') {
      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
      return parentVal;
    }
    if (!parentVal) {
      return childVal;
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn() {
      return mergeData(childVal.call(this), parentVal.call(this));
    };
  } else if (parentVal || childVal) {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook(parentVal, childVal) {
  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
}

config._lifecycleHooks.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets(parentVal, childVal) {
  var res = Object.create(parentVal || null);
  return childVal ? extend(res, childVal) : res;
}

config._assetTypes.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal) {
  /* istanbul ignore if */
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = {};
  extend(ret, parentVal);
  for (var key in childVal) {
    var parent = ret[key];
    var child = childVal[key];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key] = parent ? parent.concat(child) : [child];
  }
  return ret;
};

/**
 * Other object hashes.
 */
strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = Object.create(null);
  extend(ret, parentVal);
  extend(ret, childVal);
  return ret;
};

/**
 * Default strategy.
 */
var defaultStrat = function defaultStrat(parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};

/**
 * Validate component names
 */
function checkComponents(options) {
  for (var key in options.components) {
    var lower = key.toLowerCase();
    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
    }
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps(options) {
  var props = options.props;
  if (!props) {
    return;
  }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (process.env.NODE_ENV !== 'production') {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : { type: val };
    }
  }
  options.props = res;
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives(options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions(parent, child, vm) {
  if (process.env.NODE_ENV !== 'production') {
    checkComponents(child);
  }
  normalizeProps(child);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = typeof extendsFrom === 'function' ? mergeOptions(parent, extendsFrom.options, vm) : mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      var mixin = child.mixins[i];
      if (mixin.prototype instanceof Vue$3) {
        mixin = mixin.options;
      }
      parent = mergeOptions(parent, mixin, vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options;
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) {
    return assets[id];
  }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }
  return res;
}

/*  */

function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  if (process.env.NODE_ENV !== 'production') {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}

/**
 * Assert whether a prop is valid.
 */
function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn('Invalid prop: type check failed for prop "' + name + '".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);
    return;
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

/**
 * Assert the type of a value
 */
function assertType(value, type) {
  var valid;
  var expectedType = getType(type);
  if (expectedType === 'String') {
    valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === (expectedType = 'string');
  } else if (expectedType === 'Number') {
    valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === (expectedType = 'number');
  } else if (expectedType === 'Boolean') {
    valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === (expectedType = 'boolean');
  } else if (expectedType === 'Function') {
    valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === (expectedType = 'function');
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  };
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match && match[1];
}

function isType(type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type);
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true;
    }
  }
  /* istanbul ignore next */
  return false;
}

function handleError(err, vm, info) {
  if (config.errorHandler) {
    config.errorHandler.call(null, err, vm, info);
  } else {
    if (process.env.NODE_ENV !== 'production') {
      warn("Error in " + info + ":", vm);
    }
    /* istanbul ignore else */
    if (inBrowser && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err;
    }
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (process.env.NODE_ENV !== 'production') {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function warnNonPresent(target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + "referenced during render. Make sure to declare reactive data " + "properties in the data option.", target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed;
    }
  };

  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

var mark;
var measure;

if (process.env.NODE_ENV !== 'production') {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function mark(tag) {
      return perf.mark(tag);
    };
    measure = function measure(name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/*  */

var VNode = function VNode(tag, data, children, text, elm, context, componentOptions) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.functionalContext = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
};

var prototypeAccessors = { child: {} };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function createEmptyVNode() {
  var node = new VNode();
  node.text = '';
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isCloned = true;
  return cloned;
}

function cloneVNodes(vnodes) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i]);
  }
  return res;
}

/*  */

var normalizeEvent = cached(function (name) {
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture
  };
});

function createFnInvoker(fns) {
  function invoker() {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      for (var i = 0; i < fns.length; i++) {
        fns[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments);
    }
  }
  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, vm) {
  var name, cur, old, event;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (!cur) {
      process.env.NODE_ENV !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (!old) {
      if (!cur.fns) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (!on[name]) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook(def, hookKey, hook) {
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (!oldHook) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (oldHook.fns && oldHook.merged) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }
  return children;
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (c == null || typeof c === 'boolean') {
      continue;
    }
    last = res[res.length - 1];
    //  nested
    if (Array.isArray(c)) {
      res.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + "_" + i));
    } else if (isPrimitive(c)) {
      if (last && last.text) {
        last.text += String(c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (c.text && last && last.text) {
        res[res.length - 1] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (c.tag && c.key == null && nestedIndex != null) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res;
}

/*  */

function getFirstComponentChild(children) {
  return children && children.filter(function (c) {
    return c && c.componentOptions;
  })[0];
}

/*  */

function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn, once$$1) {
  if (once$$1) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        this$1.$off(event[i$1], fn);
      }
      return vm;
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm;
    }
    if (arguments.length === 1) {
      vm._events[event] = null;
      return vm;
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }
    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        cbs[i].apply(vm, args);
      }
    }
    return vm;
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots(children, context) {
  var slots = {};
  if (!children) {
    return slots;
  }
  var defaultSlot = [];
  var name, child;
  for (var i = 0, l = children.length; i < l; i++) {
    child = children[i];
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.functionalContext === context) && child.data && (name = child.data.slot)) {
      var slot = slots[name] || (slots[name] = []);
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children);
      } else {
        slot.push(child);
      }
    } else {
      defaultSlot.push(child);
    }
  }
  // ignore whitespace
  if (!defaultSlot.every(isWhitespace)) {
    slots.default = defaultSlot;
  }
  return slots;
}

function isWhitespace(node) {
  return node.isComment || node.text === ' ';
}

function resolveScopedSlots(fns) {
  var res = {};
  for (var i = 0; i < fns.length; i++) {
    res[fns[i][0]] = fns[i][1];
  }
  return res;
}

/*  */

var activeInstance = null;

function initLifecycle(vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
      , vm.$options._parentElm, vm.$options._refElm);
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return;
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (process.env.NODE_ENV !== 'production') {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = function updateComponent() {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(name + " render", startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function updateComponent() {
      vm._update(vm._render(), hydrating);
    };
  }

  vm._watcher = new Watcher(vm, updateComponent, noop);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  parentVnode.data.scopedSlots || // has new scoped slots
  vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render
  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    if (process.env.NODE_ENV !== 'production') {
      observerState.isSettingProps = true;
    }
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    if (process.env.NODE_ENV !== 'production') {
      observerState.isSettingProps = false;
    }
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }
  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }
  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }
  if (vm._inactive || vm._inactive == null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return;
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, hook + " hook");
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */

var queue = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState() {
  queue.length = 0;
  has = {};
  if (process.env.NODE_ENV !== 'production') {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue() {
  flushing = true;
  var watcher, id, vm;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) {
    return a.id - b.id;
  });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > config._maxUpdateCount) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  }

  // call updated hooks
  index = queue.length;
  while (index--) {
    watcher = queue[index];
    vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }

  resetSchedulerState();
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher(watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i >= 0 && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(Math.max(i, index) + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher(vm, expOrFn, cb, options) {
  this.vm = vm;
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      process.env.NODE_ENV !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }
  this.value = this.lazy ? undefined : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;
  if (this.user) {
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    }
  } else {
    value = this.getter.call(vm, vm);
  }
  // "touch" every property so they are all tracked as
  // dependencies for deep watching
  if (this.deep) {
    traverse(value);
  }
  popTarget();
  this.cleanupDeps();
  return value;
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();
    if (value !== this.value ||
    // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown() {
  var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
var seenObjects = new _Set();
function traverse(val) {
  seenObjects.clear();
  _traverse(val, seenObjects);
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if (!isA && !isObject(val) || !Object.isExtensible(val)) {
    return;
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return;
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) {
    initProps(vm, opts.props);
  }
  if (opts.methods) {
    initMethods(vm, opts.methods);
  }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) {
    initComputed(vm, opts.computed);
  }
  if (opts.watch) {
    initWatch(vm, opts.watch);
  }
}

var isReservedProp = { key: 1, ref: 1, slot: 1 };

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function loop(key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      if (isReservedProp[key]) {
        warn("\"" + key + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }
      defineReactive$$1(props, key, value, function () {
        if (vm.$parent && !observerState.isSettingProps) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {
      defineReactive$$1(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) {
    loop(key);
  }observerState.shouldConvert = true;
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? data.call(vm) : data || {};
  if (!isPlainObject(data)) {
    data = {};
    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var i = keys.length;
  while (i--) {
    if (props && hasOwn(props, keys[i])) {
      process.env.NODE_ENV !== 'production' && warn("The data property \"" + keys[i] + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(keys[i])) {
      proxy(vm, "_data", keys[i]);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

var computedWatcherOptions = { lazy: true };

function initComputed(vm, computed) {
  var watchers = vm._computedWatchers = Object.create(null);

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    // create internal watcher for the computed property.
    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    }
  }
}

function defineComputed(target, key, userDef) {
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = createComputedGetter(key);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value;
    }
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
    if (process.env.NODE_ENV !== 'production') {
      if (methods[key] == null) {
        warn("method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
      }
      if (props && hasOwn(props, key)) {
        warn("method \"" + key + "\" has already been defined as a prop.", vm);
      }
    }
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, key, handler) {
  var options;
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  vm.$watch(key, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () {
    return this._data;
  };
  var propsDef = {};
  propsDef.get = function () {
    return this._props;
  };
  if (process.env.NODE_ENV !== 'production') {
    dataDef.set = function (newData) {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn() {
      watcher.teardown();
    };
  };
}

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init(vnode, hydrating, parentElm, refElm) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },

  insert: function insert(vnode) {
    if (!vnode.componentInstance._isMounted) {
      vnode.componentInstance._isMounted = true;
      callHook(vnode.componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      activateChildComponent(vnode.componentInstance, true /* direct */);
    }
  },

  destroy: function destroy(vnode) {
    if (!vnode.componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        vnode.componentInstance.$destroy();
      } else {
        deactivateChildComponent(vnode.componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (!Ctor) {
    return;
  }

  var baseCtor = context.$options._base;
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  if (typeof Ctor !== 'function') {
    if (process.env.NODE_ENV !== 'production') {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  }

  // async component
  if (!Ctor.cid) {
    if (Ctor.resolved) {
      Ctor = Ctor.resolved;
    } else {
      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {
        // it's ok to queue this on every render because
        // $forceUpdate is buffered by the scheduler.
        context.$forceUpdate();
      });
      if (!Ctor) {
        // return nothing if this is indeed an async component
        // wait for the callback to trigger parent update.
        return;
      }
    }
  }

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  data = data || {};

  // transform component v-model data into props & events
  if (data.model) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractProps(data, Ctor);

  // functional component
  if (Ctor.options.functional) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  data.on = data.nativeOn;

  if (Ctor.options.abstract) {
    // abstract components do not keep anything
    // other than props & listeners
    data = {};
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children });
  return vnode;
}

function createFunctionalComponent(Ctor, propsData, data, context, children) {
  var props = {};
  var propOptions = Ctor.options.props;
  if (propOptions) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData);
    }
  }
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var _context = Object.create(context);
  var h = function h(a, b, c, d) {
    return createElement(_context, a, b, c, d, true);
  };
  var vnode = Ctor.options.render.call(null, h, {
    props: props,
    data: data,
    parent: context,
    children: children,
    slots: function slots() {
      return resolveSlots(children, context);
    }
  });
  if (vnode instanceof VNode) {
    vnode.functionalContext = context;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent, // activeInstance in lifecycle state
parentElm, refElm) {
  var vnodeComponentOptions = vnode.componentOptions;
  var options = {
    _isComponent: true,
    parent: parent,
    propsData: vnodeComponentOptions.propsData,
    _componentTag: vnodeComponentOptions.tag,
    _parentVnode: vnode,
    _parentListeners: vnodeComponentOptions.listeners,
    _renderChildren: vnodeComponentOptions.children,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (inlineTemplate) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnodeComponentOptions.Ctor(options);
}

function resolveAsyncComponent(factory, baseCtor, cb) {
  if (factory.requested) {
    // pool callbacks
    factory.pendingCallbacks.push(cb);
  } else {
    factory.requested = true;
    var cbs = factory.pendingCallbacks = [cb];
    var sync = true;

    var resolve = function resolve(res) {
      if (isObject(res)) {
        res = baseCtor.extend(res);
      }
      // cache resolved
      factory.resolved = res;
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        for (var i = 0, l = cbs.length; i < l; i++) {
          cbs[i](res);
        }
      }
    };

    var reject = function reject(reason) {
      process.env.NODE_ENV !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
    };

    var res = factory(resolve, reject);

    // handle promise
    if (res && typeof res.then === 'function' && !factory.resolved) {
      res.then(resolve, reject);
    }

    sync = false;
    // return in case resolved synchronously
    return factory.resolved;
  }
}

function extractProps(data, Ctor) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (!propOptions) {
    return;
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  var domProps = data.domProps;
  if (attrs || props || domProps) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (process.env.NODE_ENV !== 'production') {
        var keyInLowerCase = key.toLowerCase();
        if (key !== keyInLowerCase && attrs && attrs.hasOwnProperty(keyInLowerCase)) {
          warn("Prop \"" + keyInLowerCase + "\" is not declared in component " + formatComponentName(Ctor) + ". Note that HTML attributes are " + "case-insensitive and camelCased props need to use their kebab-case " + "equivalents when using in-DOM templates. You should probably use " + "\"" + altKey + "\" instead of \"" + key + "\".");
        }
      }
      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey) || checkProp(res, domProps, key, altKey);
    }
  }
  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (hash) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true;
    }
  }
  return false;
}

function mergeHooks(data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1(one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  };
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (on[event]) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (alwaysNormalize) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (data && data.__ob__) {
    process.env.NODE_ENV !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if (Ctor = resolveAsset(context.$options, 'components', tag)) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (vnode) {
    if (ns) {
      applyNS(vnode, ns);
    }
    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    return;
  }
  if (vnode.children) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (child.tag && !child.ns) {
        applyNS(child, ns);
      }
    }
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList(val, render) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  return ret;
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  if (scopedSlotFn) {
    // scoped slot
    props = props || {};
    if (bindObject) {
      extend(props, bindObject);
    }
    return scopedSlotFn(props) || fallback;
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes && process.env.NODE_ENV !== 'production') {
      slotNodes._rendered && warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
      slotNodes._rendered = true;
    }
    return slotNodes || fallback;
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 */
function checkKeyCodes(eventKeyCode, key, builtInAlias) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (Array.isArray(keyCodes)) {
    return keyCodes.indexOf(eventKeyCode) === -1;
  } else {
    return keyCodes !== eventKeyCode;
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps(data, tag, value, asProp) {
  if (value) {
    if (!isObject(value)) {
      process.env.NODE_ENV !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      for (var key in value) {
        if (key === 'class' || key === 'style') {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];
        }
      }
    }
  }
  return data;
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic(index, isInFor) {
  var tree = this._staticTrees[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);
  }
  // otherwise, render a fresh tree.
  tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
  markStatic(tree, "__static__" + index, false);
  return tree;
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function initRender(vm) {
  vm.$vnode = null; // the placeholder node in parent tree
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null;
  var parentVnode = vm.$options._parentVnode;
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  };
}

function renderMixin(Vue) {
  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var staticRenderFns = ref.staticRenderFns;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // clone slot nodes on re-renders
      for (var key in vm.$slots) {
        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
      }
    }

    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;

    if (staticRenderFns && !vm._staticTrees) {
      vm._staticTrees = [];
    }
    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render function");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        vnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode;
  };

  // internal render helpers.
  // these are exposed on the instance prototype to reduce generated render
  // code size.
  Vue.prototype._o = markOnce;
  Vue.prototype._n = toNumber;
  Vue.prototype._s = _toString;
  Vue.prototype._l = renderList;
  Vue.prototype._t = renderSlot;
  Vue.prototype._q = looseEqual;
  Vue.prototype._i = looseIndexOf;
  Vue.prototype._m = renderStatic;
  Vue.prototype._f = resolveFilter;
  Vue.prototype._k = checkKeyCodes;
  Vue.prototype._b = bindObjectProps;
  Vue.prototype._v = createTextVNode;
  Vue.prototype._e = createEmptyVNode;
  Vue.prototype._u = resolveScopedSlots;
}

/*  */

function initProvide(vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var inject = vm.$options.inject;
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    // isArray here
    var isArray = Array.isArray(inject);
    var keys = isArray ? inject : hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = isArray ? key : inject[key];
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          vm[key] = source._provided[provideKey];
          break;
        }
        source = source.$parent;
      }
    }
  }
}

/*  */

var uid = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      mark('vue-perf-init');
    }

    var vm = this;
    // a uid
    vm._uid = uid++;
    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark('vue-perf-init-end');
      measure(vm._name + " init", 'vue-perf-init', 'vue-perf-init-end');
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  opts.parent = options.parent;
  opts.propsData = options.propsData;
  opts._parentVnode = options._parentVnode;
  opts._parentListeners = options._parentListeners;
  opts._renderChildren = options._renderChildren;
  opts._componentTag = options._componentTag;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }
      modified[key] = dedupe(latest[key], sealed[key]);
    }
  }
  return modified;
}

function dedupe(latest, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    for (var i = 0; i < latest.length; i++) {
      if (sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res;
  } else {
    return latest;
  }
}

function Vue$3(options) {
  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue$3)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    /* istanbul ignore if */
    if (plugin.installed) {
      return;
    }
    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    plugin.installed = true;
    return this;
  };
}

/*  */

function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
  };
}

/*  */

function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;
    if (process.env.NODE_ENV !== 'production') {
      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
      }
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    config._assetTypes.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  config._assetTypes.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production') {
          if (type === 'component' && config.isReservedTag(id)) {
            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
          }
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}

/*  */

var patternTypes = [String, RegExp];

function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (pattern instanceof RegExp) {
    return pattern.test(name);
  }
  /* istanbul ignore next */
  return false;
}

function pruneCache(cache, filter) {
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cachedNode);
        cache[key] = null;
      }
    }
  }
}

function pruneCacheEntry(vnode) {
  if (vnode) {
    if (!vnode.componentInstance._inactive) {
      callHook(vnode.componentInstance, 'deactivated');
    }
    vnode.componentInstance.$destroy();
  }
}

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes
  },

  created: function created() {
    this.cache = Object.create(null);
  },

  destroyed: function destroyed() {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache[key]);
    }
  },

  watch: {
    include: function include(val) {
      pruneCache(this.cache, function (name) {
        return matches(val, name);
      });
    },
    exclude: function exclude(val) {
      pruneCache(this.cache, function (name) {
        return !matches(val, name);
      });
    }
  },

  render: function render() {
    var vnode = getFirstComponentChild(this.$slots.default);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      if (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {
        return vnode;
      }
      var key = vnode.key == null
      // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
      if (this.cache[key]) {
        vnode.componentInstance = this.cache[key].componentInstance;
      } else {
        this.cache[key] = vnode;
      }
      vnode.data.keepAlive = true;
    }
    return vnode;
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};
  configDef.get = function () {
    return config;
  };
  if (process.env.NODE_ENV !== 'production') {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  config._assetTypes.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Vue$3.version = '2.2.4';

/*  */

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select');
var mustUseProp = function mustUseProp(tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function isXlink(name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function getXlinkProp(name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function isFalsyAttrValue(val) {
  return val == null || val === false;
};

/*  */

function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (childNode.componentInstance) {
    childNode = childNode.componentInstance._vnode;
    if (childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (parentNode = parentNode.parent) {
    if (parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return genClassFromData(data);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: child.class ? [child.class, parent.class] : parent.class
  };
}

function genClassFromData(data) {
  var dynamicClass = data.class;
  var staticClass = data.staticClass;
  if (staticClass || dynamicClass) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */
  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  var res = '';
  if (!value) {
    return res;
  }
  if (typeof value === 'string') {
    return value;
  }
  if (Array.isArray(value)) {
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
      if (value[i]) {
        if (stringified = stringifyClass(value[i])) {
          res += stringified + ' ';
        }
      }
    }
    return res.slice(0, -1);
  }
  if (isObject(value)) {
    for (var key in value) {
      if (value[key]) {
        res += key + ' ';
      }
    }
    return res.slice(0, -1);
  }
  /* istanbul ignore next */
  return res;
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template');

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isPreTag = function isPreTag(tag) {
  return tag === 'pre';
};

var isReservedTag = function isReservedTag(tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }
  if (isReservedTag(tag)) {
    return false;
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);
      return document.createElement('div');
    }
    return selected;
  } else {
    return el;
  }
}

/*  */

function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm;
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setAttribute(node, key, val) {
  node.setAttribute(key, val);
}

var nodeOps = Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {
        refs[key].push(ref);
      } else {
        refs[key] = [ref];
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *

/*
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function isUndef(s) {
  return s == null;
}

function isDef(s) {
  return s != null;
}

function sameVnode(vnode1, vnode2) {
  return vnode1.key === vnode2.key && vnode1.tag === vnode2.tag && vnode1.isComment === vnode2.isComment && !vnode1.data === !vnode2.data;
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) {
      map[key] = i;
    }
  }
  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (modules[j][hooks[i]] !== undefined) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (parent) {
      nodeOps.removeChild(parent, el);
    }
  }

  var inPre = 0;
  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (process.env.NODE_ENV !== 'production') {
        if (data && data.pre) {
          inPre++;
        }
        if (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }
      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
        inPre--;
      }
    } else if (vnode.isComment) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isReactivated) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (vnode.data.pendingInsert) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break;
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref) {
    if (parent) {
      if (ref) {
        nodeOps.insertBefore(parent, elm, ref);
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (i.create) {
        i.create(emptyNode, vnode);
      }
      if (i.insert) {
        insertedVnodeQueue.push(vnode);
      }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope(vnode) {
    var i;
    var ancestor = vnode;
    while (ancestor) {
      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
        nodeOps.setAttribute(vnode.elm, i, '');
      }
      ancestor = ancestor.parent;
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }
      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (rm || isDef(vnode.data)) {
      var listeners = cbs.remove.length + 1;
      if (!rm) {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      } else {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, elmToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          elmToMove = oldCh[idxInOld];
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !elmToMove) {
            warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');
          }
          if (sameVnode(elmToMove, newStartVnode)) {
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          }
        }
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }
    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (vnode.isStatic && oldVnode.isStatic && vnode.key === oldVnode.key && (vnode.isCloned || vnode.isOnce)) {
      vnode.elm = oldVnode.elm;
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }
    var i;
    var data = vnode.data;
    var hasData = isDef(data);
    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }
    var elm = vnode.elm = oldVnode.elm;
    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (hasData && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }
      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (hasData) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (initial && vnode.parent) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var bailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate(elm, vnode, insertedVnodeQueue) {
    if (process.env.NODE_ENV !== 'production') {
      if (!assertNodeMatch(elm, vnode)) {
        return false;
      }
    }
    vnode.elm = elm;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true /* hydrating */);
      }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          var childrenMatch = true;
          var childNode = elm.firstChild;
          for (var i$1 = 0; i$1 < children.length; i$1++) {
            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
              childrenMatch = false;
              break;
            }
            childNode = childNode.nextSibling;
          }
          // if childNode is not null, it means the actual childNodes list is
          // longer than the virtual children list.
          if (!childrenMatch || childNode) {
            if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !bailed) {
              bailed = true;
              console.warn('Parent: ', elm);
              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
            }
            return false;
          }
        }
      }
      if (isDef(data)) {
        for (var key in data) {
          if (!isRenderedModule(key)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true;
  }

  function assertNodeMatch(node, vnode) {
    if (vnode.tag) {
      return vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (!vnode) {
      if (oldVnode) {
        invokeDestroyHook(oldVnode);
      }
      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (!oldVnode) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
            oldVnode.removeAttribute('server-rendered');
            hydrating = true;
          }
          if (hydrating) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (process.env.NODE_ENV !== 'production') {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }
        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);
        createElm(vnode, insertedVnodeQueue,
        // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));

        if (vnode.parent) {
          // component root element replaced.
          // update parent placeholder node element, recursively
          var ancestor = vnode.parent;
          while (ancestor) {
            ancestor.elm = vnode.elm;
            ancestor = ancestor.parent;
          }
          if (isPatchable(vnode)) {
            for (var i = 0; i < cbs.create.length; ++i) {
              cbs.create[i](emptyNode, vnode.parent);
            }
          }
        }

        if (parentElm$1 !== null) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function callInsert() {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);
  if (!dirs) {
    return res;
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
  }
}

var baseModules = [ref, directives];

/*  */

function updateAttrs(oldVnode, vnode) {
  if (!oldVnode.data.attrs && !vnode.data.attrs) {
    return;
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (attrs.__ob__) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  /* istanbul ignore if */
  if (isIE9 && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (attrs[key] == null) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, key);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, value);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (!data.staticClass && !data.class && (!oldData || !oldData.staticClass && !oldData.class)) {
    return;
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (transitionClass) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters(exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) {
        inSingle = false;
      }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) {
        inDouble = false;
      }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) {
        inTemplateString = false;
      }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) {
        inRegex = false;
      }
    } else if (c === 0x7C && // pipe
    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;break; // "
        case 0x27:
          inSingle = true;break; // '
        case 0x60:
          inTemplateString = true;break; // `
        case 0x28:
          paren++;break; // (
        case 0x29:
          paren--;break; // )
        case 0x5B:
          square++;break; // [
        case 0x5D:
          square--;break; // ]
        case 0x7B:
          curly++;break; // {
        case 0x7D:
          curly--;break; // }
      }
      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0;
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') {
            break;
          }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression;
}

function wrapFilter(exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return "_f(\"" + filter + "\")(" + exp + ")";
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return "_f(\"" + name + "\")(" + exp + "," + args;
  }
}

/*  */

function baseWarn(msg) {
  console.error("[Vue compiler]: " + msg);
}

function pluckModuleFunction(modules, key) {
  return modules ? modules.map(function (m) {
    return m[key];
  }).filter(function (_) {
    return _;
  }) : [];
}

function addProp(el, name, value) {
  (el.props || (el.props = [])).push({ name: name, value: value });
}

function addAttr(el, name, value) {
  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
}

function addDirective(el, name, rawName, value, arg, modifiers) {
  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
}

function addHandler(el, name, value, modifiers, important) {
  // check capture modifier
  if (modifiers && modifiers.capture) {
    delete modifiers.capture;
    name = '!' + name; // mark the event as captured
  }
  if (modifiers && modifiers.once) {
    delete modifiers.once;
    name = '~' + name; // mark the event as once
  }
  var events;
  if (modifiers && modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }
  var newHandler = { value: value, modifiers: modifiers };
  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }
}

function getBindingAttr(el, name, getStatic) {
  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue);
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue);
    }
  }
}

function getAndRemoveAttr(el, name) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break;
      }
    }
  }
  return val;
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel(el, value, modifiers) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: "(" + value + ")",
    expression: "\"" + value + "\"",
    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode(value, assignment) {
  var modelRs = parseModel(value);
  if (modelRs.idx === null) {
    return value + "=" + assignment;
  } else {
    return "var $$exp = " + modelRs.exp + ", $$idx = " + modelRs.idx + ";" + "if (!Array.isArray($$exp)){" + value + "=" + assignment + "}" + "else{$$exp.splice($$idx, 1, " + assignment + ")}";
  }
}

/**
 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
 *
 * for loop possible cases:
 *
 * - test
 * - test[idx]
 * - test[test1[idx]]
 * - test["a"][idx]
 * - xxx.test[a[a].test1[idx]]
 * - test.xxx.a["asa"][test1[idx]]
 *
 */

var len;
var str;
var chr;
var index$1;
var expressionPos;
var expressionEndPos;

function parseModel(val) {
  str = val;
  len = str.length;
  index$1 = expressionPos = expressionEndPos = 0;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    return {
      exp: val,
      idx: null
    };
  }

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.substring(0, expressionPos),
    idx: val.substring(expressionPos + 1, expressionEndPos)
  };
}

function next() {
  return str.charCodeAt(++index$1);
}

function eof() {
  return index$1 >= len;
}

function isStringStart(chr) {
  return chr === 0x22 || chr === 0x27;
}

function parseBracket(chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue;
    }
    if (chr === 0x5B) {
      inBracket++;
    }
    if (chr === 0x5D) {
      inBracket--;
    }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break;
    }
  }
}

function parseString(chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break;
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model(el, dir, _warn) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (process.env.NODE_ENV !== 'production') {
    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
    if (tag === 'input' && dynamicType) {
      warn$1("<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" + "v-model does not support dynamic input types. Use v-if branches instead.");
    }
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.");
    }
  }

  if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false;
  } else if (process.env.NODE_ENV !== 'production') {
    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');
  }

  // ensure runtime directive metadata
  return true;
}

function genCheckboxModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
  addHandler(el, CHECKBOX_RADIO_TOKEN, "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$c){$$i<0&&(" + value + "=$$a.concat($$v))}" + "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" + "}else{" + value + "=$$c}", null, true);
}

function genRadioModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);
}

function genSelect(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + genAssignmentCode(value, assignment);
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel(el, value, modifiers) {
  var type = el.attrsMap.type;
  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', "(" + value + ")");
  addHandler(el, event, code, null, true);
  if (trim || number || type === 'number') {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents(on) {
  var event;
  /* istanbul ignore if */
  if (on[RANGE_TOKEN]) {
    // IE input[type=range] only supports `change` event
    event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  if (on[CHECKBOX_RADIO_TOKEN]) {
    // Chrome fires microtasks in between click/change, leads to #4521
    event = isChrome ? 'click' : 'change';
    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function add$1(event, _handler, once, capture) {
  if (once) {
    var oldHandler = _handler;
    var _target = target$1; // save current target element in closure
    _handler = function handler(ev) {
      var res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, _handler, capture, _target);
      }
    };
  }
  target$1.addEventListener(event, _handler, capture);
}

function remove$2(event, handler, capture, _target) {
  (_target || target$1).removeEventListener(event, handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (!oldVnode.data.on && !vnode.data.on) {
    return;
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

function updateDOMProps(oldVnode, vnode) {
  if (!oldVnode.data.domProps && !vnode.data.domProps) {
    return;
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (props.__ob__) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (props[key] == null) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }
      if (cur === oldProps[key]) {
        continue;
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = cur == null ? '' : String(cur);
      if (shouldUpdateValue(elm, vnode, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, vnode, checkVal) {
  return !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));
}

function isDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value
  return document.activeElement !== elm && elm.value !== checkVal;
}

function isInputChanged(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (modifiers && modifiers.number || elm.type === 'number') {
    return toNumber(value) !== toNumber(newVal);
  }
  if (modifiers && modifiers.trim) {
    return value.trim() !== newVal.trim();
  }
  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle ? extend(data.staticStyle, style) : style;
}

// normalize possible array / string values into Object
function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }
  return bindingStyle;
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res;
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function setProp(el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    el.style[normalize(name)] = val;
  }
};

var prefixes = ['Webkit', 'Moz', 'ms'];

var testEl;
var normalize = cached(function (prop) {
  testEl = testEl || document.createElement('div');
  prop = camelize(prop);
  if (prop !== 'filter' && prop in testEl.style) {
    return prop;
  }
  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < prefixes.length; i++) {
    var prefixed = prefixes[i] + upper;
    if (prefixed in testEl.style) {
      return prefixed;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (!data.staticStyle && !data.style && !oldData.staticStyle && !oldData.style) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldVnode.data.staticStyle;
  var oldStyleBinding = oldVnode.data.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  vnode.data.style = style.__ob__ ? extend({}, style) : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (newStyle[name] == null) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    el.setAttribute('class', cur.trim());
  }
}

/*  */

function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */
  if ((typeof def$$1 === 'undefined' ? 'undefined' : _typeof(def$$1)) === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  (el._transitionClasses || (el._transitionClasses = [])).push(cls);
  addClass(el, cls);
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) {
    return cb();
  }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function end() {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function onEnd(e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
}

function toMs(s) {
  return Number(s.slice(0, -1)) * 1000;
}

/*  */

function enter(vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (el._leaveCb) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (!data) {
    return;
  }

  /* istanbul ignore if */
  if (el._enterCb || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;

  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;

  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      addTransitionClass(el, toClass);
      removeTransitionClass(el, startClass);
      if (!cb.cancelled && !userWantsControl) {
        if (isValidDuration(explicitEnterDuration)) {
          setTimeout(cb, explicitEnterDuration);
        } else {
          whenTransitionEnds(el, type, cb);
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (el._enterCb) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (!data) {
    return rm();
  }

  /* istanbul ignore if */
  if (el._leaveCb || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if (process.env.NODE_ENV !== 'production' && explicitLeaveDuration != null) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        addTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitLeaveDuration)) {
            setTimeout(cb, explicitLeaveDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength(fn) {
  if (!fn) {
    return false;
  }
  var invokerFns = fn.fns;
  if (invokerFns) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (!vnode.data.show) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (!vnode.data.show) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [attrs, klass, events, domProps, style, transition];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var model$1 = {
  inserted: function inserted(el, binding, vnode) {
    if (vnode.tag === 'select') {
      var cb = function cb() {
        setSelected(el, binding, vnode.context);
      };
      cb();
      /* istanbul ignore if */
      if (isIE || isEdge) {
        setTimeout(cb, 0);
      }
    } else if (vnode.tag === 'textarea' || el.type === 'text') {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        if (!isAndroid) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
        }
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var needReset = el.multiple ? binding.value.some(function (v) {
        return hasNoMatchingOption(v, el.options);
      }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
      if (needReset) {
        trigger(el, 'change');
      }
    }
  }
};

function setSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    process.env.NODE_ENV !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return;
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  for (var i = 0, l = options.length; i < l; i++) {
    if (looseEqual(getValue(options[i]), value)) {
      return false;
    }
  }
  return true;
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
    if (value && transition && !isIE9) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (value === oldValue) {
      return;
    }
    vnode = locateNode(vnode);
    var transition = vnode.data && vnode.data.transition;
    if (transition && !isIE9) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: model$1,
  show: show
};

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data;
}

function placeholder(h, rawChild) {
  return (/\d-keep-alive$/.test(rawChild.tag) ? h('keep-alive') : null
  );
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render(h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return;
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) {
      return c.tag;
    });
    /* istanbul ignore if */
    if (!children.length) {
      return;
    }

    // warn multiple elements
    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode;

    // warn invalid mode
    if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) {
      return d.name === 'show';
    })) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        var delayedLeave;
        var performLeave = function performLeave() {
          delayedLeave();
        };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
        } else if (process.env.NODE_ENV !== 'production') {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },

  beforeUpdate: function beforeUpdate() {
    // force removing pass
    this.__patch__(this._vnode, this.kept, false, // hydrating
    true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    var body = document.body;
    var f = body.offsetHeight; // eslint-disable-line

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      if (this._hasMove != null) {
        return this._hasMove;
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue$3.options.directives, platformDirectives);
extend(Vue$3.options.components, platformComponents);

// install platform patch function
Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue$3.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
};

// devtools global hook
/* istanbul ignore next */
setTimeout(function () {
  if (config.devtools) {
    if (devtools) {
      devtools.emit('init', Vue$3);
    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
    }
  }
  if (process.env.NODE_ENV !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {
    console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
  }
}, 0);

/*  */

// check whether current browser encodes a char inside attribute values
function shouldDecode(content, encoded) {
  var div = document.createElement('div');
  div.innerHTML = "<div a=\"" + content + "\">";
  return div.innerHTML.indexOf(encoded) > 0;
}

// #3663
// IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;

/*  */

var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');

/*  */

var decoder;

function decode(html) {
  decoder = decoder || document.createElement('div');
  decoder.innerHTML = html;
  return decoder.textContent;
}

/**
 * Not type-checking this file because it's mostly vendor code.
 */

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */

// Regular Expressions for parsing tags and attributes
var singleAttrIdentifier = /([^\s"'<>/=]+)/;
var singleAttrAssign = /(?:=)/;
var singleAttrValues = [
// attr value double quotes
/"([^"]*)"+/.source,
// attr value, single quotes
/'([^']*)'+/.source,
// attr value, no quotes
/([^\s"'=<>`]+)/.source];
var attribute = new RegExp('^\\s*' + singleAttrIdentifier.source + '(?:\\s*(' + singleAttrAssign.source + ')' + '\\s*(?:' + singleAttrValues.join('|') + '))?');

// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
// but for Vue templates we can enforce a simple charset
var ncname = '[a-zA-Z_][\\w\\-\\.]*';
var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
var startTagOpen = new RegExp('^<' + qnameCapture);
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
var doctype = /^<!DOCTYPE [^>]+>/i;
var comment = /^<!--/;
var conditionalComment = /^<!\[/;

var IS_REGEX_CAPTURING_BROKEN = false;
'x'.replace(/x(.)?/g, function (m, g) {
  IS_REGEX_CAPTURING_BROKEN = g === '';
});

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n'
};
var encodedAttr = /&(?:lt|gt|quot|amp);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;

function decodeAttr(value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) {
    return decodingMap[match];
  });
}

function parseHTML(html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            advance(commentEnd + 3);
            continue;
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue;
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue;
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue;
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          continue;
        }
      }

      var text = void 0,
          rest$1 = void 0,
          next = void 0;
      if (textEnd >= 0) {
        rest$1 = html.slice(textEnd);
        while (!endTag.test(rest$1) && !startTagOpen.test(rest$1) && !comment.test(rest$1) && !conditionalComment.test(rest$1)) {
          // < in plain text, be forgiving and treat it as text
          next = rest$1.indexOf('<', 1);
          if (next < 0) {
            break;
          }
          textEnd += next;
          rest$1 = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
        advance(textEnd);
      }

      if (textEnd < 0) {
        text = html;
        html = '';
      }

      if (options.chars && text) {
        options.chars(text);
      }
    } else {
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var endTagLength = 0;
      var rest = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text.replace(/<!--([\s\S]*?)-->/g, '$1').replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (options.chars) {
          options.chars(text);
        }
        return '';
      });
      index += html.length - rest.length;
      html = rest;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {
        options.warn("Mal-formatted tag at end of template: \"" + html + "\"");
      }
      break;
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance(n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag() {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
        advance(attr[0].length);
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match;
      }
    }
  }

  function handleStartTag(match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
        if (args[3] === '') {
          delete args[3];
        }
        if (args[4] === '') {
          delete args[4];
        }
        if (args[5] === '') {
          delete args[5];
        }
      }
      var value = args[3] || args[4] || args[5] || '';
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, options.shouldDecodeNewlines)
      };
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag(tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) {
      start = index;
    }
    if (end == null) {
      end = index;
    }

    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
    }

    // Find the closest opened tag of the same type
    if (tagName) {
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break;
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if (process.env.NODE_ENV !== 'production' && (i > pos || !tagName) && options.warn) {
          options.warn("tag <" + stack[i].tag + "> has no matching end tag.");
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});

function parseText(text, delimiters) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return;
  }
  var tokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index;
  while (match = tagRE.exec(text)) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push("_s(" + exp + ")");
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    tokens.push(JSON.stringify(text.slice(lastIndex)));
  }
  return tokens.join('+');
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;

var argRE = /:(.*)$/;
var bindRE = /^:|^v-bind:/;
var modifierRE = /\.[^.]+/g;

var decodeHTMLCached = cached(decode);

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;

/**
 * Convert HTML string to AST.
 */
function parse(template, options) {
  warn$2 = options.warn || baseWarn;
  platformGetTagNamespace = options.getTagNamespace || no;
  platformMustUseProp = options.mustUseProp || no;
  platformIsPreTag = options.isPreTag || no;
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  transforms = pluckModuleFunction(options.modules, 'transformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce(msg) {
    if (!warned) {
      warned = true;
      warn$2(msg);
    }
  }

  function endPre(element) {
    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    start: function start(tag, attrs, unary) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = {
        type: 1,
        tag: tag,
        attrsList: attrs,
        attrsMap: makeAttrsMap(attrs),
        parent: currentParent,
        children: []
      };
      if (ns) {
        element.ns = ns;
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        process.env.NODE_ENV !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.');
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        preTransforms[i](element, options);
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else {
        processFor(element);
        processIf(element);
        processOnce(element);
        processKey(element);

        // determine whether this is a plain element after
        // removing structural attributes
        element.plain = !element.key && !attrs.length;

        processRef(element);
        processSlot(element);
        processComponent(element);
        for (var i$1 = 0; i$1 < transforms.length; i$1++) {
          transforms[i$1](element, options);
        }
        processAttrs(element);
      }

      function checkRootConstraints(el) {
        if (process.env.NODE_ENV !== 'production') {
          if (el.tag === 'slot' || el.tag === 'template') {
            warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.');
          }
          if (el.attrsMap.hasOwnProperty('v-for')) {
            warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');
          }
        }
      }

      // tree management
      if (!root) {
        root = element;
        checkRootConstraints(root);
      } else if (!stack.length) {
        // allow root elements with v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          checkRootConstraints(element);
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          });
        } else if (process.env.NODE_ENV !== 'production') {
          warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.");
        }
      }
      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent);
        } else if (element.slotScope) {
          // scoped slot
          currentParent.plain = false;
          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        } else {
          currentParent.children.push(element);
          element.parent = currentParent;
        }
      }
      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        endPre(element);
      }
      // apply post-transforms
      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
        postTransforms[i$2](element, options);
      }
    },

    end: function end() {
      // remove trailing whitespace
      var element = stack[stack.length - 1];
      var lastNode = element.children[element.children.length - 1];
      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
        element.children.pop();
      }
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      endPre(element);
    },

    chars: function chars(text) {
      if (!currentParent) {
        if (process.env.NODE_ENV !== 'production') {
          if (text === template) {
            warnOnce('Component template requires a root element, rather than just text.');
          } else if (text = text.trim()) {
            warnOnce("text \"" + text + "\" outside root element will be ignored.");
          }
        }
        return;
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
        return;
      }
      var children = currentParent.children;
      text = inPre || text.trim() ? decodeHTMLCached(text)
      // only preserve whitespace if its not right after a starting tag
      : preserveWhitespace && children.length ? ' ' : '';
      if (text) {
        var expression;
        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
          children.push({
            type: 2,
            expression: expression,
            text: text
          });
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          children.push({
            type: 3,
            text: text
          });
        }
      }
    }
  });
  return root;
}

function processPre(el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs(el) {
  var l = el.attrsList.length;
  if (l) {
    var attrs = el.attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      attrs[i] = {
        name: el.attrsList[i].name,
        value: JSON.stringify(el.attrsList[i].value)
      };
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processKey(el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {
      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
    }
    el.key = exp;
  }
}

function processRef(el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor(el) {
  var exp;
  if (exp = getAndRemoveAttr(el, 'v-for')) {
    var inMatch = exp.match(forAliasRE);
    if (!inMatch) {
      process.env.NODE_ENV !== 'production' && warn$2("Invalid v-for expression: " + exp);
      return;
    }
    el.for = inMatch[2].trim();
    var alias = inMatch[1].trim();
    var iteratorMatch = alias.match(forIteratorRE);
    if (iteratorMatch) {
      el.alias = iteratorMatch[1].trim();
      el.iterator1 = iteratorMatch[2].trim();
      if (iteratorMatch[3]) {
        el.iterator2 = iteratorMatch[3].trim();
      }
    } else {
      el.alias = alias;
    }
  }
}

function processIf(el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions(el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (process.env.NODE_ENV !== 'production') {
    warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.");
  }
}

function findPrevElement(children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i];
    } else {
      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {
        warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.");
      }
      children.pop();
    }
  }
}

function addIfCondition(el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce(el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

function processSlot(el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if (process.env.NODE_ENV !== 'production' && el.key) {
      warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.");
    }
  } else {
    var slotTarget = getBindingAttr(el, 'slot');
    if (slotTarget) {
      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    }
    if (el.tag === 'template') {
      el.slotScope = getAndRemoveAttr(el, 'scope');
    }
  }
}

function processComponent(el) {
  var binding;
  if (binding = getBindingAttr(el, 'is')) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs(el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, isProp;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name);
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) {
        // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isProp = false;
        if (modifiers) {
          if (modifiers.prop) {
            isProp = true;
            name = camelize(name);
            if (name === 'innerHtml') {
              name = 'innerHTML';
            }
          }
          if (modifiers.camel) {
            name = camelize(name);
          }
        }
        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, value);
        } else {
          addAttr(el, name, value);
        }
      } else if (onRE.test(name)) {
        // v-on
        name = name.replace(onRE, '');
        addHandler(el, name, value, modifiers);
      } else {
        // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
        }
        addDirective(el, name, rawName, value, arg, modifiers);
        if (process.env.NODE_ENV !== 'production' && name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (process.env.NODE_ENV !== 'production') {
        var expression = parseText(value, delimiters);
        if (expression) {
          warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.');
        }
      }
      addAttr(el, name, JSON.stringify(value));
    }
  }
}

function checkInFor(el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true;
    }
    parent = parent.parent;
  }
  return false;
}

function parseModifiers(name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) {
      ret[m.slice(1)] = true;
    });
    return ret;
  }
}

function makeAttrsMap(attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE) {
      warn$2('duplicate attribute: ' + attrs[i].name);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map;
}

function isForbiddenTag(el) {
  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug(attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res;
}

function checkForAliasModel(el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.");
    }
    _el = _el.parent;
  }
}

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize(root, options) {
  if (!root) {
    return;
  }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1(keys) {
  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));
}

function markStatic$1(node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
      return;
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
  }
}

function markStaticRoots(node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
      node.staticRoot = true;
      return;
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      walkThroughConditionsBlocks(node.ifConditions, isInFor);
    }
  }
}

function walkThroughConditionsBlocks(conditionBlocks, isInFor) {
  for (var i = 1, len = conditionBlocks.length; i < len; i++) {
    markStaticRoots(conditionBlocks[i].block, isInFor);
  }
}

function isStatic(node) {
  if (node.type === 2) {
    // expression
    return false;
  }
  if (node.type === 3) {
    // text
    return true;
  }
  return !!(node.pre || !node.hasBindings && // no dynamic bindings
  !node.if && !node.for && // not v-if or v-for or v-else
  !isBuiltInTag(node.tag) && // not a built-in
  isPlatformReservedTag(node.tag) && // not a component
  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
}

function isDirectChildOfTemplateFor(node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false;
    }
    if (node.for) {
      return true;
    }
  }
  return false;
}

/*  */

var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

// keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function genGuard(condition) {
  return "if(" + condition + ")return null;";
};

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers(events, native) {
  var res = native ? 'nativeOn:{' : 'on:{';
  for (var name in events) {
    res += "\"" + name + "\":" + genHandler(name, events[name]) + ",";
  }
  return res.slice(0, -1) + '}';
}

function genHandler(name, handler) {
  if (!handler) {
    return 'function(){}';
  }

  if (Array.isArray(handler)) {
    return "[" + handler.map(function (handler) {
      return genHandler(name, handler);
    }).join(',') + "]";
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);

  if (!handler.modifiers) {
    return isMethodPath || isFunctionExpression ? handler.value : "function($event){" + handler.value + "}"; // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? "(" + handler.value + ")($event)" : handler.value;
    return "function($event){" + code + handlerCode + "}";
  }
}

function genKeyFilter(keys) {
  return "if(!('button' in $event)&&" + keys.map(genFilterCode).join('&&') + ")return null;";
}

function genFilterCode(key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return "$event.keyCode!==" + keyVal;
  }
  var alias = keyCodes[key];
  return "_k($event.keyCode," + JSON.stringify(key) + (alias ? ',' + JSON.stringify(alias) : '') + ")";
}

/*  */

function bind$1(el, dir) {
  el.wrapData = function (code) {
    return "_b(" + code + ",'" + el.tag + "'," + dir.value + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + ")";
  };
}

/*  */

var baseDirectives = {
  bind: bind$1,
  cloak: noop
};

/*  */

// configurable state
var warn$3;
var transforms$1;
var dataGenFns;
var platformDirectives$1;
var isPlatformReservedTag$1;
var staticRenderFns;
var onceCount;
var currentOptions;

function generate(ast, options) {
  // save previous staticRenderFns so generate calls can be nested
  var prevStaticRenderFns = staticRenderFns;
  var currentStaticRenderFns = staticRenderFns = [];
  var prevOnceCount = onceCount;
  onceCount = 0;
  currentOptions = options;
  warn$3 = options.warn || baseWarn;
  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');
  dataGenFns = pluckModuleFunction(options.modules, 'genData');
  platformDirectives$1 = options.directives || {};
  isPlatformReservedTag$1 = options.isReservedTag || no;
  var code = ast ? genElement(ast) : '_c("div")';
  staticRenderFns = prevStaticRenderFns;
  onceCount = prevOnceCount;
  return {
    render: "with(this){return " + code + "}",
    staticRenderFns: currentStaticRenderFns
  };
}

function genElement(el) {
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el);
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el);
  } else if (el.for && !el.forProcessed) {
    return genFor(el);
  } else if (el.if && !el.ifProcessed) {
    return genIf(el);
  } else if (el.tag === 'template' && !el.slotTarget) {
    return genChildren(el) || 'void 0';
  } else if (el.tag === 'slot') {
    return genSlot(el);
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el);
    } else {
      var data = el.plain ? undefined : genData(el);

      var children = el.inlineTemplate ? null : genChildren(el, true);
      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
    }
    // module transforms
    for (var i = 0; i < transforms$1.length; i++) {
      code = transforms$1[i](el, code);
    }
    return code;
  }
}

// hoist static sub-trees out
function genStatic(el) {
  el.staticProcessed = true;
  staticRenderFns.push("with(this){return " + genElement(el) + "}");
  return "_m(" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
}

// v-once
function genOnce(el) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el);
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break;
      }
      parent = parent.parent;
    }
    if (!key) {
      process.env.NODE_ENV !== 'production' && warn$3("v-once can only be used inside v-for that is keyed. ");
      return genElement(el);
    }
    return "_o(" + genElement(el) + "," + onceCount++ + (key ? "," + key : "") + ")";
  } else {
    return genStatic(el);
  }
}

function genIf(el) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice());
}

function genIfConditions(conditions) {
  if (!conditions.length) {
    return '_e()';
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions);
  } else {
    return "" + genTernaryExp(condition.block);
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp(el) {
    return el.once ? genOnce(el) : genElement(el);
  }
}

function genFor(el) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

  if (process.env.NODE_ENV !== 'production' && maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
    warn$3("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return "_l((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + genElement(el) + '})';
}

function genData(el) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el);
  if (dirs) {
    data += dirs + ',';
  }

  // key
  if (el.key) {
    data += "key:" + el.key + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + el.ref + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + el.tag + "\",";
  }
  // module data generation functions
  for (var i = 0; i < dataGenFns.length; i++) {
    data += dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:{" + genProps(el.attrs) + "},";
  }
  // DOM props
  if (el.props) {
    data += "domProps:{" + genProps(el.props) + "},";
  }
  // event handlers
  if (el.events) {
    data += genHandlers(el.events) + ",";
  }
  if (el.nativeEvents) {
    data += genHandlers(el.nativeEvents, true) + ",";
  }
  // slot target
  if (el.slotTarget) {
    data += "slot:" + el.slotTarget + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += genScopedSlots(el.scopedSlots) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  return data;
}

function genDirectives(el) {
  var dirs = el.directives;
  if (!dirs) {
    return;
  }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, warn$3);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:\"" + dir.arg + "\"" : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']';
  }
}

function genInlineTemplate(el) {
  var ast = el.children[0];
  if (process.env.NODE_ENV !== 'production' && (el.children.length > 1 || ast.type !== 1)) {
    warn$3('Inline-template components must have exactly one child element.');
  }
  if (ast.type === 1) {
    var inlineRenderFns = generate(ast, currentOptions);
    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
      return "function(){" + code + "}";
    }).join(',') + "]}";
  }
}

function genScopedSlots(slots) {
  return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
    return genScopedSlot(key, slots[key]);
  }).join(',') + "])";
}

function genScopedSlot(key, el) {
  return "[" + key + ",function(" + String(el.attrsMap.scope) + "){" + "return " + (el.tag === 'template' ? genChildren(el) || 'void 0' : genElement(el)) + "}]";
}

function genChildren(el, checkSkip) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
      return genElement(el$1);
    }
    var normalizationType = checkSkip ? getNormalizationType(children) : 0;
    return "[" + children.map(genNode).join(',') + "]" + (normalizationType ? "," + normalizationType : '');
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType(children) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue;
    }
    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return needsNormalization(c.block);
    })) {
      res = 2;
      break;
    }
    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return maybeComponent(c.block);
    })) {
      res = 1;
    }
  }
  return res;
}

function needsNormalization(el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}

function maybeComponent(el) {
  return !isPlatformReservedTag$1(el.tag);
}

function genNode(node) {
  if (node.type === 1) {
    return genElement(node);
  } else {
    return genText(node);
  }
}

function genText(text) {
  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
}

function genSlot(el) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el);
  var res = "_t(" + slotName + (children ? "," + children : '');
  var attrs = el.attrs && "{" + el.attrs.map(function (a) {
    return camelize(a.name) + ":" + a.value;
  }).join(',') + "}";
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')';
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent(componentName, el) {
  var children = el.inlineTemplate ? null : genChildren(el, true);
  return "_c(" + componentName + "," + genData(el) + (children ? "," + children : '') + ")";
}

function genProps(props) {
  var res = '';
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    res += "\"" + prop.name + "\":" + transformSpecialNewlines(prop.value) + ",";
  }
  return res.slice(0, -1);
}

// #3895, #4268
function transformSpecialNewlines(text) {
  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}

/*  */

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// check valid identifier for v-for
var identRE = /[A-Za-z_$][\w$]*/;

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors(ast) {
  var errors = [];
  if (ast) {
    checkNode(ast, errors);
  }
  return errors;
}

function checkNode(node, errors) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          if (name === 'v-for') {
            checkFor(node, "v-for=\"" + value + "\"", errors);
          } else if (onRE.test(name)) {
            checkEvent(value, name + "=\"" + value + "\"", errors);
          } else {
            checkExpression(value, name + "=\"" + value + "\"", errors);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], errors);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, errors);
  }
}

function checkEvent(exp, text, errors) {
  var keywordMatch = exp.replace(stripStringRE, '').match(unaryOperatorsRE);
  if (keywordMatch) {
    errors.push("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
  }
  checkExpression(exp, text, errors);
}

function checkFor(node, text, errors) {
  checkExpression(node.for || '', text, errors);
  checkIdentifier(node.alias, 'v-for alias', text, errors);
  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
}

function checkIdentifier(ident, type, text, errors) {
  if (typeof ident === 'string' && !identRE.test(ident)) {
    errors.push("invalid " + type + " \"" + ident + "\" in expression: " + text.trim());
  }
}

function checkExpression(exp, text, errors) {
  try {
    new Function("return " + exp);
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      errors.push("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
    } else {
      errors.push("invalid expression: " + text.trim());
    }
  }
}

/*  */

function baseCompile(template, options) {
  var ast = parse(template.trim(), options);
  optimize(ast, options);
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  };
}

function makeFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop;
  }
}

function createCompiler(baseOptions) {
  var functionCompileCache = Object.create(null);

  function compile(template, options) {
    var finalOptions = Object.create(baseOptions);
    var errors = [];
    var tips = [];
    finalOptions.warn = function (msg, tip$$1) {
      (tip$$1 ? tips : errors).push(msg);
    };

    if (options) {
      // merge custom modules
      if (options.modules) {
        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
      }
      // merge custom directives
      if (options.directives) {
        finalOptions.directives = extend(Object.create(baseOptions.directives), options.directives);
      }
      // copy other options
      for (var key in options) {
        if (key !== 'modules' && key !== 'directives') {
          finalOptions[key] = options[key];
        }
      }
    }

    var compiled = baseCompile(template, finalOptions);
    if (process.env.NODE_ENV !== 'production') {
      errors.push.apply(errors, detectErrors(compiled.ast));
    }
    compiled.errors = errors;
    compiled.tips = tips;
    return compiled;
  }

  function compileToFunctions(template, options, vm) {
    options = options || {};

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
        }
      }
    }

    // check cache
    var key = options.delimiters ? String(options.delimiters) + template : template;
    if (functionCompileCache[key]) {
      return functionCompileCache[key];
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    if (process.env.NODE_ENV !== 'production') {
      if (compiled.errors && compiled.errors.length) {
        warn("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
          return "- " + e;
        }).join('\n') + '\n', vm);
      }
      if (compiled.tips && compiled.tips.length) {
        compiled.tips.forEach(function (msg) {
          return tip(msg, vm);
        });
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = makeFunction(compiled.render, fnGenErrors);
    var l = compiled.staticRenderFns.length;
    res.staticRenderFns = new Array(l);
    for (var i = 0; i < l; i++) {
      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);
    }

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
          var err = ref.err;
          var code = ref.code;

          return err.toString() + " in\n\n" + code + "\n";
        }).join('\n'), vm);
      }
    }

    return functionCompileCache[key] = res;
  }

  return {
    compile: compile,
    compileToFunctions: compileToFunctions
  };
}

/*  */

function transformNode(el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if (process.env.NODE_ENV !== 'production' && staticClass) {
    var expression = parseText(staticClass, options.delimiters);
    if (expression) {
      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.');
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData$1(el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + el.staticClass + ",";
  }
  if (el.classBinding) {
    data += "class:" + el.classBinding + ",";
  }
  return data;
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData$1
};

/*  */

function transformNode$1(el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      var expression = parseText(staticStyle, options.delimiters);
      if (expression) {
        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.');
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$2(el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + el.staticStyle + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + el.styleBinding + "),";
  }
  return data;
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$2
};

var modules$1 = [klass$1, style$1];

/*  */

function text(el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', "_s(" + dir.value + ")");
  }
}

/*  */

function html(el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', "_s(" + dir.value + ")");
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

var ref$1 = createCompiler(baseOptions);
var compileToFunctions = ref$1.compileToFunctions;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML;
});

var mount = Vue$3.prototype.$mount;
Vue$3.prototype.$mount = function (el, hydrating) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
    return this;
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn("Template element not found or is empty: " + options.template, this);
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this);
        }
        return this;
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        shouldDecodeNewlines: shouldDecodeNewlines,
        delimiters: options.delimiters
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end');
        measure(this._name + " compile", 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating);
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML(el) {
  if (el.outerHTML) {
    return el.outerHTML;
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML;
  }
}

Vue$3.compile = compileToFunctions;

exports.default = Vue$3;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(9)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(3);

// Load library
H5P.Feedback = __webpack_require__(2).default;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(0)(
  /* script */
  __webpack_require__(4),
  /* template */
  __webpack_require__(15),
  /* scopeId */
  null,
  /* cssModules */
  null
)
Component.options.__file = "/home/tomaj/code/joubel/content-types/h5p-feedback/src/scripts/views/Final.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key !== "__esModule"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] Final.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-5c2bb111", Component.options)
  } else {
    hotAPI.reload("data-v-5c2bb111", Component.options)
  }
})()}

module.exports = Component.exports


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(0)(
  /* script */
  __webpack_require__(5),
  /* template */
  __webpack_require__(14),
  /* scopeId */
  null,
  /* cssModules */
  null
)
Component.options.__file = "/home/tomaj/code/joubel/content-types/h5p-feedback/src/scripts/views/ScoreInput.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key !== "__esModule"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] ScoreInput.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4903dccd", Component.options)
  } else {
    hotAPI.reload("data-v-4903dccd", Component.options)
  }
})()}

module.exports = Component.exports


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(0)(
  /* script */
  __webpack_require__(6),
  /* template */
  __webpack_require__(16),
  /* scopeId */
  null,
  /* cssModules */
  null
)
Component.options.__file = "/home/tomaj/code/joubel/content-types/h5p-feedback/src/scripts/views/TextInput.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key !== "__esModule"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] TextInput.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-6315a138", Component.options)
  } else {
    hotAPI.reload("data-v-6315a138", Component.options)
  }
})()}

module.exports = Component.exports


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "h5p-feedback-score",
    attrs: {
      "role": "region"
    }
  }, [_c('h3', {
    staticClass: "feedback-title",
    domProps: {
      "innerHTML": _vm._s(_vm.message)
    }
  }), _c('ul', {
    staticClass: "feedback-score-input"
  }, _vm._l((_vm.alternatives), function(alternative) {
    return _c('li', [_c('div', {
      class: alternative.cls,
      attrs: {
        "role": "button"
      },
      on: {
        "click": function($event) {
          _vm.sendScore(alternative)
        }
      }
    }, [_c('div', {
      staticClass: "feedback-score-title"
    }, [_vm._v(_vm._s(alternative.title))])])])
  }))])
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-4903dccd", module.exports)
  }
}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _vm._m(0)
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "h5p-feedback-final",
    attrs: {
      "role": "region"
    }
  }, [_c('p', [_vm._v("We put a lot of effort into making H5P easy to use for all!")]), _c('h2', [_vm._v("Your feedback is highly appreciated!")])])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-5c2bb111", module.exports)
  }
}

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "feedback-text-input",
    attrs: {
      "role": "region"
    }
  }, [_c('div', {
    staticClass: "from-score-input"
  }, [_c('span', {
    staticClass: "feedback-score",
    class: _vm.alternative.cls
  }), _c('span', {
    staticClass: "feedback-score-title"
  }, [_vm._v(_vm._s(this.alternative.title))]), _c('router-link', {
    attrs: {
      "to": "/score-input"
    }
  }, [_vm._v("Change")])], 1), _c('h2', [_vm._v("Thanks for the rating!")]), _vm._m(0), _c('textarea', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.text),
      expression: "text"
    }],
    attrs: {
      "rows": "4",
      "placeholder": "Your Feedback"
    },
    domProps: {
      "value": (_vm.text)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.text = $event.target.value
      }
    }
  }), _c('button', {
    staticClass: "button button-primary",
    attrs: {
      "disabled": _vm.text.length < 1
    },
    on: {
      "click": function($event) {
        _vm.sendText(_vm.text)
      }
    }
  }, [_vm._v("Send")])])
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('p', [_vm._v("Let us know how we can improve your experience with the "), _c('strong', [_vm._v("Drag Text")]), _vm._v(" authoring tool.")])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-6315a138", module.exports)
  }
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgN2E5YTcyYzc4NzNjZTY4YzU0NTAiLCJ3ZWJwYWNrOi8vLy4vfi92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9mZWVkYmFjay5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL21haW4uc2Nzcz8zN2ZjIiwid2VicGFjazovLy9GaW5hbC52dWUiLCJ3ZWJwYWNrOi8vL1Njb3JlSW5wdXQudnVlIiwid2VicGFjazovLy9UZXh0SW5wdXQudnVlIiwid2VicGFjazovLy8uL34vdnVlLXJvdXRlci9kaXN0L3Z1ZS1yb3V0ZXIuZXNtLmpzIiwid2VicGFjazovLy8uL34vdnVlL2Rpc3QvdnVlLmVzbS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL3NyYy9lbnRyaWVzL2Rpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvdmlld3MvRmluYWwudnVlIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3ZpZXdzL1Njb3JlSW5wdXQudnVlIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3ZpZXdzL1RleHRJbnB1dC52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvdmlld3MvU2NvcmVJbnB1dC52dWU/NTgxZiIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy92aWV3cy9GaW5hbC52dWU/MWU4MyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy92aWV3cy9UZXh0SW5wdXQudnVlPzVjNTciXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJlIiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImxlbmd0aCIsImNvbmNhdCIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwibGVuIiwicnVuIiwibmV4dFRpY2siLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJpIiwicHVzaCIsIkl0ZW0iLCJhcnJheSIsInByb3RvdHlwZSIsImFwcGx5IiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsImJpbmRpbmciLCJuYW1lIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayIsInVzZSIsIkZlZWRiYWNrIiwiY29uZmlnIiwiY29udGVudElkIiwiY29udGVudERhdGEiLCJhbHRlcm5hdGl2ZXMiLCJjbHMiLCJzY29yZSIsImRhdGEiLCJtZXNzYWdlIiwidGV4dCIsInJvdXRlciIsIm1vZGUiLCJyb3V0ZXMiLCJwYXRoIiwiY29tcG9uZW50IiwicHJvcHMiLCJyZWRpcmVjdCIsImJlZm9yZUVhY2giLCJ0byIsImZyb20iLCJuZXh0IiwidHJpZ2dlciIsInZpZXdNb2RlbCIsImF0dGFjaCIsImlkIiwiJHdyYXBwZXIiLCJnZXQiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVJvb3RFbGVtZW50IiwiJG1vdW50IiwiZWxlbWVudCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImlubmVySFRNTCIsIkg1UCIsIkV2ZW50RGlzcGF0Y2hlciIsImFzc2VydCIsImNvbmRpdGlvbiIsIndhcm4iLCJjb25zb2xlIiwiVmlldyIsImZ1bmN0aW9uYWwiLCJ0eXBlIiwiU3RyaW5nIiwiZGVmYXVsdCIsInJlbmRlciIsImgiLCJyZWYiLCJjaGlsZHJlbiIsInBhcmVudCIsInJvdXRlclZpZXciLCJyb3V0ZSIsIiRyb3V0ZSIsImNhY2hlIiwiX3JvdXRlclZpZXdDYWNoZSIsImRlcHRoIiwiaW5hY3RpdmUiLCIkdm5vZGUiLCJfaW5hY3RpdmUiLCIkcGFyZW50Iiwicm91dGVyVmlld0RlcHRoIiwibWF0Y2hlZCIsImNvbXBvbmVudHMiLCJob29rcyIsImhvb2siLCJpbml0Iiwidm5vZGUiLCJpbnN0YW5jZXMiLCJjaGlsZCIsInByZXBhdGNoIiwib2xkVm5vZGUiLCJkZXN0cm95IiwidW5kZWZpbmVkIiwicmVzb2x2ZVByb3BzIiwicGFyYW1zIiwiZW5jb2RlUmVzZXJ2ZVJFIiwiZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyIiwiYyIsImNoYXJDb2RlQXQiLCJ0b1N0cmluZyIsImNvbW1hUkUiLCJlbmNvZGUiLCJzdHIiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXBsYWNlIiwiZGVjb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicmVzb2x2ZVF1ZXJ5IiwicXVlcnkiLCJleHRyYVF1ZXJ5IiwicGFyc2VkUXVlcnkiLCJwYXJzZVF1ZXJ5IiwiTk9ERV9FTlYiLCJrZXkiLCJyZXMiLCJ0cmltIiwic3BsaXQiLCJmb3JFYWNoIiwicGFyYW0iLCJwYXJ0cyIsInNoaWZ0IiwidmFsIiwiam9pbiIsImlzQXJyYXkiLCJzdHJpbmdpZnlRdWVyeSIsIm9iaiIsIk9iamVjdCIsImtleXMiLCJtYXAiLCJyZXN1bHQiLCJzbGljZSIsInZhbDIiLCJmaWx0ZXIiLCJ4IiwidHJhaWxpbmdTbGFzaFJFIiwiY3JlYXRlUm91dGUiLCJyZWNvcmQiLCJsb2NhdGlvbiIsInJlZGlyZWN0ZWRGcm9tIiwibWV0YSIsImhhc2giLCJmdWxsUGF0aCIsImdldEZ1bGxQYXRoIiwiZm9ybWF0TWF0Y2giLCJmcmVlemUiLCJTVEFSVCIsInVuc2hpZnQiLCJpc1NhbWVSb3V0ZSIsImEiLCJiIiwiaXNPYmplY3RFcXVhbCIsImFLZXlzIiwiYktleXMiLCJldmVyeSIsImlzSW5jbHVkZWRSb3V0ZSIsImN1cnJlbnQiLCJ0YXJnZXQiLCJpbmRleE9mIiwicXVlcnlJbmNsdWRlcyIsInRvVHlwZXMiLCJldmVudFR5cGVzIiwiTGluayIsInJlcXVpcmVkIiwidGFnIiwiZXhhY3QiLCJCb29sZWFuIiwiYXBwZW5kIiwiYWN0aXZlQ2xhc3MiLCJldmVudCIsInRoaXMkMSIsIiRyb3V0ZXIiLCJyZXNvbHZlIiwiaHJlZiIsImNsYXNzZXMiLCJvcHRpb25zIiwibGlua0FjdGl2ZUNsYXNzIiwiY29tcGFyZVRhcmdldCIsImhhbmRsZXIiLCJndWFyZEV2ZW50IiwiY2xpY2siLCJjbGFzcyIsImF0dHJzIiwiZmluZEFuY2hvciIsIiRzbG90cyIsImlzU3RhdGljIiwiZXh0ZW5kIiwiX1Z1ZSIsInV0aWwiLCJhRGF0YSIsImFBdHRycyIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJkZWZhdWx0UHJldmVudGVkIiwiYnV0dG9uIiwiZ2V0QXR0cmlidXRlIiwidGVzdCIsInByZXZlbnREZWZhdWx0IiwiaW5zdGFsbCIsIlZ1ZSIsImluc3RhbGxlZCIsImRlZmluZVByb3BlcnR5IiwiJHJvb3QiLCJfcm91dGVyIiwiX3JvdXRlIiwibWl4aW4iLCJiZWZvcmVDcmVhdGUiLCIkb3B0aW9ucyIsImRlZmluZVJlYWN0aXZlIiwiaGlzdG9yeSIsInN0cmF0cyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsImJlZm9yZVJvdXRlRW50ZXIiLCJiZWZvcmVSb3V0ZUxlYXZlIiwiY3JlYXRlZCIsImluQnJvd3NlciIsIndpbmRvdyIsInJlc29sdmVQYXRoIiwicmVsYXRpdmUiLCJiYXNlIiwiY2hhckF0Iiwic3RhY2siLCJwb3AiLCJzZWdtZW50cyIsInNlZ21lbnQiLCJwYXJzZVBhdGgiLCJoYXNoSW5kZXgiLCJxdWVyeUluZGV4IiwiY2xlYW5QYXRoIiwiY3JlYXRlUm91dGVNYXAiLCJvbGRQYXRoTWFwIiwib2xkTmFtZU1hcCIsInBhdGhNYXAiLCJjcmVhdGUiLCJuYW1lTWFwIiwiYWRkUm91dGVSZWNvcmQiLCJtYXRjaEFzIiwibm9ybWFsaXplUGF0aCIsImJlZm9yZUVudGVyIiwic29tZSIsImNoaWxkTWF0Y2hBcyIsImFsaWFzIiwiYWxpYXNSb3V0ZSIsImluZGV4JDEiLCJhcnIiLCJpc2FycmF5IiwiaW5kZXgiLCJwYXRoVG9SZWdleHAiLCJwYXJzZV8xIiwicGFyc2UiLCJjb21waWxlXzEiLCJjb21waWxlIiwidG9rZW5zVG9GdW5jdGlvbl8xIiwidG9rZW5zVG9GdW5jdGlvbiIsInRva2Vuc1RvUmVnRXhwXzEiLCJ0b2tlbnNUb1JlZ0V4cCIsIlBBVEhfUkVHRVhQIiwiUmVnRXhwIiwidG9rZW5zIiwiZGVmYXVsdERlbGltaXRlciIsImRlbGltaXRlciIsImV4ZWMiLCJtIiwiZXNjYXBlZCIsIm9mZnNldCIsInByZWZpeCIsImNhcHR1cmUiLCJncm91cCIsIm1vZGlmaWVyIiwiYXN0ZXJpc2siLCJwYXJ0aWFsIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJwYXR0ZXJuIiwiZXNjYXBlR3JvdXAiLCJlc2NhcGVTdHJpbmciLCJzdWJzdHIiLCJlbmNvZGVVUklDb21wb25lbnRQcmV0dHkiLCJlbmNvZGVVUkkiLCJ0b1VwcGVyQ2FzZSIsImVuY29kZUFzdGVyaXNrIiwibWF0Y2hlcyIsIm9wdHMiLCJwcmV0dHkiLCJ0b2tlbiIsInZhbHVlIiwiVHlwZUVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImoiLCJhdHRhY2hLZXlzIiwicmUiLCJmbGFncyIsInNlbnNpdGl2ZSIsInJlZ2V4cFRvUmVnZXhwIiwiZ3JvdXBzIiwic291cmNlIiwibWF0Y2giLCJhcnJheVRvUmVnZXhwIiwicmVnZXhwIiwic3RyaW5nVG9SZWdleHAiLCJzdHJpY3QiLCJlbmQiLCJlbmRzV2l0aERlbGltaXRlciIsInJlZ2V4cENhY2hlIiwiZ2V0Um91dGVSZWdleCIsImhpdCIsInJlZ2V4cENvbXBpbGVDYWNoZSIsImZpbGxQYXJhbXMiLCJyb3V0ZU1zZyIsImZpbGxlciIsIm5vcm1hbGl6ZUxvY2F0aW9uIiwicmF3IiwiX25vcm1hbGl6ZWQiLCJhc3NpZ24iLCJyYXdQYXRoIiwicGFyc2VkUGF0aCIsImJhc2VQYXRoIiwiY3JlYXRlTWF0Y2hlciIsImFkZFJvdXRlcyIsImN1cnJlbnRSb3V0ZSIsInBhcmFtTmFtZXMiLCJfY3JlYXRlUm91dGUiLCJtYXRjaFJvdXRlIiwib3JpZ2luYWxSZWRpcmVjdCIsImhhc093blByb3BlcnR5IiwidGFyZ2V0UmVjb3JkIiwicmVzb2x2ZVJlY29yZFBhdGgiLCJyZXNvbHZlZFBhdGgiLCJhbGlhc2VkUGF0aCIsImFsaWFzZWRNYXRjaCIsImFsaWFzZWRSZWNvcmQiLCJwYXRobmFtZSIsInBvc2l0aW9uU3RvcmUiLCJzZXR1cFNjcm9sbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJzYXZlU2Nyb2xsUG9zaXRpb24iLCJzdGF0ZSIsInNldFN0YXRlS2V5IiwiaGFuZGxlU2Nyb2xsIiwiaXNQb3AiLCJhcHAiLCJiZWhhdmlvciIsInNjcm9sbEJlaGF2aW9yIiwiJG5leHRUaWNrIiwicG9zaXRpb24iLCJnZXRTY3JvbGxQb3NpdGlvbiIsInNob3VsZFNjcm9sbCIsImlzT2JqZWN0Iiwic2VsZWN0b3IiLCJlbCIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRFbGVtZW50UG9zaXRpb24iLCJpc1ZhbGlkUG9zaXRpb24iLCJub3JtYWxpemVQb3NpdGlvbiIsInNjcm9sbFRvIiwieSIsImdldFN0YXRlS2V5IiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsImRvY0VsIiwiZG9jdW1lbnRFbGVtZW50IiwiZG9jUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImVsUmVjdCIsImxlZnQiLCJ0b3AiLCJpc051bWJlciIsInYiLCJzdXBwb3J0c1B1c2hTdGF0ZSIsInVhIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiVGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiRGF0ZSIsIl9rZXkiLCJnZW5LZXkiLCJ0b0ZpeGVkIiwicHVzaFN0YXRlIiwidXJsIiwicmVwbGFjZVN0YXRlIiwicnVuUXVldWUiLCJmbiIsImNiIiwic3RlcCIsIkhpc3RvcnkiLCJub3JtYWxpemVCYXNlIiwicGVuZGluZyIsInJlYWR5IiwicmVhZHlDYnMiLCJsaXN0ZW4iLCJvblJlYWR5IiwidHJhbnNpdGlvblRvIiwib25Db21wbGV0ZSIsIm9uQWJvcnQiLCJjb25maXJtVHJhbnNpdGlvbiIsInVwZGF0ZVJvdXRlIiwiZW5zdXJlVVJMIiwiYWJvcnQiLCJyZXNvbHZlUXVldWUiLCJ1cGRhdGVkIiwiZGVhY3RpdmF0ZWQiLCJhY3RpdmF0ZWQiLCJleHRyYWN0TGVhdmVHdWFyZHMiLCJiZWZvcmVIb29rcyIsImV4dHJhY3RVcGRhdGVIb29rcyIsInJlc29sdmVBc3luY0NvbXBvbmVudHMiLCJpdGVyYXRvciIsInBvc3RFbnRlckNicyIsImlzVmFsaWQiLCJlbnRlckd1YXJkcyIsImV4dHJhY3RFbnRlckd1YXJkcyIsInByZXYiLCJhZnRlckhvb2tzIiwiYmFzZUVsIiwibWF4IiwiTWF0aCIsImV4dHJhY3RHdWFyZHMiLCJyZWNvcmRzIiwiYmluZCIsInJldmVyc2UiLCJndWFyZHMiLCJmbGF0TWFwQ29tcG9uZW50cyIsImRlZiIsImluc3RhbmNlIiwiZ3VhcmQiLCJleHRyYWN0R3VhcmQiLCJmbGF0dGVuIiwiYmluZEd1YXJkIiwiYm91bmRSb3V0ZUd1YXJkIiwiY2JzIiwiXyIsImJpbmRFbnRlckd1YXJkIiwicm91dGVFbnRlckd1YXJkIiwicG9sbCIsInJlc29sdmVkRGVmIiwicmVqZWN0IiwicmVhc29uIiwidGhlbiIsImNhbGxlZCIsIkhUTUw1SGlzdG9yeSIsIkhpc3RvcnkkJDEiLCJleHBlY3RTY3JvbGwiLCJnZXRMb2NhdGlvbiIsIl9fcHJvdG9fXyIsImNvbnN0cnVjdG9yIiwiZ28iLCJuIiwiZ2V0Q3VycmVudExvY2F0aW9uIiwic2VhcmNoIiwiSGFzaEhpc3RvcnkiLCJmYWxsYmFjayIsImNoZWNrRmFsbGJhY2siLCJlbnN1cmVTbGFzaCIsInNldHVwTGlzdGVuZXJzIiwiZ2V0SGFzaCIsInJlcGxhY2VIYXNoIiwicHVzaEhhc2giLCJBYnN0cmFjdEhpc3RvcnkiLCJ0YXJnZXRJbmRleCIsIlZ1ZVJvdXRlciIsImFwcHMiLCJtYXRjaGVyIiwicHJvdG90eXBlQWNjZXNzb3JzIiwic2V0dXBIYXNoTGlzdGVuZXIiLCJhZnRlckVhY2giLCJiYWNrIiwiZm9yd2FyZCIsImdldE1hdGNoZWRDb21wb25lbnRzIiwiY3JlYXRlSHJlZiIsIm5vcm1hbGl6ZWRUbyIsInJlc29sdmVkIiwiZGVmaW5lUHJvcGVydGllcyIsIl90b1N0cmluZyIsInRvTnVtYmVyIiwicGFyc2VGbG9hdCIsImlzTmFOIiwibWFrZU1hcCIsImV4cGVjdHNMb3dlckNhc2UiLCJsaXN0IiwidG9Mb3dlckNhc2UiLCJpc0J1aWx0SW5UYWciLCJyZW1vdmUiLCJpdGVtIiwic3BsaWNlIiwiaGFzT3duIiwiaXNQcmltaXRpdmUiLCJjYWNoZWQiLCJjYWNoZWRGbiIsImNhbWVsaXplUkUiLCJjYW1lbGl6ZSIsImNhcGl0YWxpemUiLCJoeXBoZW5hdGVSRSIsImh5cGhlbmF0ZSIsImN0eCIsImJvdW5kRm4iLCJsIiwiX2xlbmd0aCIsInRvQXJyYXkiLCJzdGFydCIsInJldCIsIl9mcm9tIiwiT0JKRUNUX1NUUklORyIsImlzUGxhaW5PYmplY3QiLCJ0b09iamVjdCIsIm5vIiwiaWRlbnRpdHkiLCJnZW5TdGF0aWNLZXlzIiwibW9kdWxlcyIsInJlZHVjZSIsInN0YXRpY0tleXMiLCJsb29zZUVxdWFsIiwiaXNPYmplY3RBIiwiaXNPYmplY3RCIiwibG9vc2VJbmRleE9mIiwic2lsZW50IiwicHJvZHVjdGlvblRpcCIsImRldnRvb2xzIiwiZXJyb3JIYW5kbGVyIiwiaWdub3JlZEVsZW1lbnRzIiwia2V5Q29kZXMiLCJpc1Jlc2VydmVkVGFnIiwiaXNVbmtub3duRWxlbWVudCIsImdldFRhZ05hbWVzcGFjZSIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwibXVzdFVzZVByb3AiLCJfYXNzZXRUeXBlcyIsIl9saWZlY3ljbGVIb29rcyIsIl9tYXhVcGRhdGVDb3VudCIsImVtcHR5T2JqZWN0IiwiaXNSZXNlcnZlZCIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImJhaWxSRSIsImhhc1Byb3RvIiwiVUEiLCJpc0lFIiwiaXNJRTkiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJnbG9iYWwiLCJWVUVfRU5WIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImlzTmF0aXZlIiwiQ3RvciIsImhhc1N5bWJvbCIsIlN5bWJvbCIsIlJlZmxlY3QiLCJvd25LZXlzIiwiY2FsbGJhY2tzIiwidGltZXJGdW5jIiwibmV4dFRpY2tIYW5kbGVyIiwiY29waWVzIiwiUHJvbWlzZSIsInAiLCJsb2dFcnJvciIsImVyciIsImVycm9yIiwiY2F0Y2giLCJNdXRhdGlvbk9ic2VydmVyIiwiY291bnRlciIsIm9ic2VydmVyIiwidGV4dE5vZGUiLCJjcmVhdGVUZXh0Tm9kZSIsIm9ic2VydmUiLCJjaGFyYWN0ZXJEYXRhIiwicXVldWVOZXh0VGljayIsIl9yZXNvbHZlIiwiX1NldCIsIlNldCIsInNldCIsImhhcyIsImFkZCIsImNsZWFyIiwidGlwIiwiZm9ybWF0Q29tcG9uZW50TmFtZSIsImhhc0NvbnNvbGUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJtc2ciLCJ2bSIsImZvcm1hdExvY2F0aW9uIiwiaW5jbHVkZUZpbGUiLCJfaXNWdWUiLCJfY29tcG9uZW50VGFnIiwiZmlsZSIsIl9fZmlsZSIsInVpZCQxIiwiRGVwIiwic3VicyIsImFkZFN1YiIsInN1YiIsInJlbW92ZVN1YiIsImRlcGVuZCIsImFkZERlcCIsIm5vdGlmeSIsInVwZGF0ZSIsInRhcmdldFN0YWNrIiwicHVzaFRhcmdldCIsIl90YXJnZXQiLCJwb3BUYXJnZXQiLCJhcnJheVByb3RvIiwiYXJyYXlNZXRob2RzIiwibWV0aG9kIiwib3JpZ2luYWwiLCJtdXRhdG9yIiwiYXJndW1lbnRzJDEiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIm9ic2VydmVyU3RhdGUiLCJzaG91bGRDb252ZXJ0IiwiaXNTZXR0aW5nUHJvcHMiLCJPYnNlcnZlciIsInZtQ291bnQiLCJhdWdtZW50IiwicHJvdG9BdWdtZW50IiwiY29weUF1Z21lbnQiLCJ3YWxrIiwiZGVmaW5lUmVhY3RpdmUkJDEiLCJpdGVtcyIsInNyYyIsImFzUm9vdERhdGEiLCJpc0V4dGVuc2libGUiLCJjdXN0b21TZXR0ZXIiLCJwcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJkZWwiLCJwcm9wc0RhdGEiLCJkZWZhdWx0U3RyYXQiLCJtZXJnZURhdGEiLCJ0b1ZhbCIsImZyb21WYWwiLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJtZXJnZUFzc2V0cyIsIndhdGNoIiwibWV0aG9kcyIsImNvbXB1dGVkIiwiY2hlY2tDb21wb25lbnRzIiwibG93ZXIiLCJub3JtYWxpemVQcm9wcyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMiLCJkaXJzIiwiZGlyZWN0aXZlcyIsIm1lcmdlT3B0aW9ucyIsImV4dGVuZHNGcm9tIiwiZXh0ZW5kcyIsIm1peGlucyIsIlZ1ZSQzIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImlzVHlwZSIsImdldFByb3BEZWZhdWx0VmFsdWUiLCJwcmV2U2hvdWxkQ29udmVydCIsImFzc2VydFByb3AiLCJfcHJvcHMiLCJnZXRUeXBlIiwidmFsaWQiLCJleHBlY3RlZFR5cGVzIiwiYXNzZXJ0ZWRUeXBlIiwiYXNzZXJ0VHlwZSIsImV4cGVjdGVkVHlwZSIsInZhbGlkYXRvciIsImhhbmRsZUVycm9yIiwiaW5mbyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsIm1hcmsiLCJtZWFzdXJlIiwicGVyZiIsImNsZWFyTWFya3MiLCJjbGVhck1lYXN1cmVzIiwic3RhcnRUYWciLCJlbmRUYWciLCJWTm9kZSIsImVsbSIsImNvbnRleHQiLCJjb21wb25lbnRPcHRpb25zIiwibnMiLCJmdW5jdGlvbmFsQ29udGV4dCIsImNvbXBvbmVudEluc3RhbmNlIiwiaXNSb290SW5zZXJ0IiwiaXNDb21tZW50IiwiaXNDbG9uZWQiLCJpc09uY2UiLCJjcmVhdGVFbXB0eVZOb2RlIiwibm9kZSIsImNyZWF0ZVRleHRWTm9kZSIsImNsb25lVk5vZGUiLCJjbG9uZWQiLCJjbG9uZVZOb2RlcyIsInZub2RlcyIsIm5vcm1hbGl6ZUV2ZW50Iiwib25jZSQkMSIsImNyZWF0ZUZuSW52b2tlciIsImZucyIsImludm9rZXIiLCJ1cGRhdGVMaXN0ZW5lcnMiLCJvbGRPbiIsInJlbW92ZSQkMSIsImN1ciIsIm9sZCIsIm1lcmdlVk5vZGVIb29rIiwiaG9va0tleSIsIm9sZEhvb2siLCJ3cmFwcGVkSG9vayIsIm1lcmdlZCIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwibmVzdGVkSW5kZXgiLCJsYXN0IiwiZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCIsImluaXRFdmVudHMiLCJfZXZlbnRzIiwiX2hhc0hvb2tFdmVudCIsImxpc3RlbmVycyIsIl9wYXJlbnRMaXN0ZW5lcnMiLCJ1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMiLCIkb25jZSIsIiRvbiIsInJlbW92ZSQxIiwiJG9mZiIsIm9sZExpc3RlbmVycyIsImV2ZW50c01peGluIiwiaG9va1JFIiwiaSQxIiwiJGVtaXQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsImRlZmF1bHRTbG90Iiwic2xvdCIsImlzV2hpdGVzcGFjZSIsInJlc29sdmVTY29wZWRTbG90cyIsImFjdGl2ZUluc3RhbmNlIiwiaW5pdExpZmVjeWNsZSIsImFic3RyYWN0IiwiJGNoaWxkcmVuIiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc01vdW50ZWQiLCJfaXNEZXN0cm95ZWQiLCJfaXNCZWluZ0Rlc3Ryb3llZCIsImxpZmVjeWNsZU1peGluIiwiX3VwZGF0ZSIsImh5ZHJhdGluZyIsImNhbGxIb29rIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwiX3Zub2RlIiwicHJldkFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX3BhcmVudEVsbSIsIl9yZWZFbG0iLCJfX3Z1ZV9fIiwiJGZvcmNlVXBkYXRlIiwiJGRlc3Ryb3kiLCJ0ZWFyZG93biIsIl93YXRjaGVycyIsIl9kYXRhIiwibW91bnRDb21wb25lbnQiLCJ0ZW1wbGF0ZSIsInVwZGF0ZUNvbXBvbmVudCIsIl9uYW1lIiwiX3VpZCIsIl9yZW5kZXIiLCJXYXRjaGVyIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJwYXJlbnRWbm9kZSIsInJlbmRlckNoaWxkcmVuIiwiaGFzQ2hpbGRyZW4iLCJfcmVuZGVyQ2hpbGRyZW4iLCJzY29wZWRTbG90cyIsIiRzY29wZWRTbG90cyIsIl9wYXJlbnRWbm9kZSIsInByb3BLZXlzIiwiX3Byb3BLZXlzIiwiaXNJbkluYWN0aXZlVHJlZSIsImFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJkaXJlY3QiLCJkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJjaXJjdWxhciIsIndhaXRpbmciLCJmbHVzaGluZyIsInJlc2V0U2NoZWR1bGVyU3RhdGUiLCJmbHVzaFNjaGVkdWxlclF1ZXVlIiwid2F0Y2hlciIsInNvcnQiLCJ1c2VyIiwiZXhwcmVzc2lvbiIsInF1ZXVlV2F0Y2hlciIsInVpZCQyIiwiZXhwT3JGbiIsImRlZXAiLCJsYXp5Iiwic3luYyIsImFjdGl2ZSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJ0cmF2ZXJzZSIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNlZW5PYmplY3RzIiwiX3RyYXZlcnNlIiwic2VlbiIsImlzQSIsImRlcElkIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwicHJveHkiLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsImlzUmVzZXJ2ZWRQcm9wIiwicHJvcHNPcHRpb25zIiwiaXNSb290IiwibG9vcCIsImNvbXB1dGVkV2F0Y2hlck9wdGlvbnMiLCJ3YXRjaGVycyIsIl9jb21wdXRlZFdhdGNoZXJzIiwidXNlckRlZiIsImRlZmluZUNvbXB1dGVkIiwiY3JlYXRlQ29tcHV0ZWRHZXR0ZXIiLCJjb21wdXRlZEdldHRlciIsImNyZWF0ZVdhdGNoZXIiLCIkd2F0Y2giLCJzdGF0ZU1peGluIiwiZGF0YURlZiIsInByb3BzRGVmIiwibmV3RGF0YSIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwiY29tcG9uZW50Vk5vZGVIb29rcyIsInBhcmVudEVsbSIsInJlZkVsbSIsImNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUiLCJrZWVwQWxpdmUiLCJtb3VudGVkTm9kZSIsImluc2VydCIsImhvb2tzVG9NZXJnZSIsImNyZWF0ZUNvbXBvbmVudCIsImJhc2VDdG9yIiwiX2Jhc2UiLCJjaWQiLCJyZXNvbHZlQXN5bmNDb21wb25lbnQiLCJyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIiwibW9kZWwiLCJ0cmFuc2Zvcm1Nb2RlbCIsImV4dHJhY3RQcm9wcyIsImNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJuYXRpdmVPbiIsIm1lcmdlSG9va3MiLCJfY29udGV4dCIsImQiLCJ2bm9kZUNvbXBvbmVudE9wdGlvbnMiLCJfaXNDb21wb25lbnQiLCJpbmxpbmVUZW1wbGF0ZSIsInN0YXRpY1JlbmRlckZucyIsImZhY3RvcnkiLCJyZXF1ZXN0ZWQiLCJwZW5kaW5nQ2FsbGJhY2tzIiwiZG9tUHJvcHMiLCJhbHRLZXkiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsInByZXNlcnZlIiwiZnJvbVBhcmVudCIsIm91cnMiLCJtZXJnZUhvb2skMSIsIm9uZSIsInR3byIsImNhbGxiYWNrIiwiU0lNUExFX05PUk1BTElaRSIsIkFMV0FZU19OT1JNQUxJWkUiLCJub3JtYWxpemF0aW9uVHlwZSIsImFsd2F5c05vcm1hbGl6ZSIsIl9jcmVhdGVFbGVtZW50IiwiYXBwbHlOUyIsInJlbmRlckxpc3QiLCJyZW5kZXJTbG90IiwiYmluZE9iamVjdCIsInNjb3BlZFNsb3RGbiIsInNsb3ROb2RlcyIsIl9yZW5kZXJlZCIsInJlc29sdmVGaWx0ZXIiLCJjaGVja0tleUNvZGVzIiwiZXZlbnRLZXlDb2RlIiwiYnVpbHRJbkFsaWFzIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwicmVuZGVyU3RhdGljIiwiaXNJbkZvciIsInRyZWUiLCJfc3RhdGljVHJlZXMiLCJtYXJrU3RhdGljIiwibWFya09uY2UiLCJtYXJrU3RhdGljTm9kZSIsImluaXRSZW5kZXIiLCJyZW5kZXJDb250ZXh0IiwiX2MiLCIkY3JlYXRlRWxlbWVudCIsInJlbmRlck1peGluIiwicmVuZGVyRXJyb3IiLCJfbyIsIl9uIiwiX3MiLCJfbCIsIl90IiwiX3EiLCJfaSIsIl9tIiwiX2YiLCJfayIsIl9iIiwiX3YiLCJfZSIsIl91IiwiaW5pdFByb3ZpZGUiLCJwcm92aWRlIiwiX3Byb3ZpZGVkIiwiaW5pdEluamVjdGlvbnMiLCJpbmplY3QiLCJwcm92aWRlS2V5IiwidWlkIiwiaW5pdE1peGluIiwiX2luaXQiLCJpbml0SW50ZXJuYWxDb21wb25lbnQiLCJfc2VsZiIsInN1cGVyIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJkZWR1cGUiLCJpbml0VXNlIiwicGx1Z2luIiwiaW5pdE1peGluJDEiLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsInBhdHRlcm5UeXBlcyIsImdldENvbXBvbmVudE5hbWUiLCJwcnVuZUNhY2hlIiwiY2FjaGVkTm9kZSIsInBydW5lQ2FjaGVFbnRyeSIsIktlZXBBbGl2ZSIsImluY2x1ZGUiLCJleGNsdWRlIiwiZGVzdHJveWVkIiwiYnVpbHRJbkNvbXBvbmVudHMiLCJpbml0R2xvYmFsQVBJIiwiY29uZmlnRGVmIiwiZGVsZXRlIiwiYWNjZXB0VmFsdWUiLCJhdHRyIiwiaXNFbnVtZXJhdGVkQXR0ciIsImlzQm9vbGVhbkF0dHIiLCJ4bGlua05TIiwiaXNYbGluayIsImdldFhsaW5rUHJvcCIsImlzRmFsc3lBdHRyVmFsdWUiLCJnZW5DbGFzc0ZvclZub2RlIiwicGFyZW50Tm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwiZ2VuQ2xhc3NGcm9tRGF0YSIsInN0YXRpY0NsYXNzIiwiZHluYW1pY0NsYXNzIiwic3RyaW5naWZ5Q2xhc3MiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsImlzUHJlVGFnIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50Iiwic2VsZWN0ZWQiLCJjcmVhdGVFbGVtZW50JDEiLCJ0YWdOYW1lIiwibXVsdGlwbGUiLCJzZXRBdHRyaWJ1dGUiLCJjcmVhdGVFbGVtZW50TlMiLCJuYW1lc3BhY2UiLCJjcmVhdGVDb21tZW50IiwiaW5zZXJ0QmVmb3JlIiwibmV3Tm9kZSIsInJlZmVyZW5jZU5vZGUiLCJyZW1vdmVDaGlsZCIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsIm5vZGVPcHMiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsImlzVW5kZWYiLCJzIiwiaXNEZWYiLCJzYW1lVm5vZGUiLCJ2bm9kZTEiLCJ2bm9kZTIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJlbXB0eU5vZGVBdCIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsInJlbW92ZU5vZGUiLCJpblByZSIsImNyZWF0ZUVsbSIsImluc2VydGVkVm5vZGVRdWV1ZSIsIm5lc3RlZCIsInByZSIsInNldFNjb3BlIiwiY3JlYXRlQ2hpbGRyZW4iLCJpbnZva2VDcmVhdGVIb29rcyIsImlzUmVhY3RpdmF0ZWQiLCJpbml0Q29tcG9uZW50IiwicmVhY3RpdmF0ZUNvbXBvbmVudCIsInBlbmRpbmdJbnNlcnQiLCJpc1BhdGNoYWJsZSIsImlubmVyTm9kZSIsInRyYW5zaXRpb24iLCJhY3RpdmF0ZSIsImFuY2VzdG9yIiwiX3Njb3BlSWQiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJlbG1Ub01vdmUiLCJjYW5Nb3ZlIiwicGF0Y2hWbm9kZSIsImhhc0RhdGEiLCJwb3N0cGF0Y2giLCJpbnZva2VJbnNlcnRIb29rIiwiaW5pdGlhbCIsImJhaWxlZCIsImlzUmVuZGVyZWRNb2R1bGUiLCJoeWRyYXRlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsIm5vZGVUeXBlIiwicGF0Y2giLCJpc0luaXRpYWxQYXRjaCIsImlzUmVhbEVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJvbGRFbG0iLCJwYXJlbnRFbG0kMSIsIl9sZWF2ZUNiIiwidXBkYXRlRGlyZWN0aXZlcyIsInVuYmluZERpcmVjdGl2ZXMiLCJpc0NyZWF0ZSIsImlzRGVzdHJveSIsIm9sZERpcnMiLCJub3JtYWxpemVEaXJlY3RpdmVzJDEiLCJuZXdEaXJzIiwiZGlyc1dpdGhJbnNlcnQiLCJkaXJzV2l0aFBvc3RwYXRjaCIsIm9sZERpciIsImNhbGxIb29rJDEiLCJjb21wb25lbnRVcGRhdGVkIiwiY2FsbEluc2VydCIsImVtcHR5TW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiZ2V0UmF3RGlyTmFtZSIsInJhd05hbWUiLCJiYXNlTW9kdWxlcyIsInVwZGF0ZUF0dHJzIiwib2xkQXR0cnMiLCJzZXRBdHRyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGVOUyIsInVwZGF0ZUNsYXNzIiwib2xkRGF0YSIsInRyYW5zaXRpb25DbGFzcyIsIl90cmFuc2l0aW9uQ2xhc3NlcyIsIl9wcmV2Q2xhc3MiLCJrbGFzcyIsInZhbGlkRGl2aXNpb25DaGFyUkUiLCJwYXJzZUZpbHRlcnMiLCJleHAiLCJpblNpbmdsZSIsImluRG91YmxlIiwiaW5UZW1wbGF0ZVN0cmluZyIsImluUmVnZXgiLCJjdXJseSIsInNxdWFyZSIsInBhcmVuIiwibGFzdEZpbHRlckluZGV4IiwiZmlsdGVycyIsInB1c2hGaWx0ZXIiLCJ3cmFwRmlsdGVyIiwiYmFzZVdhcm4iLCJwbHVja01vZHVsZUZ1bmN0aW9uIiwiYWRkUHJvcCIsImFkZEF0dHIiLCJhZGREaXJlY3RpdmUiLCJhcmciLCJhZGRIYW5kbGVyIiwiaW1wb3J0YW50IiwiZXZlbnRzIiwibmF0aXZlIiwibmF0aXZlRXZlbnRzIiwibmV3SGFuZGxlciIsImdldEJpbmRpbmdBdHRyIiwiZ2V0U3RhdGljIiwiZHluYW1pY1ZhbHVlIiwiZ2V0QW5kUmVtb3ZlQXR0ciIsInN0YXRpY1ZhbHVlIiwiYXR0cnNNYXAiLCJhdHRyc0xpc3QiLCJnZW5Db21wb25lbnRNb2RlbCIsIm51bWJlciIsImJhc2VWYWx1ZUV4cHJlc3Npb24iLCJ2YWx1ZUV4cHJlc3Npb24iLCJhc3NpZ25tZW50IiwiZ2VuQXNzaWdubWVudENvZGUiLCJtb2RlbFJzIiwicGFyc2VNb2RlbCIsImlkeCIsImNociIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwibGFzdEluZGV4T2YiLCJlb2YiLCJpc1N0cmluZ1N0YXJ0IiwicGFyc2VTdHJpbmciLCJwYXJzZUJyYWNrZXQiLCJzdWJzdHJpbmciLCJpbkJyYWNrZXQiLCJzdHJpbmdRdW90ZSIsIndhcm4kMSIsIlJBTkdFX1RPS0VOIiwiQ0hFQ0tCT1hfUkFESU9fVE9LRU4iLCJfd2FybiIsImR5bmFtaWNUeXBlIiwiZ2VuU2VsZWN0IiwiZ2VuQ2hlY2tib3hNb2RlbCIsImdlblJhZGlvTW9kZWwiLCJnZW5EZWZhdWx0TW9kZWwiLCJ2YWx1ZUJpbmRpbmciLCJ0cnVlVmFsdWVCaW5kaW5nIiwiZmFsc2VWYWx1ZUJpbmRpbmciLCJzZWxlY3RlZFZhbCIsImNvZGUiLCJuZWVkQ29tcG9zaXRpb25HdWFyZCIsIm5vcm1hbGl6ZUV2ZW50cyIsInRhcmdldCQxIiwiYWRkJDEiLCJvbGRIYW5kbGVyIiwiZXYiLCJyZW1vdmUkMiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1cGRhdGVET01MaXN0ZW5lcnMiLCJ1cGRhdGVET01Qcm9wcyIsIm9sZFByb3BzIiwiX3ZhbHVlIiwic3RyQ3VyIiwic2hvdWxkVXBkYXRlVmFsdWUiLCJjaGVja1ZhbCIsImNvbXBvc2luZyIsImlzRGlydHkiLCJpc0lucHV0Q2hhbmdlZCIsImFjdGl2ZUVsZW1lbnQiLCJfdk1vZGlmaWVycyIsInBhcnNlU3R5bGVUZXh0IiwiY3NzVGV4dCIsImxpc3REZWxpbWl0ZXIiLCJwcm9wZXJ0eURlbGltaXRlciIsIm5vcm1hbGl6ZVN0eWxlRGF0YSIsInN0eWxlIiwibm9ybWFsaXplU3R5bGVCaW5kaW5nIiwic3RhdGljU3R5bGUiLCJiaW5kaW5nU3R5bGUiLCJnZXRTdHlsZSIsImNoZWNrQ2hpbGQiLCJzdHlsZURhdGEiLCJjc3NWYXJSRSIsImltcG9ydGFudFJFIiwic2V0UHJvcCIsInNldFByb3BlcnR5Iiwibm9ybWFsaXplIiwicHJlZml4ZXMiLCJ0ZXN0RWwiLCJ1cHBlciIsInByZWZpeGVkIiwidXBkYXRlU3R5bGUiLCJvbGRTdGF0aWNTdHlsZSIsIm9sZFN0eWxlQmluZGluZyIsIm9sZFN0eWxlIiwibmV3U3R5bGUiLCJhZGRDbGFzcyIsImNsYXNzTGlzdCIsInJlbW92ZUNsYXNzIiwidGFyIiwicmVzb2x2ZVRyYW5zaXRpb24iLCJkZWYkJDEiLCJjc3MiLCJhdXRvQ3NzVHJhbnNpdGlvbiIsImVudGVyQ2xhc3MiLCJlbnRlclRvQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwibGVhdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsImxlYXZlQWN0aXZlQ2xhc3MiLCJoYXNUcmFuc2l0aW9uIiwiVFJBTlNJVElPTiIsIkFOSU1BVElPTiIsInRyYW5zaXRpb25Qcm9wIiwidHJhbnNpdGlvbkVuZEV2ZW50IiwiYW5pbWF0aW9uUHJvcCIsImFuaW1hdGlvbkVuZEV2ZW50Iiwib250cmFuc2l0aW9uZW5kIiwib253ZWJraXR0cmFuc2l0aW9uZW5kIiwib25hbmltYXRpb25lbmQiLCJvbndlYmtpdGFuaW1hdGlvbmVuZCIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5leHRGcmFtZSIsImFkZFRyYW5zaXRpb25DbGFzcyIsInJlbW92ZVRyYW5zaXRpb25DbGFzcyIsIndoZW5UcmFuc2l0aW9uRW5kcyIsImdldFRyYW5zaXRpb25JbmZvIiwicHJvcENvdW50IiwiZW5kZWQiLCJvbkVuZCIsInRyYW5zZm9ybVJFIiwic3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRyYW5zaXRpb25EZWxheXMiLCJ0cmFuc2l0aW9uRHVyYXRpb25zIiwidHJhbnNpdGlvblRpbWVvdXQiLCJnZXRUaW1lb3V0IiwiYW5pbWF0aW9uRGVsYXlzIiwiYW5pbWF0aW9uRHVyYXRpb25zIiwiYW5pbWF0aW9uVGltZW91dCIsImhhc1RyYW5zZm9ybSIsImRlbGF5cyIsImR1cmF0aW9ucyIsInRvTXMiLCJOdW1iZXIiLCJlbnRlciIsInRvZ2dsZURpc3BsYXkiLCJjYW5jZWxsZWQiLCJfZW50ZXJDYiIsImFwcGVhckNsYXNzIiwiYXBwZWFyVG9DbGFzcyIsImFwcGVhckFjdGl2ZUNsYXNzIiwiYWZ0ZXJFbnRlciIsImVudGVyQ2FuY2VsbGVkIiwiYmVmb3JlQXBwZWFyIiwiYXBwZWFyIiwiYWZ0ZXJBcHBlYXIiLCJhcHBlYXJDYW5jZWxsZWQiLCJkdXJhdGlvbiIsInRyYW5zaXRpb25Ob2RlIiwiaXNBcHBlYXIiLCJzdGFydENsYXNzIiwidG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJiZWZvcmVMZWF2ZSIsImFmdGVyTGVhdmUiLCJsZWF2ZUNhbmNlbGxlZCIsImRlbGF5TGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJwZXJmb3JtTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwidm1vZGVsIiwibW9kZWwkMSIsInNldFNlbGVjdGVkIiwib25Db21wb3NpdGlvblN0YXJ0Iiwib25Db21wb3NpdGlvbkVuZCIsIm5lZWRSZXNldCIsImhhc05vTWF0Y2hpbmdPcHRpb24iLCJpc011bHRpcGxlIiwib3B0aW9uIiwiZ2V0VmFsdWUiLCJzZWxlY3RlZEluZGV4IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibG9jYXRlTm9kZSIsIm9yaWdpbmFsRGlzcGxheSIsIl9fdk9yaWdpbmFsRGlzcGxheSIsImRpc3BsYXkiLCJ1bmJpbmQiLCJwbGF0Zm9ybURpcmVjdGl2ZXMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJnZXRSZWFsQ2hpbGQiLCJjb21wT3B0aW9ucyIsImV4dHJhY3RUcmFuc2l0aW9uRGF0YSIsImNvbXAiLCJrZXkkMSIsInBsYWNlaG9sZGVyIiwicmF3Q2hpbGQiLCJoYXNQYXJlbnRUcmFuc2l0aW9uIiwiaXNTYW1lQ2hpbGQiLCJvbGRDaGlsZCIsIlRyYW5zaXRpb24iLCJfbGVhdmluZyIsIm9sZFJhd0NoaWxkIiwiZGVsYXllZExlYXZlIiwibW92ZUNsYXNzIiwiVHJhbnNpdGlvbkdyb3VwIiwicHJldkNoaWxkcmVuIiwicmF3Q2hpbGRyZW4iLCJ0cmFuc2l0aW9uRGF0YSIsImtlcHQiLCJyZW1vdmVkIiwiYyQxIiwicG9zIiwiYmVmb3JlVXBkYXRlIiwiaGFzTW92ZSIsImNhbGxQZW5kaW5nQ2JzIiwicmVjb3JkUG9zaXRpb24iLCJhcHBseVRyYW5zbGF0aW9uIiwiYm9keSIsImYiLCJvZmZzZXRIZWlnaHQiLCJtb3ZlZCIsInRyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIl9tb3ZlQ2IiLCJwcm9wZXJ0eU5hbWUiLCJfaGFzTW92ZSIsImNsb25lIiwiY2xvbmVOb2RlIiwibmV3UG9zIiwib2xkUG9zIiwiZHgiLCJkeSIsInBsYXRmb3JtQ29tcG9uZW50cyIsInNob3VsZERlY29kZSIsImNvbnRlbnQiLCJlbmNvZGVkIiwiZGl2Iiwic2hvdWxkRGVjb2RlTmV3bGluZXMiLCJpc1VuYXJ5VGFnIiwiY2FuQmVMZWZ0T3BlblRhZyIsImlzTm9uUGhyYXNpbmdUYWciLCJkZWNvZGVyIiwiaHRtbCIsInNpbmdsZUF0dHJJZGVudGlmaWVyIiwic2luZ2xlQXR0ckFzc2lnbiIsInNpbmdsZUF0dHJWYWx1ZXMiLCJhdHRyaWJ1dGUiLCJuY25hbWUiLCJxbmFtZUNhcHR1cmUiLCJzdGFydFRhZ09wZW4iLCJzdGFydFRhZ0Nsb3NlIiwiZG9jdHlwZSIsImNvbW1lbnQiLCJjb25kaXRpb25hbENvbW1lbnQiLCJJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOIiwiZyIsImlzUGxhaW5UZXh0RWxlbWVudCIsInJlQ2FjaGUiLCJkZWNvZGluZ01hcCIsImVuY29kZWRBdHRyIiwiZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMiLCJkZWNvZGVBdHRyIiwicGFyc2VIVE1MIiwiZXhwZWN0SFRNTCIsImlzVW5hcnlUYWckJDEiLCJsYXN0VGFnIiwidGV4dEVuZCIsImNvbW1lbnRFbmQiLCJhZHZhbmNlIiwiY29uZGl0aW9uYWxFbmQiLCJkb2N0eXBlTWF0Y2giLCJlbmRUYWdNYXRjaCIsImN1ckluZGV4IiwicGFyc2VFbmRUYWciLCJzdGFydFRhZ01hdGNoIiwicGFyc2VTdGFydFRhZyIsImhhbmRsZVN0YXJ0VGFnIiwicmVzdCQxIiwiY2hhcnMiLCJzdGFja2VkVGFnIiwicmVTdGFja2VkVGFnIiwiZW5kVGFnTGVuZ3RoIiwicmVzdCIsImFsbCIsInVuYXJ5U2xhc2giLCJ1bmFyeSIsImxvd2VyQ2FzZWRUYWciLCJsb3dlckNhc2VkVGFnTmFtZSIsImRlZmF1bHRUYWdSRSIsInJlZ2V4RXNjYXBlUkUiLCJidWlsZFJlZ2V4IiwiZGVsaW1pdGVycyIsIm9wZW4iLCJjbG9zZSIsInBhcnNlVGV4dCIsInRhZ1JFIiwibGFzdEluZGV4Iiwib25SRSIsImRpclJFIiwiZm9yQWxpYXNSRSIsImZvckl0ZXJhdG9yUkUiLCJhcmdSRSIsImJpbmRSRSIsIm1vZGlmaWVyUkUiLCJkZWNvZGVIVE1MQ2FjaGVkIiwid2FybiQyIiwidHJhbnNmb3JtcyIsInByZVRyYW5zZm9ybXMiLCJwb3N0VHJhbnNmb3JtcyIsInBsYXRmb3JtSXNQcmVUYWciLCJwbGF0Zm9ybU11c3RVc2VQcm9wIiwicGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJyb290IiwiY3VycmVudFBhcmVudCIsImluVlByZSIsIndhcm5lZCIsIndhcm5PbmNlIiwiZW5kUHJlIiwiZ3VhcmRJRVNWR0J1ZyIsIm1ha2VBdHRyc01hcCIsImlzRm9yYmlkZGVuVGFnIiwiZm9yYmlkZGVuIiwicHJvY2Vzc1ByZSIsInByb2Nlc3NSYXdBdHRycyIsInByb2Nlc3NGb3IiLCJwcm9jZXNzSWYiLCJwcm9jZXNzT25jZSIsInByb2Nlc3NLZXkiLCJwbGFpbiIsInByb2Nlc3NSZWYiLCJwcm9jZXNzU2xvdCIsInByb2Nlc3NDb21wb25lbnQiLCJwcm9jZXNzQXR0cnMiLCJjaGVja1Jvb3RDb25zdHJhaW50cyIsImlmIiwiZWxzZWlmIiwiZWxzZSIsImFkZElmQ29uZGl0aW9uIiwiYmxvY2siLCJwcm9jZXNzSWZDb25kaXRpb25zIiwic2xvdFNjb3BlIiwic2xvdFRhcmdldCIsImkkMiIsImxhc3ROb2RlIiwiY2hlY2tJbkZvciIsImluTWF0Y2giLCJmb3IiLCJpdGVyYXRvck1hdGNoIiwiaXRlcmF0b3IxIiwiaXRlcmF0b3IyIiwiZmluZFByZXZFbGVtZW50IiwiaWZDb25kaXRpb25zIiwic2xvdE5hbWUiLCJpc1Byb3AiLCJoYXNCaW5kaW5ncyIsInBhcnNlTW9kaWZpZXJzIiwiY2FtZWwiLCJhcmdNYXRjaCIsImNoZWNrRm9yQWxpYXNNb2RlbCIsImllTlNCdWciLCJpZU5TUHJlZml4IiwiX2VsIiwiaXNTdGF0aWNLZXkiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWciLCJnZW5TdGF0aWNLZXlzQ2FjaGVkIiwiZ2VuU3RhdGljS2V5cyQxIiwib3B0aW1pemUiLCJtYXJrU3RhdGljJDEiLCJtYXJrU3RhdGljUm9vdHMiLCJzdGF0aWMiLCJzdGF0aWNJbkZvciIsInN0YXRpY1Jvb3QiLCJ3YWxrVGhyb3VnaENvbmRpdGlvbnNCbG9ja3MiLCJjb25kaXRpb25CbG9ja3MiLCJpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciIsImZuRXhwUkUiLCJzaW1wbGVQYXRoUkUiLCJlc2MiLCJ0YWIiLCJzcGFjZSIsInVwIiwicmlnaHQiLCJkb3duIiwiZ2VuR3VhcmQiLCJtb2RpZmllckNvZGUiLCJzdG9wIiwicHJldmVudCIsInNlbGYiLCJjdHJsIiwiYWx0IiwibWlkZGxlIiwiZ2VuSGFuZGxlcnMiLCJnZW5IYW5kbGVyIiwiaXNNZXRob2RQYXRoIiwiaXNGdW5jdGlvbkV4cHJlc3Npb24iLCJnZW5Nb2RpZmllckNvZGUiLCJnZW5LZXlGaWx0ZXIiLCJoYW5kbGVyQ29kZSIsImdlbkZpbHRlckNvZGUiLCJrZXlWYWwiLCJwYXJzZUludCIsImJpbmQkMSIsIndyYXBEYXRhIiwiYmFzZURpcmVjdGl2ZXMiLCJjbG9hayIsIndhcm4kMyIsInRyYW5zZm9ybXMkMSIsImRhdGFHZW5GbnMiLCJwbGF0Zm9ybURpcmVjdGl2ZXMkMSIsImlzUGxhdGZvcm1SZXNlcnZlZFRhZyQxIiwib25jZUNvdW50IiwiY3VycmVudE9wdGlvbnMiLCJnZW5lcmF0ZSIsImFzdCIsInByZXZTdGF0aWNSZW5kZXJGbnMiLCJjdXJyZW50U3RhdGljUmVuZGVyRm5zIiwicHJldk9uY2VDb3VudCIsImdlbkVsZW1lbnQiLCJzdGF0aWNQcm9jZXNzZWQiLCJnZW5TdGF0aWMiLCJvbmNlUHJvY2Vzc2VkIiwiZ2VuT25jZSIsImZvclByb2Nlc3NlZCIsImdlbkZvciIsImlmUHJvY2Vzc2VkIiwiZ2VuSWYiLCJnZW5DaGlsZHJlbiIsImdlblNsb3QiLCJnZW5Db21wb25lbnQiLCJnZW5EYXRhIiwiZ2VuSWZDb25kaXRpb25zIiwiY29uZGl0aW9ucyIsImdlblRlcm5hcnlFeHAiLCJtYXliZUNvbXBvbmVudCIsImdlbkRpcmVjdGl2ZXMiLCJnZW5Qcm9wcyIsImdlblNjb3BlZFNsb3RzIiwiZ2VuSW5saW5lVGVtcGxhdGUiLCJoYXNSdW50aW1lIiwibmVlZFJ1bnRpbWUiLCJnZW4iLCJpbmxpbmVSZW5kZXJGbnMiLCJnZW5TY29wZWRTbG90Iiwic2NvcGUiLCJjaGVja1NraXAiLCJlbCQxIiwiZ2V0Tm9ybWFsaXphdGlvblR5cGUiLCJnZW5Ob2RlIiwibmVlZHNOb3JtYWxpemF0aW9uIiwiZ2VuVGV4dCIsInRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyIsImJpbmQkJDEiLCJjb21wb25lbnROYW1lIiwicHJvaGliaXRlZEtleXdvcmRSRSIsInVuYXJ5T3BlcmF0b3JzUkUiLCJpZGVudFJFIiwic3RyaXBTdHJpbmdSRSIsImRldGVjdEVycm9ycyIsImVycm9ycyIsImNoZWNrTm9kZSIsImNoZWNrRm9yIiwiY2hlY2tFdmVudCIsImNoZWNrRXhwcmVzc2lvbiIsImtleXdvcmRNYXRjaCIsImNoZWNrSWRlbnRpZmllciIsImlkZW50IiwiRnVuY3Rpb24iLCJiYXNlQ29tcGlsZSIsIm1ha2VGdW5jdGlvbiIsImNyZWF0ZUNvbXBpbGVyIiwiYmFzZU9wdGlvbnMiLCJmdW5jdGlvbkNvbXBpbGVDYWNoZSIsImZpbmFsT3B0aW9ucyIsInRpcHMiLCJ0aXAkJDEiLCJjb21waWxlZCIsImNvbXBpbGVUb0Z1bmN0aW9ucyIsImZuR2VuRXJyb3JzIiwidHJhbnNmb3JtTm9kZSIsImNsYXNzQmluZGluZyIsImdlbkRhdGEkMSIsImtsYXNzJDEiLCJ0cmFuc2Zvcm1Ob2RlJDEiLCJzdHlsZUJpbmRpbmciLCJnZW5EYXRhJDIiLCJzdHlsZSQxIiwibW9kdWxlcyQxIiwiZGlyZWN0aXZlcyQxIiwicmVmJDEiLCJpZFRvVGVtcGxhdGUiLCJtb3VudCIsImdldE91dGVySFRNTCIsIm91dGVySFRNTCIsImNvbnRhaW5lciIsImV2YWwiLCJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2hFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7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QUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQywrQkFBK0IsYUFBYSwwQkFBMEI7QUFDdkU7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQyIsImZpbGUiOiJoNXAtZmVlZGJhY2suanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgN2E5YTcyYzc4NzNjZTY4YzU0NTAiLCIvLyB0aGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGVcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICByYXdTY3JpcHRFeHBvcnRzLFxuICBjb21waWxlZFRlbXBsYXRlLFxuICBzY29wZUlkLFxuICBjc3NNb2R1bGVzXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICAvLyBpbmplY3QgY3NzTW9kdWxlc1xuICBpZiAoY3NzTW9kdWxlcykge1xuICAgIHZhciBjb21wdXRlZCA9IE9iamVjdC5jcmVhdGUob3B0aW9ucy5jb21wdXRlZCB8fCBudWxsKVxuICAgIE9iamVjdC5rZXlzKGNzc01vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG1vZHVsZSA9IGNzc01vZHVsZXNba2V5XVxuICAgICAgY29tcHV0ZWRba2V5XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZHVsZSB9XG4gICAgfSlcbiAgICBvcHRpb25zLmNvbXB1dGVkID0gY29tcHV0ZWRcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcHJvY2Vzcy9icm93c2VyLmpzIiwiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xuaW1wb3J0IFJvdXRlciBmcm9tICd2dWUtcm91dGVyJztcbmltcG9ydCBTY29yZUlucHV0IGZyb20gJy4vdmlld3MvU2NvcmVJbnB1dC52dWUnO1xuaW1wb3J0IFRleHRJbnB1dCBmcm9tICcuL3ZpZXdzL1RleHRJbnB1dC52dWUnO1xuaW1wb3J0IEZpbmFsIGZyb20gJy4vdmlld3MvRmluYWwudnVlJztcblxuVnVlLnVzZShSb3V0ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGZWVkYmFjayBleHRlbmRzIEg1UC5FdmVudERpc3BhdGNoZXIge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRJZFxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGVudERhdGFcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZywgY29udGVudElkLCBjb250ZW50RGF0YSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNvbnRlbnRJZCA9IGNvbnRlbnRJZDtcblxuICAgIGNvbnN0IGFsdGVybmF0aXZlcyA9IFtcbiAgICAgIHtcbiAgICAgICAgdGl0bGU6ICdWZXJ5IFNhdGlzZmllZCcsXG4gICAgICAgIGNsczogJ2ZlZWRiYWNrLXNjb3JlLTQnLFxuICAgICAgICBzY29yZTogJzQnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0aXRsZTogJ1NhdGlzZmllZCcsXG4gICAgICAgIGNsczogJ2ZlZWRiYWNrLXNjb3JlLTMnLFxuICAgICAgICBzY29yZTogJzMnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0aXRsZTogJ05ldXRyYWwnLFxuICAgICAgICBjbHM6ICdmZWVkYmFjay1zY29yZS0yJyxcbiAgICAgICAgc2NvcmU6ICcyJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGl0bGU6ICdVbnNhdGlzZmllZCcsXG4gICAgICAgIGNsczogJ2ZlZWRiYWNrLXNjb3JlLTEnLFxuICAgICAgICBzY29yZTogJzEnXG4gICAgICB9XTtcblxuICAgIC8vIHNldCBkYXRhIG9uIHNjb3JlIGlucHV0IHZpZXdcbiAgICBTY29yZUlucHV0LmRhdGEgPSAoKSA9PiAoe1xuICAgICAgbWVzc2FnZTogY29uZmlnLnRpdGxlLFxuICAgICAgc2NvcmU6ICcwJyxcbiAgICAgIGFsdGVybmF0aXZlc1xuICAgIH0pO1xuXG4gICAgLy8gc2V0IGRhdGEgb24gdGV4dCBpbnB1dCB2aWV3XG4gICAgVGV4dElucHV0LmRhdGEgPSAoKSA9PiAoe1xuICAgICAgYWx0ZXJuYXRpdmVzLFxuICAgICAgdGV4dDogJydcbiAgICB9KTtcblxuICAgIC8vIGNyYXRlIHJvdXRlclxuICAgIGNvbnN0IHJvdXRlciA9IG5ldyBSb3V0ZXIoe1xuICAgICAgbW9kZTogJ2Fic3RyYWN0JyxcbiAgICAgIHJvdXRlczogW1xuICAgICAgICB7IHBhdGg6ICcvc2NvcmUtaW5wdXQnLCBjb21wb25lbnQ6IFNjb3JlSW5wdXQgfSxcbiAgICAgICAgeyBwYXRoOiAnL3RleHQtaW5wdXQvOnNjb3JlJywgY29tcG9uZW50OiBUZXh0SW5wdXQsIHByb3BzOiB0cnVlIH0sXG4gICAgICAgIHsgcGF0aDogJy9maW5hbCcsIGNvbXBvbmVudDogRmluYWwgfSxcbiAgICAgICAgeyBwYXRoOiAnLycsIHJlZGlyZWN0OiAnL3Njb3JlLWlucHV0JyB9LFxuICAgICAgXVxuICAgIH0pO1xuXG4gICAgLy8gdHJpZ2dlciByZXNpemUgd2hlbiBzd2l0Y2hpbmcgdmlld3NcbiAgICByb3V0ZXIuYmVmb3JlRWFjaCgodG8sIGZyb20sIG5leHQpID0+IHtcbiAgICAgIG5leHQoKTtcbiAgICAgIHRoaXMudHJpZ2dlcigncmVzaXplJyk7XG4gICAgfSk7XG5cbiAgICAvLyBjcmVhdGUgdmlldyBtb2RlbFxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZ1ZSh7IHJvdXRlciB9KTtcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBsaWJyYXJ5IHRvIHdyYXBwZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkd3JhcHBlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB0aGlzLmF0dGFjaCA9ICR3cmFwcGVyID0+IHtcbiAgICAgIGNvbnN0IGlkID0gYGg1cC1mZWVkYmFjay1jb250ZW50LSR7dGhpcy5jb250ZW50SWR9YDtcbiAgICAgICR3cmFwcGVyLmdldCgwKS5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZVJvb3RFbGVtZW50KGlkKSk7XG4gICAgICB0aGlzLnZpZXdNb2RlbC4kbW91bnQoYCMke2lkfWApO1xuICAgICAgcm91dGVyLnB1c2goJ3Njb3JlLWlucHV0Jyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHJvb3QgZWxlbWVudCB0aGF0IHZ1ZSB3aWxsIHJlbmRlciBpbnRvXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jcmVhdGVSb290RWxlbWVudCA9IGlkID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGVsZW1lbnQuaWQgPSBpZDtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gJ2g1cC1mZWVkYmFjayc7XG4gICAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8cm91dGVyLXZpZXc+PC9yb3V0ZXItdmlldz4nO1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NjcmlwdHMvZmVlZGJhY2suanMiLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3N0eWxlcy9tYWluLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiPHRlbXBsYXRlPlxuICA8ZGl2IHJvbGU9XCJyZWdpb25cIiBjbGFzcz1cImg1cC1mZWVkYmFjay1maW5hbFwiPlxuICAgIDxwPldlIHB1dCBhIGxvdCBvZiBlZmZvcnQgaW50byBtYWtpbmcgSDVQIGVhc3kgdG8gdXNlIGZvciBhbGwhPC9wPlxuICAgIDxoMj5Zb3VyIGZlZWRiYWNrIGlzIGhpZ2hseSBhcHByZWNpYXRlZCE8L2gyPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBuYW1lOiAnZmluYWwtdmlldydcbiAgfVxuPC9zY3JpcHQ+XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIEZpbmFsLnZ1ZT9iNTBhYTQ5YyIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiByb2xlPVwicmVnaW9uXCIgY2xhc3M9XCJoNXAtZmVlZGJhY2stc2NvcmVcIj5cbiAgICA8aDMgY2xhc3M9XCJmZWVkYmFjay10aXRsZVwiIHYtaHRtbD1cIm1lc3NhZ2VcIj48L2gzPlxuXG4gICAgPHVsIGNsYXNzPVwiZmVlZGJhY2stc2NvcmUtaW5wdXRcIj5cbiAgICAgIDxsaSB2LWZvcj1cImFsdGVybmF0aXZlIGluIGFsdGVybmF0aXZlc1wiPlxuICAgICAgICA8ZGl2IHJvbGU9XCJidXR0b25cIiB2LWJpbmQ6Y2xhc3M9XCJhbHRlcm5hdGl2ZS5jbHNcIiB2LW9uOmNsaWNrPVwic2VuZFNjb3JlKGFsdGVybmF0aXZlKVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJmZWVkYmFjay1zY29yZS10aXRsZVwiPnt7IGFsdGVybmF0aXZlLnRpdGxlIH19PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9saT5cbiAgICA8L3VsPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBuYW1lOiAnc2NvcmUtaW5wdXQtdmlldycsXG5cbiAgICBtZXRob2RzOiB7XG4gICAgICBzZW5kU2NvcmU6IGZ1bmN0aW9uKGFsdGVybmF0aXZlKSB7XG4gICAgICAgIHRoaXMuc2NvcmUgPSBhbHRlcm5hdGl2ZS5zY29yZTtcblxuICAgICAgICB0aGlzLiRyb3V0ZXIucHVzaChgdGV4dC1pbnB1dC8ke2FsdGVybmF0aXZlLnNjb3JlfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuPC9zY3JpcHQ+XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIFNjb3JlSW5wdXQudnVlPzNmY2U4ZDBhIiwiPHRlbXBsYXRlPlxuICA8ZGl2IHJvbGU9XCJyZWdpb25cIiBjbGFzcz1cImZlZWRiYWNrLXRleHQtaW5wdXRcIj5cbiAgICA8ZGl2IGNsYXNzPVwiZnJvbS1zY29yZS1pbnB1dFwiPlxuICAgICAgPHNwYW4gY2xhc3M9XCJmZWVkYmFjay1zY29yZVwiIHYtYmluZDpjbGFzcz1cImFsdGVybmF0aXZlLmNsc1wiPjwvc3Bhbj5cbiAgICAgIDxzcGFuIGNsYXNzPVwiZmVlZGJhY2stc2NvcmUtdGl0bGVcIj57eyB0aGlzLmFsdGVybmF0aXZlLnRpdGxlIH19PC9zcGFuPlxuICAgICAgPHJvdXRlci1saW5rIHRvPVwiL3Njb3JlLWlucHV0XCI+Q2hhbmdlPC9yb3V0ZXItbGluaz5cbiAgICA8L2Rpdj5cblxuICAgIDxoMj5UaGFua3MgZm9yIHRoZSByYXRpbmchPC9oMj5cbiAgICA8cD5MZXQgdXMga25vdyBob3cgd2UgY2FuIGltcHJvdmUgeW91ciBleHBlcmllbmNlIHdpdGggdGhlIDxzdHJvbmc+RHJhZyBUZXh0PC9zdHJvbmc+IGF1dGhvcmluZyB0b29sLjwvcD5cblxuICAgIDx0ZXh0YXJlYSByb3dzPVwiNFwiIHBsYWNlaG9sZGVyPVwiWW91ciBGZWVkYmFja1wiIHYtbW9kZWw9XCJ0ZXh0XCI+PC90ZXh0YXJlYT5cbiAgICA8YnV0dG9uIHYtYmluZDpkaXNhYmxlZD1cInRleHQubGVuZ3RoIDwgMVwiIGNsYXNzPVwiYnV0dG9uIGJ1dHRvbi1wcmltYXJ5XCIgdi1vbjpjbGljaz1cInNlbmRUZXh0KHRleHQpXCI+U2VuZDwvYnV0dG9uPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBuYW1lOiAndGV4dC1pbnB1dC12aWV3JyxcbiAgICBwcm9wczogWydzY29yZSddLFxuXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGFsdGVybmF0aXZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWx0ZXJuYXRpdmVzXG4gICAgICAgICAgLmZpbHRlcihhbHRlcm5hdGl2ZSA9PiBhbHRlcm5hdGl2ZS5zY29yZSA9PT0gdGhpcy5zY29yZSlbMF07XG4gICAgICB9XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcbiAgICAgIHNlbmRUZXh0OiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdzZW5kdGV4dCcsIHRleHQpO1xuICAgICAgICAvLyBUT0RPIEZpcmUgeEFQSVxuICAgICAgICB0aGlzLiRyb3V0ZXIucHVzaCgnL2ZpbmFsJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG48L3NjcmlwdD5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gVGV4dElucHV0LnZ1ZT8zMmE3NDc5YiIsIi8qKlxuICAqIHZ1ZS1yb3V0ZXIgdjIuMi4xXG4gICogKGMpIDIwMTcgRXZhbiBZb3VcbiAgKiBAbGljZW5zZSBNSVRcbiAgKi9cbi8qICAqL1xuXG5mdW5jdGlvbiBhc3NlcnQgKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcigoXCJbdnVlLXJvdXRlcl0gXCIgKyBtZXNzYWdlKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuIChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKChcIlt2dWUtcm91dGVyXSBcIiArIG1lc3NhZ2UpKTtcbiAgfVxufVxuXG52YXIgVmlldyA9IHtcbiAgbmFtZTogJ3JvdXRlci12aWV3JyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGVmYXVsdCdcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciBwYXJlbnQgPSByZWYucGFyZW50O1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG5cbiAgICBkYXRhLnJvdXRlclZpZXcgPSB0cnVlO1xuXG4gICAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICAgIHZhciByb3V0ZSA9IHBhcmVudC4kcm91dGU7XG4gICAgdmFyIGNhY2hlID0gcGFyZW50Ll9yb3V0ZXJWaWV3Q2FjaGUgfHwgKHBhcmVudC5fcm91dGVyVmlld0NhY2hlID0ge30pO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGN1cnJlbnQgdmlldyBkZXB0aCwgYWxzbyBjaGVjayB0byBzZWUgaWYgdGhlIHRyZWVcbiAgICAvLyBoYXMgYmVlbiB0b2dnbGVkIGluYWN0aXZlIGJ1dCBrZXB0LWFsaXZlLlxuICAgIHZhciBkZXB0aCA9IDA7XG4gICAgdmFyIGluYWN0aXZlID0gZmFsc2U7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC4kdm5vZGUgJiYgcGFyZW50LiR2bm9kZS5kYXRhLnJvdXRlclZpZXcpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQuX2luYWN0aXZlKSB7XG4gICAgICAgIGluYWN0aXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBkYXRhLnJvdXRlclZpZXdEZXB0aCA9IGRlcHRoO1xuXG4gICAgLy8gcmVuZGVyIHByZXZpb3VzIHZpZXcgaWYgdGhlIHRyZWUgaXMgaW5hY3RpdmUgYW5kIGtlcHQtYWxpdmVcbiAgICBpZiAoaW5hY3RpdmUpIHtcbiAgICAgIHJldHVybiBoKGNhY2hlW25hbWVdLCBkYXRhLCBjaGlsZHJlbilcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlZCA9IHJvdXRlLm1hdGNoZWRbZGVwdGhdO1xuICAgIC8vIHJlbmRlciBlbXB0eSBub2RlIGlmIG5vIG1hdGNoZWQgcm91dGVcbiAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgIGNhY2hlW25hbWVdID0gbnVsbDtcbiAgICAgIHJldHVybiBoKClcbiAgICB9XG5cbiAgICB2YXIgY29tcG9uZW50ID0gY2FjaGVbbmFtZV0gPSBtYXRjaGVkLmNvbXBvbmVudHNbbmFtZV07XG5cbiAgICAvLyBpbmplY3QgaW5zdGFuY2UgcmVnaXN0cmF0aW9uIGhvb2tzXG4gICAgdmFyIGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gICAgaG9va3MuaW5pdCA9IGZ1bmN0aW9uICh2bm9kZSkge1xuICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB2bm9kZS5jaGlsZDtcbiAgICB9O1xuICAgIGhvb2tzLnByZXBhdGNoID0gZnVuY3Rpb24gKG9sZFZub2RlLCB2bm9kZSkge1xuICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB2bm9kZS5jaGlsZDtcbiAgICB9O1xuICAgIGhvb2tzLmRlc3Ryb3kgPSBmdW5jdGlvbiAodm5vZGUpIHtcbiAgICAgIGlmIChtYXRjaGVkLmluc3RhbmNlc1tuYW1lXSA9PT0gdm5vZGUuY2hpbGQpIHtcbiAgICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHJlc29sdmUgcHJvcHNcbiAgICBkYXRhLnByb3BzID0gcmVzb2x2ZVByb3BzKHJvdXRlLCBtYXRjaGVkLnByb3BzICYmIG1hdGNoZWQucHJvcHNbbmFtZV0pO1xuXG4gICAgcmV0dXJuIGgoY29tcG9uZW50LCBkYXRhLCBjaGlsZHJlbilcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVzb2x2ZVByb3BzIChyb3V0ZSwgY29uZmlnKSB7XG4gIHN3aXRjaCAodHlwZW9mIGNvbmZpZykge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiBjb25maWcocm91dGUpXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gY29uZmlnID8gcm91dGUucGFyYW1zIDogdW5kZWZpbmVkXG4gICAgZGVmYXVsdDpcbiAgICAgIHdhcm4oZmFsc2UsIChcInByb3BzIGluIFxcXCJcIiArIChyb3V0ZS5wYXRoKSArIFwiXFxcIiBpcyBhIFwiICsgKHR5cGVvZiBjb25maWcpICsgXCIsIGV4cGVjdGluZyBhbiBvYmplY3QsIGZ1bmN0aW9uIG9yIGJvb2xlYW4uXCIpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGVuY29kZVJlc2VydmVSRSA9IC9bIScoKSpdL2c7XG52YXIgZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7IH07XG52YXIgY29tbWFSRSA9IC8lMkMvZztcblxuLy8gZml4ZWQgZW5jb2RlVVJJQ29tcG9uZW50IHdoaWNoIGlzIG1vcmUgY29tZm9ybWFudCB0byBSRkMzOTg2OlxuLy8gLSBlc2NhcGVzIFshJygpKl1cbi8vIC0gcHJlc2VydmUgY29tbWFzXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgLnJlcGxhY2UoZW5jb2RlUmVzZXJ2ZVJFLCBlbmNvZGVSZXNlcnZlUmVwbGFjZXIpXG4gIC5yZXBsYWNlKGNvbW1hUkUsICcsJyk7IH07XG5cbnZhciBkZWNvZGUgPSBkZWNvZGVVUklDb21wb25lbnQ7XG5cbmZ1bmN0aW9uIHJlc29sdmVRdWVyeSAoXG4gIHF1ZXJ5LFxuICBleHRyYVF1ZXJ5XG4pIHtcbiAgaWYgKCBleHRyYVF1ZXJ5ID09PSB2b2lkIDAgKSBleHRyYVF1ZXJ5ID0ge307XG5cbiAgaWYgKHF1ZXJ5KSB7XG4gICAgdmFyIHBhcnNlZFF1ZXJ5O1xuICAgIHRyeSB7XG4gICAgICBwYXJzZWRRdWVyeSA9IHBhcnNlUXVlcnkocXVlcnkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihmYWxzZSwgZS5tZXNzYWdlKTtcbiAgICAgIHBhcnNlZFF1ZXJ5ID0ge307XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBleHRyYVF1ZXJ5KSB7XG4gICAgICBwYXJzZWRRdWVyeVtrZXldID0gZXh0cmFRdWVyeVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkUXVlcnlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXh0cmFRdWVyeVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlUXVlcnkgKHF1ZXJ5KSB7XG4gIHZhciByZXMgPSB7fTtcblxuICBxdWVyeSA9IHF1ZXJ5LnRyaW0oKS5yZXBsYWNlKC9eKFxcP3wjfCYpLywgJycpO1xuXG4gIGlmICghcXVlcnkpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBxdWVyeS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIHBhcnRzID0gcGFyYW0ucmVwbGFjZSgvXFwrL2csICcgJykuc3BsaXQoJz0nKTtcbiAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRzLnNoaWZ0KCkpO1xuICAgIHZhciB2YWwgPSBwYXJ0cy5sZW5ndGggPiAwXG4gICAgICA/IGRlY29kZShwYXJ0cy5qb2luKCc9JykpXG4gICAgICA6IG51bGw7XG5cbiAgICBpZiAocmVzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzW2tleV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc1trZXldKSkge1xuICAgICAgcmVzW2tleV0ucHVzaCh2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNba2V5XSA9IFtyZXNba2V5XSwgdmFsXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5UXVlcnkgKG9iaikge1xuICB2YXIgcmVzID0gb2JqID8gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2YWwgPSBvYmpba2V5XTtcblxuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVuY29kZShrZXkpXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFsLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAodmFsMikge1xuICAgICAgICBpZiAodmFsMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbDIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGUoa2V5KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsMikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQuam9pbignJicpXG4gICAgfVxuXG4gICAgcmV0dXJuIGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHZhbClcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lmxlbmd0aCA+IDA7IH0pLmpvaW4oJyYnKSA6IG51bGw7XG4gIHJldHVybiByZXMgPyAoXCI/XCIgKyByZXMpIDogJydcbn1cblxuLyogICovXG5cbnZhciB0cmFpbGluZ1NsYXNoUkUgPSAvXFwvPyQvO1xuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZSAoXG4gIHJlY29yZCxcbiAgbG9jYXRpb24sXG4gIHJlZGlyZWN0ZWRGcm9tXG4pIHtcbiAgdmFyIHJvdXRlID0ge1xuICAgIG5hbWU6IGxvY2F0aW9uLm5hbWUgfHwgKHJlY29yZCAmJiByZWNvcmQubmFtZSksXG4gICAgbWV0YTogKHJlY29yZCAmJiByZWNvcmQubWV0YSkgfHwge30sXG4gICAgcGF0aDogbG9jYXRpb24ucGF0aCB8fCAnLycsXG4gICAgaGFzaDogbG9jYXRpb24uaGFzaCB8fCAnJyxcbiAgICBxdWVyeTogbG9jYXRpb24ucXVlcnkgfHwge30sXG4gICAgcGFyYW1zOiBsb2NhdGlvbi5wYXJhbXMgfHwge30sXG4gICAgZnVsbFBhdGg6IGdldEZ1bGxQYXRoKGxvY2F0aW9uKSxcbiAgICBtYXRjaGVkOiByZWNvcmQgPyBmb3JtYXRNYXRjaChyZWNvcmQpIDogW11cbiAgfTtcbiAgaWYgKHJlZGlyZWN0ZWRGcm9tKSB7XG4gICAgcm91dGUucmVkaXJlY3RlZEZyb20gPSBnZXRGdWxsUGF0aChyZWRpcmVjdGVkRnJvbSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUocm91dGUpXG59XG5cbi8vIHRoZSBzdGFydGluZyByb3V0ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGluaXRpYWwgc3RhdGVcbnZhciBTVEFSVCA9IGNyZWF0ZVJvdXRlKG51bGwsIHtcbiAgcGF0aDogJy8nXG59KTtcblxuZnVuY3Rpb24gZm9ybWF0TWF0Y2ggKHJlY29yZCkge1xuICB2YXIgcmVzID0gW107XG4gIHdoaWxlIChyZWNvcmQpIHtcbiAgICByZXMudW5zaGlmdChyZWNvcmQpO1xuICAgIHJlY29yZCA9IHJlY29yZC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRGdWxsUGF0aCAocmVmKSB7XG4gIHZhciBwYXRoID0gcmVmLnBhdGg7XG4gIHZhciBxdWVyeSA9IHJlZi5xdWVyeTsgaWYgKCBxdWVyeSA9PT0gdm9pZCAwICkgcXVlcnkgPSB7fTtcbiAgdmFyIGhhc2ggPSByZWYuaGFzaDsgaWYgKCBoYXNoID09PSB2b2lkIDAgKSBoYXNoID0gJyc7XG5cbiAgcmV0dXJuIChwYXRoIHx8ICcvJykgKyBzdHJpbmdpZnlRdWVyeShxdWVyeSkgKyBoYXNoXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVJvdXRlIChhLCBiKSB7XG4gIGlmIChiID09PSBTVEFSVCkge1xuICAgIHJldHVybiBhID09PSBiXG4gIH0gZWxzZSBpZiAoIWIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChhLnBhdGggJiYgYi5wYXRoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGEucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJycpID09PSBiLnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcnKSAmJlxuICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5xdWVyeSwgYi5xdWVyeSlcbiAgICApXG4gIH0gZWxzZSBpZiAoYS5uYW1lICYmIGIubmFtZSkge1xuICAgIHJldHVybiAoXG4gICAgICBhLm5hbWUgPT09IGIubmFtZSAmJlxuICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5xdWVyeSwgYi5xdWVyeSkgJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5wYXJhbXMsIGIucGFyYW1zKVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBpc09iamVjdEVxdWFsIChhLCBiKSB7XG4gIGlmICggYSA9PT0gdm9pZCAwICkgYSA9IHt9O1xuICBpZiAoIGIgPT09IHZvaWQgMCApIGIgPSB7fTtcblxuICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG4gIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiBhS2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBTdHJpbmcoYVtrZXldKSA9PT0gU3RyaW5nKGJba2V5XSk7IH0pXG59XG5cbmZ1bmN0aW9uIGlzSW5jbHVkZWRSb3V0ZSAoY3VycmVudCwgdGFyZ2V0KSB7XG4gIHJldHVybiAoXG4gICAgY3VycmVudC5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnLycpLmluZGV4T2YoXG4gICAgICB0YXJnZXQucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJy8nKVxuICAgICkgPT09IDAgJiZcbiAgICAoIXRhcmdldC5oYXNoIHx8IGN1cnJlbnQuaGFzaCA9PT0gdGFyZ2V0Lmhhc2gpICYmXG4gICAgcXVlcnlJbmNsdWRlcyhjdXJyZW50LnF1ZXJ5LCB0YXJnZXQucXVlcnkpXG4gIClcbn1cblxuZnVuY3Rpb24gcXVlcnlJbmNsdWRlcyAoY3VycmVudCwgdGFyZ2V0KSB7XG4gIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICBpZiAoIShrZXkgaW4gY3VycmVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKiAgKi9cblxuLy8gd29yayBhcm91bmQgd2VpcmQgZmxvdyBidWdcbnZhciB0b1R5cGVzID0gW1N0cmluZywgT2JqZWN0XTtcbnZhciBldmVudFR5cGVzID0gW1N0cmluZywgQXJyYXldO1xuXG52YXIgTGluayA9IHtcbiAgbmFtZTogJ3JvdXRlci1saW5rJyxcbiAgcHJvcHM6IHtcbiAgICB0bzoge1xuICAgICAgdHlwZTogdG9UeXBlcyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICB0YWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdhJ1xuICAgIH0sXG4gICAgZXhhY3Q6IEJvb2xlYW4sXG4gICAgYXBwZW5kOiBCb29sZWFuLFxuICAgIHJlcGxhY2U6IEJvb2xlYW4sXG4gICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBldmVudDoge1xuICAgICAgdHlwZTogZXZlbnRUeXBlcyxcbiAgICAgIGRlZmF1bHQ6ICdjbGljaydcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcm91dGVyID0gdGhpcy4kcm91dGVyO1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy4kcm91dGU7XG4gICAgdmFyIHJlZiA9IHJvdXRlci5yZXNvbHZlKHRoaXMudG8sIGN1cnJlbnQsIHRoaXMuYXBwZW5kKTtcbiAgICB2YXIgbG9jYXRpb24gPSByZWYubG9jYXRpb247XG4gICAgdmFyIHJvdXRlID0gcmVmLnJvdXRlO1xuICAgIHZhciBocmVmID0gcmVmLmhyZWY7XG4gICAgdmFyIGNsYXNzZXMgPSB7fTtcbiAgICB2YXIgYWN0aXZlQ2xhc3MgPSB0aGlzLmFjdGl2ZUNsYXNzIHx8IHJvdXRlci5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcyB8fCAncm91dGVyLWxpbmstYWN0aXZlJztcbiAgICB2YXIgY29tcGFyZVRhcmdldCA9IGxvY2F0aW9uLnBhdGggPyBjcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbikgOiByb3V0ZTtcbiAgICBjbGFzc2VzW2FjdGl2ZUNsYXNzXSA9IHRoaXMuZXhhY3RcbiAgICAgID8gaXNTYW1lUm91dGUoY3VycmVudCwgY29tcGFyZVRhcmdldClcbiAgICAgIDogaXNJbmNsdWRlZFJvdXRlKGN1cnJlbnQsIGNvbXBhcmVUYXJnZXQpO1xuXG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGd1YXJkRXZlbnQoZSkpIHtcbiAgICAgICAgaWYgKHRoaXMkMS5yZXBsYWNlKSB7XG4gICAgICAgICAgcm91dGVyLnJlcGxhY2UobG9jYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvdXRlci5wdXNoKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb24gPSB7IGNsaWNrOiBndWFyZEV2ZW50IH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5ldmVudCkpIHtcbiAgICAgIHRoaXMuZXZlbnQuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyBvbltlXSA9IGhhbmRsZXI7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvblt0aGlzLmV2ZW50XSA9IGhhbmRsZXI7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBjbGFzczogY2xhc3Nlc1xuICAgIH07XG5cbiAgICBpZiAodGhpcy50YWcgPT09ICdhJykge1xuICAgICAgZGF0YS5vbiA9IG9uO1xuICAgICAgZGF0YS5hdHRycyA9IHsgaHJlZjogaHJlZiB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmaW5kIHRoZSBmaXJzdCA8YT4gY2hpbGQgYW5kIGFwcGx5IGxpc3RlbmVyIGFuZCBocmVmXG4gICAgICB2YXIgYSA9IGZpbmRBbmNob3IodGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgICBpZiAoYSkge1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSA8YT4gaXMgYSBzdGF0aWMgbm9kZVxuICAgICAgICBhLmlzU3RhdGljID0gZmFsc2U7XG4gICAgICAgIHZhciBleHRlbmQgPSBfVnVlLnV0aWwuZXh0ZW5kO1xuICAgICAgICB2YXIgYURhdGEgPSBhLmRhdGEgPSBleHRlbmQoe30sIGEuZGF0YSk7XG4gICAgICAgIGFEYXRhLm9uID0gb247XG4gICAgICAgIHZhciBhQXR0cnMgPSBhLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGEuZGF0YS5hdHRycyk7XG4gICAgICAgIGFBdHRycy5ocmVmID0gaHJlZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRvZXNuJ3QgaGF2ZSA8YT4gY2hpbGQsIGFwcGx5IGxpc3RlbmVyIHRvIHNlbGZcbiAgICAgICAgZGF0YS5vbiA9IG9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoKHRoaXMudGFnLCBkYXRhLCB0aGlzLiRzbG90cy5kZWZhdWx0KVxuICB9XG59O1xuXG5mdW5jdGlvbiBndWFyZEV2ZW50IChlKSB7XG4gIC8vIGRvbid0IHJlZGlyZWN0IHdpdGggY29udHJvbCBrZXlzXG4gIGlmIChlLm1ldGFLZXkgfHwgZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkpIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgd2hlbiBwcmV2ZW50RGVmYXVsdCBjYWxsZWRcbiAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCBvbiByaWdodCBjbGlja1xuICBpZiAoZS5idXR0b24gIT09IHVuZGVmaW5lZCAmJiBlLmJ1dHRvbiAhPT0gMCkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCBpZiBgdGFyZ2V0PVwiX2JsYW5rXCJgXG4gIGlmIChlLnRhcmdldCAmJiBlLnRhcmdldC5nZXRBdHRyaWJ1dGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKTtcbiAgICBpZiAoL1xcYl9ibGFua1xcYi9pLnRlc3QodGFyZ2V0KSkgeyByZXR1cm4gfVxuICB9XG4gIC8vIHRoaXMgbWF5IGJlIGEgV2VleCBldmVudCB3aGljaCBkb2Vzbid0IGhhdmUgdGhpcyBtZXRob2RcbiAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZmluZEFuY2hvciAoY2hpbGRyZW4pIHtcbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgdmFyIGNoaWxkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAnYScpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQuY2hpbGRyZW4gJiYgKGNoaWxkID0gZmluZEFuY2hvcihjaGlsZC5jaGlsZHJlbikpKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgX1Z1ZTtcblxuZnVuY3Rpb24gaW5zdGFsbCAoVnVlKSB7XG4gIGlmIChpbnN0YWxsLmluc3RhbGxlZCkgeyByZXR1cm4gfVxuICBpbnN0YWxsLmluc3RhbGxlZCA9IHRydWU7XG5cbiAgX1Z1ZSA9IFZ1ZTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRyb3V0ZXInLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkgeyByZXR1cm4gdGhpcy4kcm9vdC5fcm91dGVyIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcm91dGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkgeyByZXR1cm4gdGhpcy4kcm9vdC5fcm91dGUgfVxuICB9KTtcblxuICBWdWUubWl4aW4oe1xuICAgIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gYmVmb3JlQ3JlYXRlICgpIHtcbiAgICAgIGlmICh0aGlzLiRvcHRpb25zLnJvdXRlcikge1xuICAgICAgICB0aGlzLl9yb3V0ZXIgPSB0aGlzLiRvcHRpb25zLnJvdXRlcjtcbiAgICAgICAgdGhpcy5fcm91dGVyLmluaXQodGhpcyk7XG4gICAgICAgIFZ1ZS51dGlsLmRlZmluZVJlYWN0aXZlKHRoaXMsICdfcm91dGUnLCB0aGlzLl9yb3V0ZXIuaGlzdG9yeS5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIFZ1ZS5jb21wb25lbnQoJ3JvdXRlci12aWV3JywgVmlldyk7XG4gIFZ1ZS5jb21wb25lbnQoJ3JvdXRlci1saW5rJywgTGluayk7XG5cbiAgdmFyIHN0cmF0cyA9IFZ1ZS5jb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuICAvLyB1c2UgdGhlIHNhbWUgaG9vayBtZXJnaW5nIHN0cmF0ZWd5IGZvciByb3V0ZSBob29rc1xuICBzdHJhdHMuYmVmb3JlUm91dGVFbnRlciA9IHN0cmF0cy5iZWZvcmVSb3V0ZUxlYXZlID0gc3RyYXRzLmNyZWF0ZWQ7XG59XG5cbi8qICAqL1xuXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlUGF0aCAoXG4gIHJlbGF0aXZlLFxuICBiYXNlLFxuICBhcHBlbmRcbikge1xuICBpZiAocmVsYXRpdmUuY2hhckF0KDApID09PSAnLycpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5jaGFyQXQoMCkgPT09ICc/JyB8fCByZWxhdGl2ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIHJldHVybiBiYXNlICsgcmVsYXRpdmVcbiAgfVxuXG4gIHZhciBzdGFjayA9IGJhc2Uuc3BsaXQoJy8nKTtcblxuICAvLyByZW1vdmUgdHJhaWxpbmcgc2VnbWVudCBpZjpcbiAgLy8gLSBub3QgYXBwZW5kaW5nXG4gIC8vIC0gYXBwZW5kaW5nIHRvIHRyYWlsaW5nIHNsYXNoIChsYXN0IHNlZ21lbnQgaXMgZW1wdHkpXG4gIGlmICghYXBwZW5kIHx8ICFzdGFja1tzdGFjay5sZW5ndGggLSAxXSkge1xuICAgIHN0YWNrLnBvcCgpO1xuICB9XG5cbiAgLy8gcmVzb2x2ZSByZWxhdGl2ZSBwYXRoXG4gIHZhciBzZWdtZW50cyA9IHJlbGF0aXZlLnJlcGxhY2UoL15cXC8vLCAnJykuc3BsaXQoJy8nKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgaWYgKHNlZ21lbnQgPT09ICcuJykge1xuICAgICAgY29udGludWVcbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgPT09ICcuLicpIHtcbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFjay5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVuc3VyZSBsZWFkaW5nIHNsYXNoXG4gIGlmIChzdGFja1swXSAhPT0gJycpIHtcbiAgICBzdGFjay51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIHJldHVybiBzdGFjay5qb2luKCcvJylcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIHZhciBoYXNoID0gJyc7XG4gIHZhciBxdWVyeSA9ICcnO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgaGFzaCA9IHBhdGguc2xpY2UoaGFzaEluZGV4KTtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKTtcbiAgaWYgKHF1ZXJ5SW5kZXggPj0gMCkge1xuICAgIHF1ZXJ5ID0gcGF0aC5zbGljZShxdWVyeUluZGV4ICsgMSk7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgcXVlcnlJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGg6IHBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGhhc2g6IGhhc2hcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhblBhdGggKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwvXFwvL2csICcvJylcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlTWFwIChcbiAgcm91dGVzLFxuICBvbGRQYXRoTWFwLFxuICBvbGROYW1lTWFwXG4pIHtcbiAgdmFyIHBhdGhNYXAgPSBvbGRQYXRoTWFwIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBuYW1lTWFwID0gb2xkTmFtZU1hcCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJvdXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgIGFkZFJvdXRlUmVjb3JkKHBhdGhNYXAsIG5hbWVNYXAsIHJvdXRlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoTWFwOiBwYXRoTWFwLFxuICAgIG5hbWVNYXA6IG5hbWVNYXBcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRSb3V0ZVJlY29yZCAoXG4gIHBhdGhNYXAsXG4gIG5hbWVNYXAsXG4gIHJvdXRlLFxuICBwYXJlbnQsXG4gIG1hdGNoQXNcbikge1xuICB2YXIgcGF0aCA9IHJvdXRlLnBhdGg7XG4gIHZhciBuYW1lID0gcm91dGUubmFtZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQocGF0aCAhPSBudWxsLCBcIlxcXCJwYXRoXFxcIiBpcyByZXF1aXJlZCBpbiBhIHJvdXRlIGNvbmZpZ3VyYXRpb24uXCIpO1xuICAgIGFzc2VydChcbiAgICAgIHR5cGVvZiByb3V0ZS5jb21wb25lbnQgIT09ICdzdHJpbmcnLFxuICAgICAgXCJyb3V0ZSBjb25maWcgXFxcImNvbXBvbmVudFxcXCIgZm9yIHBhdGg6IFwiICsgKFN0cmluZyhwYXRoIHx8IG5hbWUpKSArIFwiIGNhbm5vdCBiZSBhIFwiICtcbiAgICAgIFwic3RyaW5nIGlkLiBVc2UgYW4gYWN0dWFsIGNvbXBvbmVudCBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgfVxuXG4gIHZhciByZWNvcmQgPSB7XG4gICAgcGF0aDogbm9ybWFsaXplUGF0aChwYXRoLCBwYXJlbnQpLFxuICAgIGNvbXBvbmVudHM6IHJvdXRlLmNvbXBvbmVudHMgfHwgeyBkZWZhdWx0OiByb3V0ZS5jb21wb25lbnQgfSxcbiAgICBpbnN0YW5jZXM6IHt9LFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgbWF0Y2hBczogbWF0Y2hBcyxcbiAgICByZWRpcmVjdDogcm91dGUucmVkaXJlY3QsXG4gICAgYmVmb3JlRW50ZXI6IHJvdXRlLmJlZm9yZUVudGVyLFxuICAgIG1ldGE6IHJvdXRlLm1ldGEgfHwge30sXG4gICAgcHJvcHM6IHJvdXRlLnByb3BzID09IG51bGxcbiAgICAgID8ge31cbiAgICAgIDogcm91dGUuY29tcG9uZW50c1xuICAgICAgICA/IHJvdXRlLnByb3BzXG4gICAgICAgIDogeyBkZWZhdWx0OiByb3V0ZS5wcm9wcyB9XG4gIH07XG5cbiAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgLy8gV2FybiBpZiByb3V0ZSBpcyBuYW1lZCBhbmQgaGFzIGEgZGVmYXVsdCBjaGlsZCByb3V0ZS5cbiAgICAvLyBJZiB1c2VycyBuYXZpZ2F0ZSB0byB0aGlzIHJvdXRlIGJ5IG5hbWUsIHRoZSBkZWZhdWx0IGNoaWxkIHdpbGxcbiAgICAvLyBub3QgYmUgcmVuZGVyZWQgKEdIIElzc3VlICM2MjkpXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChyb3V0ZS5uYW1lICYmIHJvdXRlLmNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiAvXlxcLz8kLy50ZXN0KGNoaWxkLnBhdGgpOyB9KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiTmFtZWQgUm91dGUgJ1wiICsgKHJvdXRlLm5hbWUpICsgXCInIGhhcyBhIGRlZmF1bHQgY2hpbGQgcm91dGUuIFwiICtcbiAgICAgICAgICBcIldoZW4gbmF2aWdhdGluZyB0byB0aGlzIG5hbWVkIHJvdXRlICg6dG89XFxcIntuYW1lOiAnXCIgKyAocm91dGUubmFtZSkgKyBcIidcXFwiKSwgXCIgK1xuICAgICAgICAgIFwidGhlIGRlZmF1bHQgY2hpbGQgcm91dGUgd2lsbCBub3QgYmUgcmVuZGVyZWQuIFJlbW92ZSB0aGUgbmFtZSBmcm9tIFwiICtcbiAgICAgICAgICBcInRoaXMgcm91dGUgYW5kIHVzZSB0aGUgbmFtZSBvZiB0aGUgZGVmYXVsdCBjaGlsZCByb3V0ZSBmb3IgbmFtZWQgXCIgK1xuICAgICAgICAgIFwibGlua3MgaW5zdGVhZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByb3V0ZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdmFyIGNoaWxkTWF0Y2hBcyA9IG1hdGNoQXNcbiAgICAgICAgPyBjbGVhblBhdGgoKG1hdGNoQXMgKyBcIi9cIiArIChjaGlsZC5wYXRoKSkpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgYWRkUm91dGVSZWNvcmQocGF0aE1hcCwgbmFtZU1hcCwgY2hpbGQsIHJlY29yZCwgY2hpbGRNYXRjaEFzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyb3V0ZS5hbGlhcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocm91dGUuYWxpYXMpKSB7XG4gICAgICByb3V0ZS5hbGlhcy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICB2YXIgYWxpYXNSb3V0ZSA9IHtcbiAgICAgICAgICBwYXRoOiBhbGlhcyxcbiAgICAgICAgICBjaGlsZHJlbjogcm91dGUuY2hpbGRyZW5cbiAgICAgICAgfTtcbiAgICAgICAgYWRkUm91dGVSZWNvcmQocGF0aE1hcCwgbmFtZU1hcCwgYWxpYXNSb3V0ZSwgcGFyZW50LCByZWNvcmQucGF0aCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFsaWFzUm91dGUgPSB7XG4gICAgICAgIHBhdGg6IHJvdXRlLmFsaWFzLFxuICAgICAgICBjaGlsZHJlbjogcm91dGUuY2hpbGRyZW5cbiAgICAgIH07XG4gICAgICBhZGRSb3V0ZVJlY29yZChwYXRoTWFwLCBuYW1lTWFwLCBhbGlhc1JvdXRlLCBwYXJlbnQsIHJlY29yZC5wYXRoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXBhdGhNYXBbcmVjb3JkLnBhdGhdKSB7XG4gICAgcGF0aE1hcFtyZWNvcmQucGF0aF0gPSByZWNvcmQ7XG4gIH1cblxuICBpZiAobmFtZSkge1xuICAgIGlmICghbmFtZU1hcFtuYW1lXSkge1xuICAgICAgbmFtZU1hcFtuYW1lXSA9IHJlY29yZDtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIW1hdGNoQXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcIkR1cGxpY2F0ZSBuYW1lZCByb3V0ZXMgZGVmaW5pdGlvbjogXCIgK1xuICAgICAgICBcInsgbmFtZTogXFxcIlwiICsgbmFtZSArIFwiXFxcIiwgcGF0aDogXFxcIlwiICsgKHJlY29yZC5wYXRoKSArIFwiXFxcIiB9XCJcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGggKHBhdGgsIHBhcmVudCkge1xuICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICBpZiAocGF0aFswXSA9PT0gJy8nKSB7IHJldHVybiBwYXRoIH1cbiAgaWYgKHBhcmVudCA9PSBudWxsKSB7IHJldHVybiBwYXRoIH1cbiAgcmV0dXJuIGNsZWFuUGF0aCgoKHBhcmVudC5wYXRoKSArIFwiL1wiICsgcGF0aCkpXG59XG5cbnZhciBpbmRleCQxID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudmFyIGlzYXJyYXkgPSBpbmRleCQxO1xuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xudmFyIGluZGV4ID0gcGF0aFRvUmVnZXhwO1xudmFyIHBhcnNlXzEgPSBwYXJzZTtcbnZhciBjb21waWxlXzEgPSBjb21waWxlO1xudmFyIHRva2Vuc1RvRnVuY3Rpb25fMSA9IHRva2Vuc1RvRnVuY3Rpb247XG52YXIgdG9rZW5zVG9SZWdFeHBfMSA9IHRva2Vuc1RvUmVnRXhwO1xuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiICA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAvLyBcIi8qXCIgICAgICAgICAgICA9PiBbXCIvXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCIqXCJdXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcbl0uam9pbignfCcpLCAnZycpO1xuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnNcbiAqIEByZXR1cm4geyFBcnJheX1cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHN0ciwgb3B0aW9ucykge1xuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBrZXkgPSAwO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgcGF0aCA9ICcnO1xuICB2YXIgZGVmYXVsdERlbGltaXRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nO1xuICB2YXIgcmVzO1xuXG4gIHdoaWxlICgocmVzID0gUEFUSF9SRUdFWFAuZXhlYyhzdHIpKSAhPSBudWxsKSB7XG4gICAgdmFyIG0gPSByZXNbMF07XG4gICAgdmFyIGVzY2FwZWQgPSByZXNbMV07XG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleDtcbiAgICBwYXRoICs9IHN0ci5zbGljZShpbmRleCwgb2Zmc2V0KTtcbiAgICBpbmRleCA9IG9mZnNldCArIG0ubGVuZ3RoO1xuXG4gICAgLy8gSWdub3JlIGFscmVhZHkgZXNjYXBlZCBzZXF1ZW5jZXMuXG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBzdHJbaW5kZXhdO1xuICAgIHZhciBwcmVmaXggPSByZXNbMl07XG4gICAgdmFyIG5hbWUgPSByZXNbM107XG4gICAgdmFyIGNhcHR1cmUgPSByZXNbNF07XG4gICAgdmFyIGdyb3VwID0gcmVzWzVdO1xuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XTtcbiAgICB2YXIgYXN0ZXJpc2sgPSByZXNbN107XG5cbiAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHBhdGggb250byB0aGUgdG9rZW5zLlxuICAgIGlmIChwYXRoKSB7XG4gICAgICB0b2tlbnMucHVzaChwYXRoKTtcbiAgICAgIHBhdGggPSAnJztcbiAgICB9XG5cbiAgICB2YXIgcGFydGlhbCA9IHByZWZpeCAhPSBudWxsICYmIG5leHQgIT0gbnVsbCAmJiBuZXh0ICE9PSBwcmVmaXg7XG4gICAgdmFyIHJlcGVhdCA9IG1vZGlmaWVyID09PSAnKycgfHwgbW9kaWZpZXIgPT09ICcqJztcbiAgICB2YXIgb3B0aW9uYWwgPSBtb2RpZmllciA9PT0gJz8nIHx8IG1vZGlmaWVyID09PSAnKic7XG4gICAgdmFyIGRlbGltaXRlciA9IHJlc1syXSB8fCBkZWZhdWx0RGVsaW1pdGVyO1xuICAgIHZhciBwYXR0ZXJuID0gY2FwdHVyZSB8fCBncm91cDtcblxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICBwcmVmaXg6IHByZWZpeCB8fCAnJyxcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgYXN0ZXJpc2s6ICEhYXN0ZXJpc2ssXG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuID8gZXNjYXBlR3JvdXAocGF0dGVybikgOiAoYXN0ZXJpc2sgPyAnLionIDogJ1teJyArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpICsgJ10rPycpXG4gICAgfSk7XG4gIH1cblxuICAvLyBNYXRjaCBhbnkgY2hhcmFjdGVycyBzdGlsbCByZW1haW5pbmcuXG4gIGlmIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBwYXRoICs9IHN0ci5zdWJzdHIoaW5kZXgpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHBhdGggZXhpc3RzLCBwdXNoIGl0IG9udG8gdGhlIGVuZC5cbiAgaWYgKHBhdGgpIHtcbiAgICB0b2tlbnMucHVzaChwYXRoKTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucykpXG59XG5cbi8qKlxuICogUHJldHRpZXIgZW5jb2Rpbmcgb2YgVVJJIHBhdGggc2VnbWVudHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvW1xcLz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgdGhlIGFzdGVyaXNrIHBhcmFtZXRlci4gU2ltaWxhciB0byBgcHJldHR5YCwgYnV0IGFsbG93cyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zKSB7XG4gIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKTtcblxuICAvLyBDb21waWxlIGFsbCB0aGUgcGF0dGVybnMgYmVmb3JlIGNvbXBpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgdG9rZW5zW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgbWF0Y2hlc1tpXSA9IG5ldyBSZWdFeHAoJ14oPzonICsgdG9rZW5zW2ldLnBhdHRlcm4gKyAnKSQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuICAgIHZhciBwYXRoID0gJyc7XG4gICAgdmFyIGRhdGEgPSBvYmogfHwge307XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBlbmNvZGUgPSBvcHRpb25zLnByZXR0eSA/IGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSA6IGVuY29kZVVSSUNvbXBvbmVudDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhdGggKz0gdG9rZW47XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gZGF0YVt0b2tlbi5uYW1lXTtcbiAgICAgIHZhciBzZWdtZW50O1xuXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAvLyBQcmVwZW5kIHBhcnRpYWwgc2VnbWVudCBwcmVmaXhlcy5cbiAgICAgICAgICBpZiAodG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIGJlIGRlZmluZWQnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc2FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAoIXRva2VuLnJlcGVhdCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IHJlcGVhdCwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ2AnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgYmUgZW1wdHknKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzZWdtZW50ID0gZW5jb2RlKHZhbHVlW2pdKTtcblxuICAgICAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhbGwgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeShzZWdtZW50KSArICdgJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoICs9IChqID09PSAwID8gdG9rZW4ucHJlZml4IDogdG9rZW4uZGVsaW1pdGVyKSArIHNlZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBzZWdtZW50ID0gdG9rZW4uYXN0ZXJpc2sgPyBlbmNvZGVBc3Rlcmlzayh2YWx1ZSkgOiBlbmNvZGUodmFsdWUpO1xuXG4gICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBcIicgKyBzZWdtZW50ICsgJ1wiJylcbiAgICAgIH1cblxuICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoXG4gIH1cbn1cblxuLyoqXG4gKiBFc2NhcGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXxcXC9cXFxcXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XG4gIHJlLmtleXMgPSBrZXlzO1xuICByZXR1cm4gcmVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmbGFncyAob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJ1xufVxuXG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cCAocGF0aCwga2V5cykge1xuICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZyk7XG5cbiAgaWYgKGdyb3Vwcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiBpLFxuICAgICAgICBwcmVmaXg6IG51bGwsXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxuICAgICAgICBwYXJ0aWFsOiBmYWxzZSxcbiAgICAgICAgYXN0ZXJpc2s6IGZhbHNlLFxuICAgICAgICBwYXR0ZXJuOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChwYXRoVG9SZWdleHAocGF0aFtpXSwga2V5cywgb3B0aW9ucykuc291cmNlKTtcbiAgfVxuXG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSk7XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb1JlZ0V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gICAgICAgICAgdG9rZW5zXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19IGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKTtcbiAgICBrZXlzID0gW107XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2U7XG4gIHZhciByb3V0ZSA9ICcnO1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyh0b2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcodG9rZW4ucHJlZml4KTtcbiAgICAgIHZhciBjYXB0dXJlID0gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJyknO1xuXG4gICAgICBrZXlzLnB1c2godG9rZW4pO1xuXG4gICAgICBpZiAodG9rZW4ucmVwZWF0KSB7XG4gICAgICAgIGNhcHR1cmUgKz0gJyg/OicgKyBwcmVmaXggKyBjYXB0dXJlICsgJykqJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgIGlmICghdG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpPyc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknO1xuICAgICAgfVxuXG4gICAgICByb3V0ZSArPSBjYXB0dXJlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWxpbWl0ZXIgPSBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nKTtcbiAgdmFyIGVuZHNXaXRoRGVsaW1pdGVyID0gcm91dGUuc2xpY2UoLWRlbGltaXRlci5sZW5ndGgpID09PSBkZWxpbWl0ZXI7XG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoRGVsaW1pdGVyID8gcm91dGUuc2xpY2UoMCwgLWRlbGltaXRlci5sZW5ndGgpIDogcm91dGUpICsgJyg/OicgKyBkZWxpbWl0ZXIgKyAnKD89JCkpPyc7XG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgcm91dGUgKz0gJyQnO1xuICB9IGVsc2Uge1xuICAgIC8vIEluIG5vbi1lbmRpbmcgbW9kZSwgd2UgbmVlZCB0aGUgY2FwdHVyaW5nIGdyb3VwcyB0byBtYXRjaCBhcyBtdWNoIGFzXG4gICAgLy8gcG9zc2libGUgYnkgdXNpbmcgYSBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cbiAgICByb3V0ZSArPSBzdHJpY3QgJiYgZW5kc1dpdGhEZWxpbWl0ZXIgPyAnJyA6ICcoPz0nICsgZGVsaW1pdGVyICsgJ3wkKSc7XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoc3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucyk7XG4gICAga2V5cyA9IFtdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSlcbiAgfVxuXG4gIGlmIChpc2FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAoLyoqIEB0eXBlIHshQXJyYXl9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdUb1JlZ2V4cCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxufVxuXG5pbmRleC5wYXJzZSA9IHBhcnNlXzE7XG5pbmRleC5jb21waWxlID0gY29tcGlsZV8xO1xuaW5kZXgudG9rZW5zVG9GdW5jdGlvbiA9IHRva2Vuc1RvRnVuY3Rpb25fMTtcbmluZGV4LnRva2Vuc1RvUmVnRXhwID0gdG9rZW5zVG9SZWdFeHBfMTtcblxuLyogICovXG5cbnZhciByZWdleHBDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIGdldFJvdXRlUmVnZXggKHBhdGgpIHtcbiAgdmFyIGhpdCA9IHJlZ2V4cENhY2hlW3BhdGhdO1xuICB2YXIga2V5cywgcmVnZXhwO1xuXG4gIGlmIChoaXQpIHtcbiAgICBrZXlzID0gaGl0LmtleXM7XG4gICAgcmVnZXhwID0gaGl0LnJlZ2V4cDtcbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gW107XG4gICAgcmVnZXhwID0gaW5kZXgocGF0aCwga2V5cyk7XG4gICAgcmVnZXhwQ2FjaGVbcGF0aF0gPSB7IGtleXM6IGtleXMsIHJlZ2V4cDogcmVnZXhwIH07XG4gIH1cblxuICByZXR1cm4geyBrZXlzOiBrZXlzLCByZWdleHA6IHJlZ2V4cCB9XG59XG5cbnZhciByZWdleHBDb21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBmaWxsUGFyYW1zIChcbiAgcGF0aCxcbiAgcGFyYW1zLFxuICByb3V0ZU1zZ1xuKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZpbGxlciA9XG4gICAgICByZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gfHxcbiAgICAgIChyZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gPSBpbmRleC5jb21waWxlKHBhdGgpKTtcbiAgICByZXR1cm4gZmlsbGVyKHBhcmFtcyB8fCB7fSwgeyBwcmV0dHk6IHRydWUgfSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKGZhbHNlLCAoXCJtaXNzaW5nIHBhcmFtIGZvciBcIiArIHJvdXRlTXNnICsgXCI6IFwiICsgKGUubWVzc2FnZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2F0aW9uIChcbiAgcmF3LFxuICBjdXJyZW50LFxuICBhcHBlbmRcbikge1xuICB2YXIgbmV4dCA9IHR5cGVvZiByYXcgPT09ICdzdHJpbmcnID8geyBwYXRoOiByYXcgfSA6IHJhdztcbiAgLy8gbmFtZWQgdGFyZ2V0XG4gIGlmIChuZXh0Lm5hbWUgfHwgbmV4dC5fbm9ybWFsaXplZCkge1xuICAgIHJldHVybiBuZXh0XG4gIH1cblxuICAvLyByZWxhdGl2ZSBwYXJhbXNcbiAgaWYgKCFuZXh0LnBhdGggJiYgbmV4dC5wYXJhbXMgJiYgY3VycmVudCkge1xuICAgIG5leHQgPSBhc3NpZ24oe30sIG5leHQpO1xuICAgIG5leHQuX25vcm1hbGl6ZWQgPSB0cnVlO1xuICAgIHZhciBwYXJhbXMgPSBhc3NpZ24oYXNzaWduKHt9LCBjdXJyZW50LnBhcmFtcyksIG5leHQucGFyYW1zKTtcbiAgICBpZiAoY3VycmVudC5uYW1lKSB7XG4gICAgICBuZXh0Lm5hbWUgPSBjdXJyZW50Lm5hbWU7XG4gICAgICBuZXh0LnBhcmFtcyA9IHBhcmFtcztcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQubWF0Y2hlZCkge1xuICAgICAgdmFyIHJhd1BhdGggPSBjdXJyZW50Lm1hdGNoZWRbY3VycmVudC5tYXRjaGVkLmxlbmd0aCAtIDFdLnBhdGg7XG4gICAgICBuZXh0LnBhdGggPSBmaWxsUGFyYW1zKHJhd1BhdGgsIHBhcmFtcywgKFwicGF0aCBcIiArIChjdXJyZW50LnBhdGgpKSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKGZhbHNlLCBcInJlbGF0aXZlIHBhcmFtcyBuYXZpZ2F0aW9uIHJlcXVpcmVzIGEgY3VycmVudCByb3V0ZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBuZXh0XG4gIH1cblxuICB2YXIgcGFyc2VkUGF0aCA9IHBhcnNlUGF0aChuZXh0LnBhdGggfHwgJycpO1xuICB2YXIgYmFzZVBhdGggPSAoY3VycmVudCAmJiBjdXJyZW50LnBhdGgpIHx8ICcvJztcbiAgdmFyIHBhdGggPSBwYXJzZWRQYXRoLnBhdGhcbiAgICA/IHJlc29sdmVQYXRoKHBhcnNlZFBhdGgucGF0aCwgYmFzZVBhdGgsIGFwcGVuZCB8fCBuZXh0LmFwcGVuZClcbiAgICA6IChjdXJyZW50ICYmIGN1cnJlbnQucGF0aCkgfHwgJy8nO1xuICB2YXIgcXVlcnkgPSByZXNvbHZlUXVlcnkocGFyc2VkUGF0aC5xdWVyeSwgbmV4dC5xdWVyeSk7XG4gIHZhciBoYXNoID0gbmV4dC5oYXNoIHx8IHBhcnNlZFBhdGguaGFzaDtcbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykge1xuICAgIGhhc2ggPSBcIiNcIiArIGhhc2g7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgIHBhdGg6IHBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGhhc2g6IGhhc2hcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ24gKGEsIGIpIHtcbiAgZm9yICh2YXIga2V5IGluIGIpIHtcbiAgICBhW2tleV0gPSBiW2tleV07XG4gIH1cbiAgcmV0dXJuIGFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoZXIgKHJvdXRlcykge1xuICB2YXIgcmVmID0gY3JlYXRlUm91dGVNYXAocm91dGVzKTtcbiAgdmFyIHBhdGhNYXAgPSByZWYucGF0aE1hcDtcbiAgdmFyIG5hbWVNYXAgPSByZWYubmFtZU1hcDtcblxuICBmdW5jdGlvbiBhZGRSb3V0ZXMgKHJvdXRlcykge1xuICAgIGNyZWF0ZVJvdXRlTWFwKHJvdXRlcywgcGF0aE1hcCwgbmFtZU1hcCk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaCAoXG4gICAgcmF3LFxuICAgIGN1cnJlbnRSb3V0ZSxcbiAgICByZWRpcmVjdGVkRnJvbVxuICApIHtcbiAgICB2YXIgbG9jYXRpb24gPSBub3JtYWxpemVMb2NhdGlvbihyYXcsIGN1cnJlbnRSb3V0ZSk7XG4gICAgdmFyIG5hbWUgPSBsb2NhdGlvbi5uYW1lO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHZhciByZWNvcmQgPSBuYW1lTWFwW25hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihyZWNvcmQsIChcIlJvdXRlIHdpdGggbmFtZSAnXCIgKyBuYW1lICsgXCInIGRvZXMgbm90IGV4aXN0XCIpKTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJhbU5hbWVzID0gZ2V0Um91dGVSZWdleChyZWNvcmQucGF0aCkua2V5c1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICFrZXkub3B0aW9uYWw7IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5Lm5hbWU7IH0pO1xuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uLnBhcmFtcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgbG9jYXRpb24ucGFyYW1zID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50Um91dGUgJiYgdHlwZW9mIGN1cnJlbnRSb3V0ZS5wYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjdXJyZW50Um91dGUucGFyYW1zKSB7XG4gICAgICAgICAgaWYgKCEoa2V5IGluIGxvY2F0aW9uLnBhcmFtcykgJiYgcGFyYW1OYW1lcy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICAgICAgbG9jYXRpb24ucGFyYW1zW2tleV0gPSBjdXJyZW50Um91dGUucGFyYW1zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgbG9jYXRpb24ucGF0aCA9IGZpbGxQYXJhbXMocmVjb3JkLnBhdGgsIGxvY2F0aW9uLnBhcmFtcywgKFwibmFtZWQgcm91dGUgXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSk7XG4gICAgICAgIHJldHVybiBfY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRoKSB7XG4gICAgICBsb2NhdGlvbi5wYXJhbXMgPSB7fTtcbiAgICAgIGZvciAodmFyIHBhdGggaW4gcGF0aE1hcCkge1xuICAgICAgICBpZiAobWF0Y2hSb3V0ZShwYXRoLCBsb2NhdGlvbi5wYXJhbXMsIGxvY2F0aW9uLnBhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShwYXRoTWFwW3BhdGhdLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbm8gbWF0Y2hcbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVkaXJlY3QgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvblxuICApIHtcbiAgICB2YXIgb3JpZ2luYWxSZWRpcmVjdCA9IHJlY29yZC5yZWRpcmVjdDtcbiAgICB2YXIgcmVkaXJlY3QgPSB0eXBlb2Ygb3JpZ2luYWxSZWRpcmVjdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IG9yaWdpbmFsUmVkaXJlY3QoY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbikpXG4gICAgICAgIDogb3JpZ2luYWxSZWRpcmVjdDtcblxuICAgIGlmICh0eXBlb2YgcmVkaXJlY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZWRpcmVjdCA9IHsgcGF0aDogcmVkaXJlY3QgfTtcbiAgICB9XG5cbiAgICBpZiAoIXJlZGlyZWN0IHx8IHR5cGVvZiByZWRpcmVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgZmFsc2UsIChcImludmFsaWQgcmVkaXJlY3Qgb3B0aW9uOiBcIiArIChKU09OLnN0cmluZ2lmeShyZWRpcmVjdCkpKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gICAgfVxuXG4gICAgdmFyIHJlID0gcmVkaXJlY3Q7XG4gICAgdmFyIG5hbWUgPSByZS5uYW1lO1xuICAgIHZhciBwYXRoID0gcmUucGF0aDtcbiAgICB2YXIgcXVlcnkgPSBsb2NhdGlvbi5xdWVyeTtcbiAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gICAgdmFyIHBhcmFtcyA9IGxvY2F0aW9uLnBhcmFtcztcbiAgICBxdWVyeSA9IHJlLmhhc093blByb3BlcnR5KCdxdWVyeScpID8gcmUucXVlcnkgOiBxdWVyeTtcbiAgICBoYXNoID0gcmUuaGFzT3duUHJvcGVydHkoJ2hhc2gnKSA/IHJlLmhhc2ggOiBoYXNoO1xuICAgIHBhcmFtcyA9IHJlLmhhc093blByb3BlcnR5KCdwYXJhbXMnKSA/IHJlLnBhcmFtcyA6IHBhcmFtcztcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICAvLyByZXNvbHZlZCBuYW1lZCBkaXJlY3RcbiAgICAgIHZhciB0YXJnZXRSZWNvcmQgPSBuYW1lTWFwW25hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KHRhcmdldFJlY29yZCwgKFwicmVkaXJlY3QgZmFpbGVkOiBuYW1lZCByb3V0ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIG5vdCBmb3VuZC5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoKHtcbiAgICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgIH0sIHVuZGVmaW5lZCwgbG9jYXRpb24pXG4gICAgfSBlbHNlIGlmIChwYXRoKSB7XG4gICAgICAvLyAxLiByZXNvbHZlIHJlbGF0aXZlIHJlZGlyZWN0XG4gICAgICB2YXIgcmF3UGF0aCA9IHJlc29sdmVSZWNvcmRQYXRoKHBhdGgsIHJlY29yZCk7XG4gICAgICAvLyAyLiByZXNvbHZlIHBhcmFtc1xuICAgICAgdmFyIHJlc29sdmVkUGF0aCA9IGZpbGxQYXJhbXMocmF3UGF0aCwgcGFyYW1zLCAoXCJyZWRpcmVjdCByb3V0ZSB3aXRoIHBhdGggXFxcIlwiICsgcmF3UGF0aCArIFwiXFxcIlwiKSk7XG4gICAgICAvLyAzLiByZW1hdGNoIHdpdGggZXhpc3RpbmcgcXVlcnkgYW5kIGhhc2hcbiAgICAgIHJldHVybiBtYXRjaCh7XG4gICAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICBwYXRoOiByZXNvbHZlZFBhdGgsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaFxuICAgICAgfSwgdW5kZWZpbmVkLCBsb2NhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihmYWxzZSwgKFwiaW52YWxpZCByZWRpcmVjdCBvcHRpb246IFwiICsgKEpTT04uc3RyaW5naWZ5KHJlZGlyZWN0KSkpKTtcbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWxpYXMgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvbixcbiAgICBtYXRjaEFzXG4gICkge1xuICAgIHZhciBhbGlhc2VkUGF0aCA9IGZpbGxQYXJhbXMobWF0Y2hBcywgbG9jYXRpb24ucGFyYW1zLCAoXCJhbGlhc2VkIHJvdXRlIHdpdGggcGF0aCBcXFwiXCIgKyBtYXRjaEFzICsgXCJcXFwiXCIpKTtcbiAgICB2YXIgYWxpYXNlZE1hdGNoID0gbWF0Y2goe1xuICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICBwYXRoOiBhbGlhc2VkUGF0aFxuICAgIH0pO1xuICAgIGlmIChhbGlhc2VkTWF0Y2gpIHtcbiAgICAgIHZhciBtYXRjaGVkID0gYWxpYXNlZE1hdGNoLm1hdGNoZWQ7XG4gICAgICB2YXIgYWxpYXNlZFJlY29yZCA9IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXTtcbiAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IGFsaWFzZWRNYXRjaC5wYXJhbXM7XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKGFsaWFzZWRSZWNvcmQsIGxvY2F0aW9uKVxuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZVJvdXRlIChcbiAgICByZWNvcmQsXG4gICAgbG9jYXRpb24sXG4gICAgcmVkaXJlY3RlZEZyb21cbiAgKSB7XG4gICAgaWYgKHJlY29yZCAmJiByZWNvcmQucmVkaXJlY3QpIHtcbiAgICAgIHJldHVybiByZWRpcmVjdChyZWNvcmQsIHJlZGlyZWN0ZWRGcm9tIHx8IGxvY2F0aW9uKVxuICAgIH1cbiAgICBpZiAocmVjb3JkICYmIHJlY29yZC5tYXRjaEFzKSB7XG4gICAgICByZXR1cm4gYWxpYXMocmVjb3JkLCBsb2NhdGlvbiwgcmVjb3JkLm1hdGNoQXMpXG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSlcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWF0Y2g6IG1hdGNoLFxuICAgIGFkZFJvdXRlczogYWRkUm91dGVzXG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hSb3V0ZSAoXG4gIHBhdGgsXG4gIHBhcmFtcyxcbiAgcGF0aG5hbWVcbikge1xuICB2YXIgcmVmID0gZ2V0Um91dGVSZWdleChwYXRoKTtcbiAgdmFyIHJlZ2V4cCA9IHJlZi5yZWdleHA7XG4gIHZhciBrZXlzID0gcmVmLmtleXM7XG4gIHZhciBtID0gcGF0aG5hbWUubWF0Y2gocmVnZXhwKTtcblxuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBtLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaSAtIDFdO1xuICAgIHZhciB2YWwgPSB0eXBlb2YgbVtpXSA9PT0gJ3N0cmluZycgPyBkZWNvZGVVUklDb21wb25lbnQobVtpXSkgOiBtW2ldO1xuICAgIGlmIChrZXkpIHsgcGFyYW1zW2tleS5uYW1lXSA9IHZhbDsgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJlY29yZFBhdGggKHBhdGgsIHJlY29yZCkge1xuICByZXR1cm4gcmVzb2x2ZVBhdGgocGF0aCwgcmVjb3JkLnBhcmVudCA/IHJlY29yZC5wYXJlbnQucGF0aCA6ICcvJywgdHJ1ZSlcbn1cblxuLyogICovXG5cblxudmFyIHBvc2l0aW9uU3RvcmUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBzZXR1cFNjcm9sbCAoKSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgc2F2ZVNjcm9sbFBvc2l0aW9uKCk7XG4gICAgaWYgKGUuc3RhdGUgJiYgZS5zdGF0ZS5rZXkpIHtcbiAgICAgIHNldFN0YXRlS2V5KGUuc3RhdGUua2V5KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTY3JvbGwgKFxuICByb3V0ZXIsXG4gIHRvLFxuICBmcm9tLFxuICBpc1BvcFxuKSB7XG4gIGlmICghcm91dGVyLmFwcCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJlaGF2aW9yID0gcm91dGVyLm9wdGlvbnMuc2Nyb2xsQmVoYXZpb3I7XG4gIGlmICghYmVoYXZpb3IpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiZWhhdmlvciA9PT0gJ2Z1bmN0aW9uJywgXCJzY3JvbGxCZWhhdmlvciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICAvLyB3YWl0IHVudGlsIHJlLXJlbmRlciBmaW5pc2hlcyBiZWZvcmUgc2Nyb2xsaW5nXG4gIHJvdXRlci5hcHAuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBnZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIHZhciBzaG91bGRTY3JvbGwgPSBiZWhhdmlvcih0bywgZnJvbSwgaXNQb3AgPyBwb3NpdGlvbiA6IG51bGwpO1xuICAgIGlmICghc2hvdWxkU2Nyb2xsKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIGlzT2JqZWN0ID0gdHlwZW9mIHNob3VsZFNjcm9sbCA9PT0gJ29iamVjdCc7XG4gICAgaWYgKGlzT2JqZWN0ICYmIHR5cGVvZiBzaG91bGRTY3JvbGwuc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNob3VsZFNjcm9sbC5zZWxlY3Rvcik7XG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgcG9zaXRpb24gPSBnZXRFbGVtZW50UG9zaXRpb24oZWwpO1xuICAgICAgfSBlbHNlIGlmIChpc1ZhbGlkUG9zaXRpb24oc2hvdWxkU2Nyb2xsKSkge1xuICAgICAgICBwb3NpdGlvbiA9IG5vcm1hbGl6ZVBvc2l0aW9uKHNob3VsZFNjcm9sbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCAmJiBpc1ZhbGlkUG9zaXRpb24oc2hvdWxkU2Nyb2xsKSkge1xuICAgICAgcG9zaXRpb24gPSBub3JtYWxpemVQb3NpdGlvbihzaG91bGRTY3JvbGwpO1xuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgd2luZG93LnNjcm9sbFRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNhdmVTY3JvbGxQb3NpdGlvbiAoKSB7XG4gIHZhciBrZXkgPSBnZXRTdGF0ZUtleSgpO1xuICBpZiAoa2V5KSB7XG4gICAgcG9zaXRpb25TdG9yZVtrZXldID0ge1xuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxQb3NpdGlvbiAoKSB7XG4gIHZhciBrZXkgPSBnZXRTdGF0ZUtleSgpO1xuICBpZiAoa2V5KSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uU3RvcmVba2V5XVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRQb3NpdGlvbiAoZWwpIHtcbiAgdmFyIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgZG9jUmVjdCA9IGRvY0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgeDogZWxSZWN0LmxlZnQgLSBkb2NSZWN0LmxlZnQsXG4gICAgeTogZWxSZWN0LnRvcCAtIGRvY1JlY3QudG9wXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZFBvc2l0aW9uIChvYmopIHtcbiAgcmV0dXJuIGlzTnVtYmVyKG9iai54KSB8fCBpc051bWJlcihvYmoueSlcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUG9zaXRpb24gKG9iaikge1xuICByZXR1cm4ge1xuICAgIHg6IGlzTnVtYmVyKG9iai54KSA/IG9iai54IDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgIHk6IGlzTnVtYmVyKG9iai55KSA/IG9iai55IDogd2luZG93LnBhZ2VZT2Zmc2V0XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIgKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnbnVtYmVyJ1xufVxuXG4vKiAgKi9cblxudmFyIHN1cHBvcnRzUHVzaFN0YXRlID0gaW5Ccm93c2VyICYmIChmdW5jdGlvbiAoKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gIGlmIChcbiAgICAodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiZcbiAgICB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmXG4gICAgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmXG4gICAgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMVxuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeVxufSkoKTtcblxuLy8gdXNlIFVzZXIgVGltaW5nIGFwaSAoaWYgcHJlc2VudCkgZm9yIG1vcmUgYWNjdXJhdGUga2V5IHByZWNpc2lvblxudmFyIFRpbWUgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3dcbiAgPyB3aW5kb3cucGVyZm9ybWFuY2VcbiAgOiBEYXRlO1xuXG52YXIgX2tleSA9IGdlbktleSgpO1xuXG5mdW5jdGlvbiBnZW5LZXkgKCkge1xuICByZXR1cm4gVGltZS5ub3coKS50b0ZpeGVkKDMpXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlS2V5ICgpIHtcbiAgcmV0dXJuIF9rZXlcbn1cblxuZnVuY3Rpb24gc2V0U3RhdGVLZXkgKGtleSkge1xuICBfa2V5ID0ga2V5O1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhdGUgKHVybCwgcmVwbGFjZSkge1xuICBzYXZlU2Nyb2xsUG9zaXRpb24oKTtcbiAgLy8gdHJ5Li4uY2F0Y2ggdGhlIHB1c2hTdGF0ZSBjYWxsIHRvIGdldCBhcm91bmQgU2FmYXJpXG4gIC8vIERPTSBFeGNlcHRpb24gMTggd2hlcmUgaXQgbGltaXRzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHNcbiAgdmFyIGhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdHJ5IHtcbiAgICBpZiAocmVwbGFjZSkge1xuICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXk6IF9rZXkgfSwgJycsIHVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9rZXkgPSBnZW5LZXkoKTtcbiAgICAgIGhpc3RvcnkucHVzaFN0YXRlKHsga2V5OiBfa2V5IH0sICcnLCB1cmwpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHdpbmRvdy5sb2NhdGlvbltyZXBsYWNlID8gJ3JlcGxhY2UnIDogJ2Fzc2lnbiddKHVybCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZVN0YXRlICh1cmwpIHtcbiAgcHVzaFN0YXRlKHVybCwgdHJ1ZSk7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBydW5RdWV1ZSAocXVldWUsIGZuLCBjYikge1xuICB2YXIgc3RlcCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIGlmIChpbmRleCA+PSBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNiKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChxdWV1ZVtpbmRleF0pIHtcbiAgICAgICAgZm4ocXVldWVbaW5kZXhdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RlcChpbmRleCArIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZXAoaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHN0ZXAoMCk7XG59XG5cbi8qICAqL1xuXG5cbnZhciBIaXN0b3J5ID0gZnVuY3Rpb24gSGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gIHRoaXMucm91dGVyID0gcm91dGVyO1xuICB0aGlzLmJhc2UgPSBub3JtYWxpemVCYXNlKGJhc2UpO1xuICAvLyBzdGFydCB3aXRoIGEgcm91dGUgb2JqZWN0IHRoYXQgc3RhbmRzIGZvciBcIm5vd2hlcmVcIlxuICB0aGlzLmN1cnJlbnQgPSBTVEFSVDtcbiAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICB0aGlzLnJlYWR5Q2JzID0gW107XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4gKGNiKSB7XG4gIHRoaXMuY2IgPSBjYjtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLm9uUmVhZHkgPSBmdW5jdGlvbiBvblJlYWR5IChjYikge1xuICBpZiAodGhpcy5yZWFkeSkge1xuICAgIGNiKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZWFkeUNicy5wdXNoKGNiKTtcbiAgfVxufTtcblxuSGlzdG9yeS5wcm90b3R5cGUudHJhbnNpdGlvblRvID0gZnVuY3Rpb24gdHJhbnNpdGlvblRvIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciByb3V0ZSA9IHRoaXMucm91dGVyLm1hdGNoKGxvY2F0aW9uLCB0aGlzLmN1cnJlbnQpO1xuICB0aGlzLmNvbmZpcm1UcmFuc2l0aW9uKHJvdXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcyQxLnVwZGF0ZVJvdXRlKHJvdXRlKTtcbiAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIHRoaXMkMS5lbnN1cmVVUkwoKTtcblxuICAgIC8vIGZpcmUgcmVhZHkgY2JzIG9uY2VcbiAgICBpZiAoIXRoaXMkMS5yZWFkeSkge1xuICAgICAgdGhpcyQxLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMkMS5yZWFkeUNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgICBjYihyb3V0ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIG9uQWJvcnQpO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUuY29uZmlybVRyYW5zaXRpb24gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvbiAocm91dGUsIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKCkgeyBvbkFib3J0ICYmIG9uQWJvcnQoKTsgfTtcbiAgaWYgKFxuICAgIGlzU2FtZVJvdXRlKHJvdXRlLCBjdXJyZW50KSAmJlxuICAgIC8vIGluIHRoZSBjYXNlIHRoZSByb3V0ZSBtYXAgaGFzIGJlZW4gZHluYW1pY2FsbHkgYXBwZW5kZWQgdG9cbiAgICByb3V0ZS5tYXRjaGVkLmxlbmd0aCA9PT0gY3VycmVudC5tYXRjaGVkLmxlbmd0aFxuICApIHtcbiAgICB0aGlzLmVuc3VyZVVSTCgpO1xuICAgIHJldHVybiBhYm9ydCgpXG4gIH1cblxuICB2YXIgcmVmID0gcmVzb2x2ZVF1ZXVlKHRoaXMuY3VycmVudC5tYXRjaGVkLCByb3V0ZS5tYXRjaGVkKTtcbiAgICB2YXIgdXBkYXRlZCA9IHJlZi51cGRhdGVkO1xuICAgIHZhciBkZWFjdGl2YXRlZCA9IHJlZi5kZWFjdGl2YXRlZDtcbiAgICB2YXIgYWN0aXZhdGVkID0gcmVmLmFjdGl2YXRlZDtcblxuICB2YXIgcXVldWUgPSBbXS5jb25jYXQoXG4gICAgLy8gaW4tY29tcG9uZW50IGxlYXZlIGd1YXJkc1xuICAgIGV4dHJhY3RMZWF2ZUd1YXJkcyhkZWFjdGl2YXRlZCksXG4gICAgLy8gZ2xvYmFsIGJlZm9yZSBob29rc1xuICAgIHRoaXMucm91dGVyLmJlZm9yZUhvb2tzLFxuICAgIC8vIGluLWNvbXBvbmVudCB1cGRhdGUgaG9va3NcbiAgICBleHRyYWN0VXBkYXRlSG9va3ModXBkYXRlZCksXG4gICAgLy8gaW4tY29uZmlnIGVudGVyIGd1YXJkc1xuICAgIGFjdGl2YXRlZC5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uYmVmb3JlRW50ZXI7IH0pLFxuICAgIC8vIGFzeW5jIGNvbXBvbmVudHNcbiAgICByZXNvbHZlQXN5bmNDb21wb25lbnRzKGFjdGl2YXRlZClcbiAgKTtcblxuICB0aGlzLnBlbmRpbmcgPSByb3V0ZTtcbiAgdmFyIGl0ZXJhdG9yID0gZnVuY3Rpb24gKGhvb2ssIG5leHQpIHtcbiAgICBpZiAodGhpcyQxLnBlbmRpbmcgIT09IHJvdXRlKSB7XG4gICAgICByZXR1cm4gYWJvcnQoKVxuICAgIH1cbiAgICBob29rKHJvdXRlLCBjdXJyZW50LCBmdW5jdGlvbiAodG8pIHtcbiAgICAgIGlmICh0byA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gbmV4dChmYWxzZSkgLT4gYWJvcnQgbmF2aWdhdGlvbiwgZW5zdXJlIGN1cnJlbnQgVVJMXG4gICAgICAgIHRoaXMkMS5lbnN1cmVVUkwodHJ1ZSk7XG4gICAgICAgIGFib3J0KCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0byA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHRvID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBuZXh0KCcvJykgb3IgbmV4dCh7IHBhdGg6ICcvJyB9KSAtPiByZWRpcmVjdFxuICAgICAgICAodHlwZW9mIHRvID09PSAnb2JqZWN0JyAmJiB0by5yZXBsYWNlKSA/IHRoaXMkMS5yZXBsYWNlKHRvKSA6IHRoaXMkMS5wdXNoKHRvKTtcbiAgICAgICAgYWJvcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbmZpcm0gdHJhbnNpdGlvbiBhbmQgcGFzcyBvbiB0aGUgdmFsdWVcbiAgICAgICAgbmV4dCh0byk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcnVuUXVldWUocXVldWUsIGl0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc3RFbnRlckNicyA9IFtdO1xuICAgIHZhciBpc1ZhbGlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLmN1cnJlbnQgPT09IHJvdXRlOyB9O1xuICAgIHZhciBlbnRlckd1YXJkcyA9IGV4dHJhY3RFbnRlckd1YXJkcyhhY3RpdmF0ZWQsIHBvc3RFbnRlckNicywgaXNWYWxpZCk7XG4gICAgLy8gd2FpdCB1bnRpbCBhc3luYyBjb21wb25lbnRzIGFyZSByZXNvbHZlZCBiZWZvcmVcbiAgICAvLyBleHRyYWN0aW5nIGluLWNvbXBvbmVudCBlbnRlciBndWFyZHNcbiAgICBydW5RdWV1ZShlbnRlckd1YXJkcywgaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzJDEucGVuZGluZyAhPT0gcm91dGUpIHtcbiAgICAgICAgcmV0dXJuIGFib3J0KClcbiAgICAgIH1cbiAgICAgIHRoaXMkMS5wZW5kaW5nID0gbnVsbDtcbiAgICAgIG9uQ29tcGxldGUocm91dGUpO1xuICAgICAgaWYgKHRoaXMkMS5yb3V0ZXIuYXBwKSB7XG4gICAgICAgIHRoaXMkMS5yb3V0ZXIuYXBwLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcG9zdEVudGVyQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYigpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUudXBkYXRlUm91dGUgPSBmdW5jdGlvbiB1cGRhdGVSb3V0ZSAocm91dGUpIHtcbiAgdmFyIHByZXYgPSB0aGlzLmN1cnJlbnQ7XG4gIHRoaXMuY3VycmVudCA9IHJvdXRlO1xuICB0aGlzLmNiICYmIHRoaXMuY2Iocm91dGUpO1xuICB0aGlzLnJvdXRlci5hZnRlckhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICBob29rICYmIGhvb2socm91dGUsIHByZXYpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUJhc2UgKGJhc2UpIHtcbiAgaWYgKCFiYXNlKSB7XG4gICAgaWYgKGluQnJvd3Nlcikge1xuICAgICAgLy8gcmVzcGVjdCA8YmFzZT4gdGFnXG4gICAgICB2YXIgYmFzZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpO1xuICAgICAgYmFzZSA9IChiYXNlRWwgJiYgYmFzZUVsLmdldEF0dHJpYnV0ZSgnaHJlZicpKSB8fCAnLyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSAnLyc7XG4gICAgfVxuICB9XG4gIC8vIG1ha2Ugc3VyZSB0aGVyZSdzIHRoZSBzdGFydGluZyBzbGFzaFxuICBpZiAoYmFzZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgIGJhc2UgPSAnLycgKyBiYXNlO1xuICB9XG4gIC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICByZXR1cm4gYmFzZS5yZXBsYWNlKC9cXC8kLywgJycpXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVRdWV1ZSAoXG4gIGN1cnJlbnQsXG4gIG5leHRcbikge1xuICB2YXIgaTtcbiAgdmFyIG1heCA9IE1hdGgubWF4KGN1cnJlbnQubGVuZ3RoLCBuZXh0Lmxlbmd0aCk7XG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIGlmIChjdXJyZW50W2ldICE9PSBuZXh0W2ldKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHVwZGF0ZWQ6IG5leHQuc2xpY2UoMCwgaSksXG4gICAgYWN0aXZhdGVkOiBuZXh0LnNsaWNlKGkpLFxuICAgIGRlYWN0aXZhdGVkOiBjdXJyZW50LnNsaWNlKGkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEd1YXJkcyAoXG4gIHJlY29yZHMsXG4gIG5hbWUsXG4gIGJpbmQsXG4gIHJldmVyc2Vcbikge1xuICB2YXIgZ3VhcmRzID0gZmxhdE1hcENvbXBvbmVudHMocmVjb3JkcywgZnVuY3Rpb24gKGRlZiwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpIHtcbiAgICB2YXIgZ3VhcmQgPSBleHRyYWN0R3VhcmQoZGVmLCBuYW1lKTtcbiAgICBpZiAoZ3VhcmQpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGd1YXJkKVxuICAgICAgICA/IGd1YXJkLm1hcChmdW5jdGlvbiAoZ3VhcmQpIHsgcmV0dXJuIGJpbmQoZ3VhcmQsIGluc3RhbmNlLCBtYXRjaCwga2V5KTsgfSlcbiAgICAgICAgOiBiaW5kKGd1YXJkLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSlcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZmxhdHRlbihyZXZlcnNlID8gZ3VhcmRzLnJldmVyc2UoKSA6IGd1YXJkcylcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEd1YXJkIChcbiAgZGVmLFxuICBrZXlcbikge1xuICBpZiAodHlwZW9mIGRlZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGV4dGVuZCBub3cgc28gdGhhdCBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkLlxuICAgIGRlZiA9IF9WdWUuZXh0ZW5kKGRlZik7XG4gIH1cbiAgcmV0dXJuIGRlZi5vcHRpb25zW2tleV1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdExlYXZlR3VhcmRzIChkZWFjdGl2YXRlZCkge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyhkZWFjdGl2YXRlZCwgJ2JlZm9yZVJvdXRlTGVhdmUnLCBiaW5kR3VhcmQsIHRydWUpXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RVcGRhdGVIb29rcyAodXBkYXRlZCkge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyh1cGRhdGVkLCAnYmVmb3JlUm91dGVVcGRhdGUnLCBiaW5kR3VhcmQpXG59XG5cbmZ1bmN0aW9uIGJpbmRHdWFyZCAoZ3VhcmQsIGluc3RhbmNlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBib3VuZFJvdXRlR3VhcmQgKCkge1xuICAgIHJldHVybiBndWFyZC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFbnRlckd1YXJkcyAoXG4gIGFjdGl2YXRlZCxcbiAgY2JzLFxuICBpc1ZhbGlkXG4pIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHMoYWN0aXZhdGVkLCAnYmVmb3JlUm91dGVFbnRlcicsIGZ1bmN0aW9uIChndWFyZCwgXywgbWF0Y2gsIGtleSkge1xuICAgIHJldHVybiBiaW5kRW50ZXJHdWFyZChndWFyZCwgbWF0Y2gsIGtleSwgY2JzLCBpc1ZhbGlkKVxuICB9KVxufVxuXG5mdW5jdGlvbiBiaW5kRW50ZXJHdWFyZCAoXG4gIGd1YXJkLFxuICBtYXRjaCxcbiAga2V5LFxuICBjYnMsXG4gIGlzVmFsaWRcbikge1xuICByZXR1cm4gZnVuY3Rpb24gcm91dGVFbnRlckd1YXJkICh0bywgZnJvbSwgbmV4dCkge1xuICAgIHJldHVybiBndWFyZCh0bywgZnJvbSwgZnVuY3Rpb24gKGNiKSB7XG4gICAgICBuZXh0KGNiKTtcbiAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2JzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vICM3NTBcbiAgICAgICAgICAvLyBpZiBhIHJvdXRlci12aWV3IGlzIHdyYXBwZWQgd2l0aCBhbiBvdXQtaW4gdHJhbnNpdGlvbixcbiAgICAgICAgICAvLyB0aGUgaW5zdGFuY2UgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCBhdCB0aGlzIHRpbWUuXG4gICAgICAgICAgLy8gd2Ugd2lsbCBuZWVkIHRvIHBvbGwgZm9yIHJlZ2lzdHJhdGlvbiB1bnRpbCBjdXJyZW50IHJvdXRlXG4gICAgICAgICAgLy8gaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgICAgICAgIHBvbGwoY2IsIG1hdGNoLmluc3RhbmNlcywga2V5LCBpc1ZhbGlkKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwb2xsIChcbiAgY2IsIC8vIHNvbWVob3cgZmxvdyBjYW5ub3QgaW5mZXIgdGhpcyBpcyBhIGZ1bmN0aW9uXG4gIGluc3RhbmNlcyxcbiAga2V5LFxuICBpc1ZhbGlkXG4pIHtcbiAgaWYgKGluc3RhbmNlc1trZXldKSB7XG4gICAgY2IoaW5zdGFuY2VzW2tleV0pO1xuICB9IGVsc2UgaWYgKGlzVmFsaWQoKSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcG9sbChjYiwgaW5zdGFuY2VzLCBrZXksIGlzVmFsaWQpO1xuICAgIH0sIDE2KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnRzIChtYXRjaGVkKSB7XG4gIHJldHVybiBmbGF0TWFwQ29tcG9uZW50cyhtYXRjaGVkLCBmdW5jdGlvbiAoZGVmLCBfLCBtYXRjaCwga2V5KSB7XG4gICAgLy8gaWYgaXQncyBhIGZ1bmN0aW9uIGFuZCBkb2Vzbid0IGhhdmUgVnVlIG9wdGlvbnMgYXR0YWNoZWQsXG4gICAgLy8gYXNzdW1lIGl0J3MgYW4gYXN5bmMgY29tcG9uZW50IHJlc29sdmUgZnVuY3Rpb24uXG4gICAgLy8gd2UgYXJlIG5vdCB1c2luZyBWdWUncyBkZWZhdWx0IGFzeW5jIHJlc29sdmluZyBtZWNoYW5pc20gYmVjYXVzZVxuICAgIC8vIHdlIHdhbnQgdG8gaGFsdCB0aGUgbmF2aWdhdGlvbiB1bnRpbCB0aGUgaW5jb21pbmcgY29tcG9uZW50IGhhcyBiZWVuXG4gICAgLy8gcmVzb2x2ZWQuXG4gICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgIWRlZi5vcHRpb25zKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHRvLCBmcm9tLCBuZXh0KSB7XG4gICAgICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzb2x2ZWREZWYpIHtcbiAgICAgICAgICBtYXRjaC5jb21wb25lbnRzW2tleV0gPSByZXNvbHZlZERlZjtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICB3YXJuKGZhbHNlLCAoXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQgXCIgKyBrZXkgKyBcIjogXCIgKyByZWFzb24pKTtcbiAgICAgICAgICBuZXh0KGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlcyA9IGRlZihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGZsYXRNYXBDb21wb25lbnRzIChcbiAgbWF0Y2hlZCxcbiAgZm5cbikge1xuICByZXR1cm4gZmxhdHRlbihtYXRjaGVkLm1hcChmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhtLmNvbXBvbmVudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBmbihcbiAgICAgIG0uY29tcG9uZW50c1trZXldLFxuICAgICAgbS5pbnN0YW5jZXNba2V5XSxcbiAgICAgIG0sIGtleVxuICAgICk7IH0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuIChhcnIpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycilcbn1cblxuLy8gaW4gV2VicGFjayAyLCByZXF1aXJlLmVuc3VyZSBub3cgYWxzbyByZXR1cm5zIGEgUHJvbWlzZVxuLy8gc28gdGhlIHJlc29sdmUvcmVqZWN0IGZ1bmN0aW9ucyBtYXkgZ2V0IGNhbGxlZCBhbiBleHRyYSB0aW1lXG4vLyBpZiB0aGUgdXNlciB1c2VzIGFuIGFycm93IGZ1bmN0aW9uIHNob3J0aGFuZCB0aGF0IGhhcHBlbnMgdG9cbi8vIHJldHVybiB0aGF0IFByb21pc2UuXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgeyByZXR1cm4gfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxufVxuXG4vKiAgKi9cblxuXG52YXIgSFRNTDVIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEhUTUw1SGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcblxuICAgIHZhciBleHBlY3RTY3JvbGwgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcblxuICAgIGlmIChleHBlY3RTY3JvbGwpIHtcbiAgICAgIHNldHVwU2Nyb2xsKCk7XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMkMS50cmFuc2l0aW9uVG8oZ2V0TG9jYXRpb24odGhpcyQxLmJhc2UpLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgaWYgKGV4cGVjdFNjcm9sbCkge1xuICAgICAgICAgIGhhbmRsZVNjcm9sbChyb3V0ZXIsIHJvdXRlLCB0aGlzJDEuY3VycmVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgSFRNTDVIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIVE1MNUhpc3Rvcnk7XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHB1c2hTdGF0ZShjbGVhblBhdGgodGhpcyQxLmJhc2UgKyByb3V0ZS5mdWxsUGF0aCkpO1xuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCB0aGlzJDEuY3VycmVudCwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmVwbGFjZVN0YXRlKGNsZWFuUGF0aCh0aGlzJDEuYmFzZSArIHJvdXRlLmZ1bGxQYXRoKSk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIHRoaXMkMS5jdXJyZW50LCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMIChwdXNoKSB7XG4gICAgaWYgKGdldExvY2F0aW9uKHRoaXMuYmFzZSkgIT09IHRoaXMuY3VycmVudC5mdWxsUGF0aCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBjbGVhblBhdGgodGhpcy5iYXNlICsgdGhpcy5jdXJyZW50LmZ1bGxQYXRoKTtcbiAgICAgIHB1c2ggPyBwdXNoU3RhdGUoY3VycmVudCkgOiByZXBsYWNlU3RhdGUoY3VycmVudCk7XG4gICAgfVxuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0TG9jYXRpb24odGhpcy5iYXNlKVxuICB9O1xuXG4gIHJldHVybiBIVE1MNUhpc3Rvcnk7XG59KEhpc3RvcnkpKTtcblxuZnVuY3Rpb24gZ2V0TG9jYXRpb24gKGJhc2UpIHtcbiAgdmFyIHBhdGggPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gIGlmIChiYXNlICYmIHBhdGguaW5kZXhPZihiYXNlKSA9PT0gMCkge1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKGJhc2UubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gKHBhdGggfHwgJy8nKSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggKyB3aW5kb3cubG9jYXRpb24uaGFzaFxufVxuXG4vKiAgKi9cblxuXG52YXIgSGFzaEhpc3RvcnkgPSAoZnVuY3Rpb24gKEhpc3RvcnkkJDEpIHtcbiAgZnVuY3Rpb24gSGFzaEhpc3RvcnkgKHJvdXRlciwgYmFzZSwgZmFsbGJhY2spIHtcbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcbiAgICAvLyBjaGVjayBoaXN0b3J5IGZhbGxiYWNrIGRlZXBsaW5raW5nXG4gICAgaWYgKGZhbGxiYWNrICYmIGNoZWNrRmFsbGJhY2sodGhpcy5iYXNlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVuc3VyZVNsYXNoKCk7XG4gIH1cblxuICBpZiAoIEhpc3RvcnkkJDEgKSBIYXNoSGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5JCQxO1xuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhhc2hIaXN0b3J5O1xuXG4gIC8vIHRoaXMgaXMgZGVsYXllZCB1bnRpbCB0aGUgYXBwIG1vdW50c1xuICAvLyB0byBhdm9pZCB0aGUgaGFzaGNoYW5nZSBsaXN0ZW5lciBiZWluZyBmaXJlZCB0b28gZWFybHlcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnNldHVwTGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0dXBMaXN0ZW5lcnMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWVuc3VyZVNsYXNoKCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzJDEudHJhbnNpdGlvblRvKGdldEhhc2goKSwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIHJlcGxhY2VIYXNoKHJvdXRlLmZ1bGxQYXRoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICBwdXNoSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICByZXBsYWNlSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAocHVzaCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50LmZ1bGxQYXRoO1xuICAgIGlmIChnZXRIYXNoKCkgIT09IGN1cnJlbnQpIHtcbiAgICAgIHB1c2ggPyBwdXNoSGFzaChjdXJyZW50KSA6IHJlcGxhY2VIYXNoKGN1cnJlbnQpO1xuICAgIH1cbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0SGFzaCgpXG4gIH07XG5cbiAgcmV0dXJuIEhhc2hIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbmZ1bmN0aW9uIGNoZWNrRmFsbGJhY2sgKGJhc2UpIHtcbiAgdmFyIGxvY2F0aW9uID0gZ2V0TG9jYXRpb24oYmFzZSk7XG4gIGlmICghL15cXC8jLy50ZXN0KGxvY2F0aW9uKSkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKFxuICAgICAgY2xlYW5QYXRoKGJhc2UgKyAnLyMnICsgbG9jYXRpb24pXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVNsYXNoICgpIHtcbiAgdmFyIHBhdGggPSBnZXRIYXNoKCk7XG4gIGlmIChwYXRoLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXBsYWNlSGFzaCgnLycgKyBwYXRoKTtcbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGdldEhhc2ggKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBpbmRleCA9IGhyZWYuaW5kZXhPZignIycpO1xuICByZXR1cm4gaW5kZXggPT09IC0xID8gJycgOiBocmVmLnNsaWNlKGluZGV4ICsgMSlcbn1cblxuZnVuY3Rpb24gcHVzaEhhc2ggKHBhdGgpIHtcbiAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlSGFzaCAocGF0aCkge1xuICB2YXIgaSA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJyMnKTtcbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoXG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYuc2xpY2UoMCwgaSA+PSAwID8gaSA6IDApICsgJyMnICsgcGF0aFxuICApO1xufVxuXG4vKiAgKi9cblxuXG52YXIgQWJzdHJhY3RIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEFic3RyYWN0SGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgfVxuXG4gIGlmICggSGlzdG9yeSQkMSApIEFic3RyYWN0SGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5JCQxO1xuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSQkMSAmJiBIaXN0b3J5JCQxLnByb3RvdHlwZSApO1xuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWJzdHJhY3RIaXN0b3J5O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICB0aGlzJDEuc3RhY2sgPSB0aGlzJDEuc3RhY2suc2xpY2UoMCwgdGhpcyQxLmluZGV4ICsgMSkuY29uY2F0KHJvdXRlKTtcbiAgICAgIHRoaXMkMS5pbmRleCsrO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgdGhpcyQxLnN0YWNrID0gdGhpcyQxLnN0YWNrLnNsaWNlKDAsIHRoaXMkMS5pbmRleCkuY29uY2F0KHJvdXRlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdGFyZ2V0SW5kZXggPSB0aGlzLmluZGV4ICsgbjtcbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwIHx8IHRhcmdldEluZGV4ID49IHRoaXMuc3RhY2subGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHJvdXRlID0gdGhpcy5zdGFja1t0YXJnZXRJbmRleF07XG4gICAgdGhpcy5jb25maXJtVHJhbnNpdGlvbihyb3V0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcyQxLmluZGV4ID0gdGFyZ2V0SW5kZXg7XG4gICAgICB0aGlzJDEudXBkYXRlUm91dGUocm91dGUpO1xuICAgIH0pO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gY3VycmVudCA/IGN1cnJlbnQuZnVsbFBhdGggOiAnLydcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAoKSB7XG4gICAgLy8gbm9vcFxuICB9O1xuXG4gIHJldHVybiBBYnN0cmFjdEhpc3Rvcnk7XG59KEhpc3RvcnkpKTtcblxuLyogICovXG5cbnZhciBWdWVSb3V0ZXIgPSBmdW5jdGlvbiBWdWVSb3V0ZXIgKG9wdGlvbnMpIHtcbiAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgdGhpcy5hcHAgPSBudWxsO1xuICB0aGlzLmFwcHMgPSBbXTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5iZWZvcmVIb29rcyA9IFtdO1xuICB0aGlzLmFmdGVySG9va3MgPSBbXTtcbiAgdGhpcy5tYXRjaGVyID0gY3JlYXRlTWF0Y2hlcihvcHRpb25zLnJvdXRlcyB8fCBbXSk7XG5cbiAgdmFyIG1vZGUgPSBvcHRpb25zLm1vZGUgfHwgJ2hhc2gnO1xuICB0aGlzLmZhbGxiYWNrID0gbW9kZSA9PT0gJ2hpc3RvcnknICYmICFzdXBwb3J0c1B1c2hTdGF0ZTtcbiAgaWYgKHRoaXMuZmFsbGJhY2spIHtcbiAgICBtb2RlID0gJ2hhc2gnO1xuICB9XG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgbW9kZSA9ICdhYnN0cmFjdCc7XG4gIH1cbiAgdGhpcy5tb2RlID0gbW9kZTtcblxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlICdoaXN0b3J5JzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIVE1MNUhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSGFzaEhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlLCB0aGlzLmZhbGxiYWNrKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYWJzdHJhY3QnOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEFic3RyYWN0SGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UpO1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCAoXCJpbnZhbGlkIG1vZGU6IFwiICsgbW9kZSkpO1xuICAgICAgfVxuICB9XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjdXJyZW50Um91dGU6IHt9IH07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCAoXG4gIHJhdyxcbiAgY3VycmVudCxcbiAgcmVkaXJlY3RlZEZyb21cbikge1xuICByZXR1cm4gdGhpcy5tYXRjaGVyLm1hdGNoKHJhdywgY3VycmVudCwgcmVkaXJlY3RlZEZyb20pXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuY3VycmVudFJvdXRlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaGlzdG9yeSAmJiB0aGlzLmhpc3RvcnkuY3VycmVudFxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoYXBwIC8qIFZ1ZSBjb21wb25lbnQgaW5zdGFuY2UgKi8pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydChcbiAgICBpbnN0YWxsLmluc3RhbGxlZCxcbiAgICBcIm5vdCBpbnN0YWxsZWQuIE1ha2Ugc3VyZSB0byBjYWxsIGBWdWUudXNlKFZ1ZVJvdXRlcilgIFwiICtcbiAgICBcImJlZm9yZSBjcmVhdGluZyByb290IGluc3RhbmNlLlwiXG4gICk7XG5cbiAgdGhpcy5hcHBzLnB1c2goYXBwKTtcblxuICAvLyBtYWluIGFwcCBhbHJlYWR5IGluaXRpYWxpemVkLlxuICBpZiAodGhpcy5hcHApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMuYXBwID0gYXBwO1xuXG4gIHZhciBoaXN0b3J5ID0gdGhpcy5oaXN0b3J5O1xuXG4gIGlmIChoaXN0b3J5IGluc3RhbmNlb2YgSFRNTDVIaXN0b3J5KSB7XG4gICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gIH0gZWxzZSBpZiAoaGlzdG9yeSBpbnN0YW5jZW9mIEhhc2hIaXN0b3J5KSB7XG4gICAgdmFyIHNldHVwSGFzaExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgaGlzdG9yeS5zZXR1cExpc3RlbmVycygpO1xuICAgIH07XG4gICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oXG4gICAgICBoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpLFxuICAgICAgc2V0dXBIYXNoTGlzdGVuZXIsXG4gICAgICBzZXR1cEhhc2hMaXN0ZW5lclxuICAgICk7XG4gIH1cblxuICBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAocm91dGUpIHtcbiAgICB0aGlzJDEuYXBwcy5mb3JFYWNoKGZ1bmN0aW9uIChhcHApIHtcbiAgICAgIGFwcC5fcm91dGUgPSByb3V0ZTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmJlZm9yZUVhY2ggPSBmdW5jdGlvbiBiZWZvcmVFYWNoIChmbikge1xuICB0aGlzLmJlZm9yZUhvb2tzLnB1c2goZm4pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5hZnRlckVhY2ggPSBmdW5jdGlvbiBhZnRlckVhY2ggKGZuKSB7XG4gIHRoaXMuYWZ0ZXJIb29rcy5wdXNoKGZuKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkgKGNiKSB7XG4gIHRoaXMuaGlzdG9yeS5vblJlYWR5KGNiKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gIHRoaXMuaGlzdG9yeS5wdXNoKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gIHRoaXMuaGlzdG9yeS5yZXBsYWNlKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICB0aGlzLmhpc3RvcnkuZ28obik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbiBiYWNrICgpIHtcbiAgdGhpcy5nbygtMSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiBmb3J3YXJkICgpIHtcbiAgdGhpcy5nbygxKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuZ2V0TWF0Y2hlZENvbXBvbmVudHMgPSBmdW5jdGlvbiBnZXRNYXRjaGVkQ29tcG9uZW50cyAodG8pIHtcbiAgdmFyIHJvdXRlID0gdG9cbiAgICA/IHRoaXMucmVzb2x2ZSh0bykucm91dGVcbiAgICA6IHRoaXMuY3VycmVudFJvdXRlO1xuICBpZiAoIXJvdXRlKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgcm91dGUubWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobS5jb21wb25lbnRzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIG0uY29tcG9uZW50c1trZXldXG4gICAgfSlcbiAgfSkpXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlIChcbiAgdG8sXG4gIGN1cnJlbnQsXG4gIGFwcGVuZFxuKSB7XG4gIHZhciBsb2NhdGlvbiA9IG5vcm1hbGl6ZUxvY2F0aW9uKHRvLCBjdXJyZW50IHx8IHRoaXMuaGlzdG9yeS5jdXJyZW50LCBhcHBlbmQpO1xuICB2YXIgcm91dGUgPSB0aGlzLm1hdGNoKGxvY2F0aW9uLCBjdXJyZW50KTtcbiAgdmFyIGZ1bGxQYXRoID0gcm91dGUucmVkaXJlY3RlZEZyb20gfHwgcm91dGUuZnVsbFBhdGg7XG4gIHZhciBiYXNlID0gdGhpcy5oaXN0b3J5LmJhc2U7XG4gIHZhciBocmVmID0gY3JlYXRlSHJlZihiYXNlLCBmdWxsUGF0aCwgdGhpcy5tb2RlKTtcbiAgcmV0dXJuIHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgcm91dGU6IHJvdXRlLFxuICAgIGhyZWY6IGhyZWYsXG4gICAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICBub3JtYWxpemVkVG86IGxvY2F0aW9uLFxuICAgIHJlc29sdmVkOiByb3V0ZVxuICB9XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmFkZFJvdXRlcyA9IGZ1bmN0aW9uIGFkZFJvdXRlcyAocm91dGVzKSB7XG4gIHRoaXMubWF0Y2hlci5hZGRSb3V0ZXMocm91dGVzKTtcbiAgaWYgKHRoaXMuaGlzdG9yeS5jdXJyZW50ICE9PSBTVEFSVCkge1xuICAgIHRoaXMuaGlzdG9yeS50cmFuc2l0aW9uVG8odGhpcy5oaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZ1ZVJvdXRlci5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG5mdW5jdGlvbiBjcmVhdGVIcmVmIChiYXNlLCBmdWxsUGF0aCwgbW9kZSkge1xuICB2YXIgcGF0aCA9IG1vZGUgPT09ICdoYXNoJyA/ICcjJyArIGZ1bGxQYXRoIDogZnVsbFBhdGg7XG4gIHJldHVybiBiYXNlID8gY2xlYW5QYXRoKGJhc2UgKyAnLycgKyBwYXRoKSA6IHBhdGhcbn1cblxuVnVlUm91dGVyLmluc3RhbGwgPSBpbnN0YWxsO1xuVnVlUm91dGVyLnZlcnNpb24gPSAnMi4yLjEnO1xuXG5pZiAoaW5Ccm93c2VyICYmIHdpbmRvdy5WdWUpIHtcbiAgd2luZG93LlZ1ZS51c2UoVnVlUm91dGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVnVlUm91dGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi92dWUtcm91dGVyL2Rpc3QvdnVlLXJvdXRlci5lc20uanMiLCIvKiFcbiAqIFZ1ZS5qcyB2Mi4yLjRcbiAqIChjKSAyMDE0LTIwMTcgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuLyogICovXG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIF90b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvKFteLV0pKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHJcbiAgICAucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJylcbiAgICAucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJylcbiAgICAudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuICovXG5mdW5jdGlvbiBiaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIGZuIGxlbmd0aFxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIE9CSkVDVF9TVFJJTkcgPSAnW29iamVjdCBPYmplY3RdJztcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSBPQkpFQ1RfU1RSSU5HXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogUmV0dXJuIHNhbWUgdmFsdWVcbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHBvc3NpYmxlIGNpcmN1bGFyIHJlZmVyZW5jZVxuICAgICAgcmV0dXJuIGEgPT09IGJcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4oKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBjb25maWcgPSB7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXNzZXQgdHlwZXMgdGhhdCBhIGNvbXBvbmVudCBjYW4gb3duLlxuICAgKi9cbiAgX2Fzc2V0VHlwZXM6IFtcbiAgICAnY29tcG9uZW50JyxcbiAgICAnZGlyZWN0aXZlJyxcbiAgICAnZmlsdGVyJ1xuICBdLFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGxpZmVjeWNsZSBob29rcy5cbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogW1xuICAgICdiZWZvcmVDcmVhdGUnLFxuICAgICdjcmVhdGVkJyxcbiAgICAnYmVmb3JlTW91bnQnLFxuICAgICdtb3VudGVkJyxcbiAgICAnYmVmb3JlVXBkYXRlJyxcbiAgICAndXBkYXRlZCcsXG4gICAgJ2JlZm9yZURlc3Ryb3knLFxuICAgICdkZXN0cm95ZWQnLFxuICAgICdhY3RpdmF0ZWQnLFxuICAgICdkZWFjdGl2YXRlZCdcbiAgXSxcblxuICAvKipcbiAgICogTWF4IGNpcmN1bGFyIHVwZGF0ZXMgYWxsb3dlZCBpbiBhIHNjaGVkdWxlciBmbHVzaCBjeWNsZS5cbiAgICovXG4gIF9tYXhVcGRhdGVDb3VudDogMTAwXG59O1xuXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cbi8qIGdsb2JhbHMgTXV0YXRpb25PYnNlcnZlciAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbnZhciBpc0FuZHJvaWQgPSBVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwO1xudmFyIGlzSU9TID0gVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxuLyoqXG4gKiBEZWZlciBhIHRhc2sgdG8gZXhlY3V0ZSBpdCBhc3luY2hyb25vdXNseS5cbiAqL1xudmFyIG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgdGltZXJGdW5jO1xuXG4gIGZ1bmN0aW9uIG5leHRUaWNrSGFuZGxlciAoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG4gIC8vIHZpYSBlaXRoZXIgbmF0aXZlIFByb21pc2UudGhlbiBvciBNdXRhdGlvbk9ic2VydmVyLlxuICAvLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbiAgLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcbiAgLy8gY29tcGxldGVseSBzdG9wcyB3b3JraW5nIGFmdGVyIHRyaWdnZXJpbmcgYSBmZXcgdGltZXMuLi4gc28sIGlmIG5hdGl2ZVxuICAvLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB2YXIgbG9nRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgfTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwLnRoZW4obmV4dFRpY2tIYW5kbGVyKS5jYXRjaChsb2dFcnJvcik7XG4gICAgICAvLyBpbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAgIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICAgIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSdcbiAgKSkge1xuICAgIC8vIHVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gICAgLy8gZS5nLiBQaGFudG9tSlMgSUUxMSwgaU9TNywgQW5kcm9pZCA0LjRcbiAgICB2YXIgY291bnRlciA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobmV4dFRpY2tIYW5kbGVyKTtcbiAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICAgIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gc2V0VGltZW91dFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChuZXh0VGlja0hhbmRsZXIsIDApO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcXVldWVOZXh0VGljayAoY2IsIGN0eCkge1xuICAgIHZhciBfcmVzb2x2ZTtcbiAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY2IpIHsgY2IuY2FsbChjdHgpOyB9XG4gICAgICBpZiAoX3Jlc29sdmUpIHsgX3Jlc29sdmUoY3R4KTsgfVxuICAgIH0pO1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICB0aW1lckZ1bmMoKTtcbiAgICB9XG4gICAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB9KVxuICAgIH1cbiAgfVxufSkoKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBmb3JtYXRDb21wb25lbnROYW1lO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIFwiIFwiICsgKFxuICAgICAgICB2bSA/IGZvcm1hdExvY2F0aW9uKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgXCIgXCIgKyAoXG4gICAgICAgIHZtID8gZm9ybWF0TG9jYXRpb24oZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5vcHRpb25zXG4gICAgICA/IHZtLm9wdGlvbnMubmFtZVxuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucy5uYW1lIHx8IHZtLiRvcHRpb25zLl9jb21wb25lbnRUYWdcbiAgICAgICAgOiB2bS5uYW1lO1xuXG4gICAgdmFyIGZpbGUgPSB2bS5faXNWdWUgJiYgdm0uJG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgZm9ybWF0TG9jYXRpb24gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gXCI8QW5vbnltb3VzPlwiKSB7XG4gICAgICBzdHIgKz0gXCIgLSB1c2UgdGhlIFxcXCJuYW1lXFxcIiBvcHRpb24gZm9yIGJldHRlciBkZWJ1Z2dpbmcgbWVzc2FnZXMuXCI7XG4gICAgfVxuICAgIHJldHVybiAoXCJcXG4oZm91bmQgaW4gXCIgKyBzdHIgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cblxudmFyIHVpZCQxID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkJDErKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXVxuLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIC8vIGF2b2lkIGxlYWtpbmcgYXJndW1lbnRzOlxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb3N1cmUtd2l0aC1hcmd1bWVudHNcbiAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50cyQxW2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcbiAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciB3aGVuIHBhc3NpbmcgZG93biBwcm9wcyxcbiAqIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvbiBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYmUgYSBuZXN0ZWQgdmFsdWVcbiAqIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLiBDb252ZXJ0aW5nIGl0IHdvdWxkIGRlZmVhdCB0aGUgb3B0aW1pemF0aW9uLlxuICovXG52YXIgb2JzZXJ2ZXJTdGF0ZSA9IHtcbiAgc2hvdWxkQ29udmVydDogdHJ1ZSxcbiAgaXNTZXR0aW5nUHJvcHM6IGZhbHNlXG59O1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyXG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gIHZhciBjaGlsZE9iID0gb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSB0YXJnZXQuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9IHRhcmdldC5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICBjaGlsZFZhbC5jYWxsKHRoaXMpLFxuICAgICAgICBwYXJlbnRWYWwuY2FsbCh0aGlzKVxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJlbnRWYWwgfHwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWxcbn1cblxuY29uZmlnLl9saWZlY3ljbGVIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gICAgOiByZXNcbn1cblxuY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG59KTtcblxuLyoqXG4gKiBXYXRjaGVycy5cbiAqXG4gKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAqL1xuc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleV07XG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5XTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5XSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGV4dGVuZChyZXQsIGNoaWxkVmFsKTtcbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFyIGxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGlzQnVpbHRJblRhZyhsb3dlcikgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobG93ZXIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2lkOiAnICsga2V5XG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMpIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBpLCB2YWwsIG5hbWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG4gIHZhciBleHRlbmRzRnJvbSA9IGNoaWxkLmV4dGVuZHM7XG4gIGlmIChleHRlbmRzRnJvbSkge1xuICAgIHBhcmVudCA9IHR5cGVvZiBleHRlbmRzRnJvbSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbS5vcHRpb25zLCB2bSlcbiAgICAgIDogbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgbWl4aW4gPSBjaGlsZC5taXhpbnNbaV07XG4gICAgICBpZiAobWl4aW4ucHJvdG90eXBlIGluc3RhbmNlb2YgVnVlJDMpIHtcbiAgICAgICAgbWl4aW4gPSBtaXhpbi5vcHRpb25zO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgbWl4aW4sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gaGFuZGxlIGJvb2xlYW4gcHJvcHNcbiAgaWYgKGlzVHlwZShCb29sZWFuLCBwcm9wLnR5cGUpKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaXNUeXBlKFN0cmluZywgcHJvcC50eXBlKSAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRDb252ZXJ0ID0gb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0O1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gcHJldlNob3VsZENvbnZlcnQ7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicgK1xuICAgICAgJyBFeHBlY3RlZCAnICsgZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSArXG4gICAgICAnLCBnb3QgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpICsgJy4nLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhlIHR5cGUgb2YgYSB2YWx1ZVxuICovXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSAnU3RyaW5nJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ3N0cmluZycpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdudW1iZXInKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdCb29sZWFuJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ2Jvb2xlYW4nKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdGdW5jdGlvbicpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdmdW5jdGlvbicpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV1cbn1cblxuZnVuY3Rpb24gaXNUeXBlICh0eXBlLCBmbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZm4pKSB7XG4gICAgcmV0dXJuIGdldFR5cGUoZm4pID09PSBnZXRUeXBlKHR5cGUpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGdldFR5cGUoZm5baV0pID09PSBnZXRUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6XCIpLCB2bSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG52YXIgaW5pdFByb3h5O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgIFwicmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdG8gZGVjbGFyZSByZWFjdGl2ZSBkYXRhIFwiICtcbiAgICAgIFwicHJvcGVydGllcyBpbiB0aGUgZGF0YSBvcHRpb24uXCIsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIFByb3h5LnRvU3RyaW5nKCkubWF0Y2goL25hdGl2ZSBjb2RlLyk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YScpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gJ18nO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpO1xuICAgIH07XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zXG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZnVuY3Rpb25hbENvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDoge30gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9ICcnO1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnNcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbmZ1bmN0aW9uIGNsb25lVk5vZGVzICh2bm9kZXMpIHtcbiAgdmFyIGxlbiA9IHZub2Rlcy5sZW5ndGg7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc1tpXSA9IGNsb25lVk5vZGUodm5vZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZuc1tpXS5hcHBseShudWxsLCBhcmd1bWVudHMkMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGN1ciwgb2xkLCBldmVudDtcbiAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgY3VyID0gb25bbmFtZV07XG4gICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICBpZiAoIWN1cikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghb2xkKSB7XG4gICAgICBpZiAoIWN1ci5mbnMpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyKTtcbiAgICAgIH1cbiAgICAgIGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50Lm9uY2UsIGV2ZW50LmNhcHR1cmUpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKCFvbltuYW1lXSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIHZhciBpbnZva2VyO1xuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKCFvbGRIb29rKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKG9sZEhvb2suZm5zICYmIG9sZEhvb2subWVyZ2VkKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGksIGMsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoYyA9PSBudWxsIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpIHsgY29udGludWUgfVxuICAgIGxhc3QgPSByZXNbcmVzLmxlbmd0aCAtIDFdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSkpO1xuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcbiAgICAgIGlmIChsYXN0ICYmIGxhc3QudGV4dCkge1xuICAgICAgICBsYXN0LnRleHQgKz0gU3RyaW5nKGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYy50ZXh0ICYmIGxhc3QgJiYgbGFzdC50ZXh0KSB7XG4gICAgICAgIHJlc1tyZXMubGVuZ3RoIC0gMV0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChjLnRhZyAmJiBjLmtleSA9PSBudWxsICYmIG5lc3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgJiYgYy5jb21wb25lbnRPcHRpb25zOyB9KVswXVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuLCBvbmNlJCQxKSB7XG4gIGlmIChvbmNlJCQxKSB7XG4gICAgdGFyZ2V0LiRvbmNlKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgdm0pO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICB0aGlzJDEuJG9mZihldmVudFtpJDFdLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY2JzW2ldLmFwcGx5KHZtLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICB2YXIgZGVmYXVsdFNsb3QgPSBbXTtcbiAgdmFyIG5hbWUsIGNoaWxkO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mdW5jdGlvbmFsQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgICAgY2hpbGQuZGF0YSAmJiAobmFtZSA9IGNoaWxkLmRhdGEuc2xvdCkpIHtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWZhdWx0U2xvdC5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHdoaXRlc3BhY2VcbiAgaWYgKCFkZWZhdWx0U2xvdC5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgc2xvdHMuZGVmYXVsdCA9IGRlZmF1bHRTbG90O1xuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50IHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gIGZuc1xuKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICByZXNbZm5zW2ldWzBdXSA9IGZuc1tpXVsxXTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgobmFtZSArIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICB2bS5fd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3ApO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlblxuICB2YXIgaGFzQ2hpbGRyZW4gPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgLy8gaGFzIG5ldyBzY29wZWQgc2xvdHNcbiAgICB2bS4kc2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0IC8vIGhhcyBvbGQgc2NvcGVkIHNsb3RzXG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgb2JzZXJ2ZXJTdGF0ZS5pc1NldHRpbmdQcm9wcyA9IHRydWU7XG4gICAgfVxuICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHZtLiRvcHRpb25zLnByb3BzLCBwcm9wc0RhdGEsIHZtKTtcbiAgICB9XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgb2JzZXJ2ZXJTdGF0ZS5pc1NldHRpbmdQcm9wcyA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG4gIH1cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHZtKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChob29rICsgXCIgaG9va1wiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIHF1ZXVlLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8qKlxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xuICBmbHVzaGluZyA9IHRydWU7XG4gIHZhciB3YXRjaGVyLCBpZCwgdm07XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBjb25maWcuX21heFVwZGF0ZUNvdW50KSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGNhbGwgdXBkYXRlZCBob29rc1xuICBpbmRleCA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPj0gMCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKE1hdGgubWF4KGksIGluZGV4KSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnNcbikge1xuICB0aGlzLnZtID0gdm07XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KCk7XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgcHVzaFRhcmdldCh0aGlzKTtcbiAgdmFyIHZhbHVlO1xuICB2YXIgdm0gPSB0aGlzLnZtO1xuICBpZiAodGhpcy51c2VyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgfVxuICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gIGlmICh0aGlzLmRlZXApIHtcbiAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gIH1cbiAgcG9wVGFyZ2V0KCk7XG4gIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgcmV0dXJuIHZhbHVlXG59O1xuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZDtcbiAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuY2xlYW51cERlcHMgPSBmdW5jdGlvbiBjbGVhbnVwRGVwcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMkMS5kZXBzW2ldO1xuICAgIGlmICghdGhpcyQxLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcyQxLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzJDEuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG4gIH07XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XG4gIGlmIChvcHRzLmRhdGEpIHtcbiAgICBpbml0RGF0YSh2bSk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICB9XG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgaWYgKG9wdHMud2F0Y2gpIHsgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTsgfVxufVxuXG52YXIgaXNSZXNlcnZlZFByb3AgPSB7IGtleTogMSwgcmVmOiAxLCBzbG90OiAxIH07XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGlzUm9vdDtcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJvcFtrZXldKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bS4kcGFyZW50ICYmICFvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGRhdGEuY2FsbCh2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5c1tpXSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyAoa2V5c1tpXSkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5c1tpXSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleXNbaV0pO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcih2bSwgZ2V0dGVyLCBub29wLCBjb21wdXRlZFdhdGNoZXJPcHRpb25zKTtcblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKHRhcmdldCwga2V5LCB1c2VyRGVmKSB7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiB1c2VyRGVmLmdldFxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgPyB1c2VyRGVmLnNldFxuICAgICAgOiBub29wO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgdm1ba2V5XSA9IG1ldGhvZHNba2V5XSA9PSBudWxsID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAodm0sIGtleSwgaGFuZGxlcikge1xuICB2YXIgb3B0aW9ucztcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgdm0uJHdhdGNoKGtleSwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuLy8gaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuICAgIHZub2RlLFxuICAgIGh5ZHJhdGluZyxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtXG4gICkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50RWxtLFxuICAgICAgICByZWZFbG1cbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2sodm5vZGUuY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm5vZGUuY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmICghQ3Rvcikge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgaWYgKCFDdG9yLmNpZCkge1xuICAgIGlmIChDdG9yLnJlc29sdmVkKSB7XG4gICAgICBDdG9yID0gQ3Rvci5yZXNvbHZlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChDdG9yLCBiYXNlQ3RvciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBpdCdzIG9rIHRvIHF1ZXVlIHRoaXMgb24gZXZlcnkgcmVuZGVyIGJlY2F1c2VcbiAgICAgICAgLy8gJGZvcmNlVXBkYXRlIGlzIGJ1ZmZlcmVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gICAgICAgIGNvbnRleHQuJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIGlmICghQ3Rvcikge1xuICAgICAgICAvLyByZXR1cm4gbm90aGluZyBpZiB0aGlzIGlzIGluZGVlZCBhbiBhc3luYyBjb21wb25lbnRcbiAgICAgICAgLy8gd2FpdCBmb3IgdGhlIGNhbGxiYWNrIHRvIHRyaWdnZXIgcGFyZW50IHVwZGF0ZS5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChkYXRhLm1vZGVsKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wcyhkYXRhLCBDdG9yKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChDdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVyc1xuICAgIGRhdGEgPSB7fTtcbiAgfVxuXG4gIC8vIG1lcmdlIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgbWVyZ2VIb29rcyhkYXRhKTtcblxuICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxuICB2YXIgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcbiAgdmFyIHZub2RlID0gbmV3IFZOb2RlKFxuICAgIChcInZ1ZS1jb21wb25lbnQtXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXCItXCIgKyBuYW1lKSA6ICcnKSksXG4gICAgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9XG4gICk7XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChwcm9wT3B0aW9ucykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEpO1xuICAgIH1cbiAgfVxuICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gIC8vIGdldHMgYSB1bmlxdWUgY29udGV4dCAtIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjb3JyZWN0IG5hbWVkIHNsb3QgY2hlY2tcbiAgdmFyIF9jb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShjb250ZXh0KTtcbiAgdmFyIGggPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChfY29udGV4dCwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG4gIHZhciB2bm9kZSA9IEN0b3Iub3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCBoLCB7XG4gICAgcHJvcHM6IHByb3BzLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgcGFyZW50OiBjb250ZXh0LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBzbG90czogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBjb250ZXh0KTsgfVxuICB9KTtcbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICB2bm9kZS5mdW5jdGlvbmFsQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgaWYgKGRhdGEuc2xvdCkge1xuICAgICAgKHZub2RlLmRhdGEgfHwgKHZub2RlLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgfVxuICB9XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRFbG0sXG4gIHJlZkVsbVxuKSB7XG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgcHJvcHNEYXRhOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhLFxuICAgIF9jb21wb25lbnRUYWc6IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWcsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBfcGFyZW50TGlzdGVuZXJzOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzLFxuICAgIF9yZW5kZXJDaGlsZHJlbjogdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuLFxuICAgIF9wYXJlbnRFbG06IHBhcmVudEVsbSB8fCBudWxsLFxuICAgIF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGVDb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNiXG4pIHtcbiAgaWYgKGZhY3RvcnkucmVxdWVzdGVkKSB7XG4gICAgLy8gcG9vbCBjYWxsYmFja3NcbiAgICBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MucHVzaChjYik7XG4gIH0gZWxzZSB7XG4gICAgZmFjdG9yeS5yZXF1ZXN0ZWQgPSB0cnVlO1xuICAgIHZhciBjYnMgPSBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MgPSBbY2JdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcblxuICAgIHZhciByZXNvbHZlID0gZnVuY3Rpb24gKHJlcykge1xuICAgICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgICAgcmVzID0gYmFzZUN0b3IuZXh0ZW5kKHJlcyk7XG4gICAgICB9XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IHJlcztcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNic1tpXShyZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgLy8gaGFuZGxlIHByb21pc2VcbiAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJiAhZmFjdG9yeS5yZXNvbHZlZCkge1xuICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzIChkYXRhLCBDdG9yKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BPcHRpb25zKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICB2YXIgZG9tUHJvcHMgPSBkYXRhLmRvbVByb3BzO1xuICBpZiAoYXR0cnMgfHwgcHJvcHMgfHwgZG9tUHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuICAgICAgICAgIGF0dHJzICYmIGF0dHJzLmhhc093blByb3BlcnR5KGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIG5vdCBkZWNsYXJlZCBpbiBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUoQ3RvcikpICsgXCIuIE5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIFwiICtcbiAgICAgICAgICAgIFwiY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIFwiICtcbiAgICAgICAgICAgIFwiZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcIiArXG4gICAgICAgICAgICBcIlxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGRvbVByb3BzLCBrZXksIGFsdEtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaGFzaCkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9va3MgKGRhdGEpIHtcbiAgaWYgKCFkYXRhLmhvb2spIHtcbiAgICBkYXRhLmhvb2sgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGZyb21QYXJlbnQgPSBkYXRhLmhvb2tba2V5XTtcbiAgICB2YXIgb3VycyA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBkYXRhLmhvb2tba2V5XSA9IGZyb21QYXJlbnQgPyBtZXJnZUhvb2skMShvdXJzLCBmcm9tUGFyZW50KSA6IG91cnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgIG9uZShhLCBiLCBjLCBkKTtcbiAgICB0d28oYSwgYiwgYywgZCk7XG4gIH1cbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBpZiAob25bZXZlbnRdKSB7XG4gICAgb25bZXZlbnRdID0gW2RhdGEubW9kZWwuY2FsbGJhY2tdLmNvbmNhdChvbltldmVudF0pO1xuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxuICBhbHdheXNOb3JtYWxpemVcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGFsd2F5c05vcm1hbGl6ZSkgeyBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7IH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGRhdGEgJiYgZGF0YS5fX29iX18pIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgaWYgKCF0YWcpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICB2YXIgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgQ3RvcjtcbiAgICBucyA9IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAodm5vZGUpIHtcbiAgICBpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucykge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm5vZGUuY2hpbGRyZW4pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQudGFnICYmICFjaGlsZC5ucykge1xuICAgICAgICBhcHBseU5TKGNoaWxkLCBucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuICB2YWwsXG4gIHJlbmRlclxuKSB7XG4gIHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGV4dGVuZChwcm9wcywgYmluZE9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3ROb2RlcyA9IHRoaXMuJHNsb3RzW25hbWVdO1xuICAgIC8vIHdhcm4gZHVwbGljYXRlIHNsb3QgdXNhZ2VcbiAgICBpZiAoc2xvdE5vZGVzICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHNsb3ROb2Rlcy5fcmVuZGVyZWQgJiYgd2FybihcbiAgICAgICAgXCJEdXBsaWNhdGUgcHJlc2VuY2Ugb2Ygc2xvdCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGZvdW5kIGluIHRoZSBzYW1lIHJlbmRlciB0cmVlIFwiICtcbiAgICAgICAgXCItIHRoaXMgd2lsbCBsaWtlbHkgY2F1c2UgcmVuZGVyIGVycm9ycy5cIixcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICAgIHNsb3ROb2Rlcy5fcmVuZGVyZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc2xvdE5vZGVzIHx8IGZhbGxiYWNrXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIgKGlkKSB7XG4gIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHlcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5BbGlhc1xuKSB7XG4gIHZhciBrZXlDb2RlcyA9IGNvbmZpZy5rZXlDb2Rlc1trZXldIHx8IGJ1aWx0SW5BbGlhcztcbiAgaWYgKEFycmF5LmlzQXJyYXkoa2V5Q29kZXMpKSB7XG4gICAgcmV0dXJuIGtleUNvZGVzLmluZGV4T2YoZXZlbnRLZXlDb2RlKSA9PT0gLTFcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ga2V5Q29kZXMgIT09IGV2ZW50S2V5Q29kZVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIHYtYmluZD1cIm9iamVjdFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGJpbmRPYmplY3RQcm9wcyAoXG4gIGRhdGEsXG4gIHRhZyxcbiAgdmFsdWUsXG4gIGFzUHJvcFxuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoO1xuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgdmFyIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZSBieSBkb2luZyBhIHNoYWxsb3cgY2xvbmUuXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodHJlZSlcbiAgICAgID8gY2xvbmVWTm9kZXModHJlZSlcbiAgICAgIDogY2xvbmVWTm9kZSh0cmVlKVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XSA9XG4gICAgdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwodGhpcy5fcmVuZGVyUHJveHkpO1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICByZXR1cm4gdHJlZVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAqL1xuZnVuY3Rpb24gbWFya09uY2UgKFxuICB0cmVlLFxuICBpbmRleCxcbiAga2V5XG4pIHtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICB0cmVlLFxuICBrZXksXG4gIGlzT25jZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLmlzT25jZSA9IGlzT25jZTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLiR2bm9kZSA9IG51bGw7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7XG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHModm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XG5cbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgLy8gY2xvbmUgc2xvdCBub2RlcyBvbiByZS1yZW5kZXJzXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdm0uJHNsb3RzKSB7XG4gICAgICAgIHZtLiRzbG90c1trZXldID0gY2xvbmVWTm9kZXModm0uJHNsb3RzW2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZtLiRzY29wZWRTbG90cyA9IChfcGFyZW50Vm5vZGUgJiYgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMpIHx8IGVtcHR5T2JqZWN0O1xuXG4gICAgaWYgKHN0YXRpY1JlbmRlckZucyAmJiAhdm0uX3N0YXRpY1RyZWVzKSB7XG4gICAgICB2bS5fc3RhdGljVHJlZXMgPSBbXTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIHZhciB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXIgZnVuY3Rpb25cIik7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvclxuICAgICAgICAgID8gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKVxuICAgICAgICAgIDogdm0uX3Zub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudFxuICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfTtcblxuICAvLyBpbnRlcm5hbCByZW5kZXIgaGVscGVycy5cbiAgLy8gdGhlc2UgYXJlIGV4cG9zZWQgb24gdGhlIGluc3RhbmNlIHByb3RvdHlwZSB0byByZWR1Y2UgZ2VuZXJhdGVkIHJlbmRlclxuICAvLyBjb2RlIHNpemUuXG4gIFZ1ZS5wcm90b3R5cGUuX28gPSBtYXJrT25jZTtcbiAgVnVlLnByb3RvdHlwZS5fbiA9IHRvTnVtYmVyO1xuICBWdWUucHJvdG90eXBlLl9zID0gX3RvU3RyaW5nO1xuICBWdWUucHJvdG90eXBlLl9sID0gcmVuZGVyTGlzdDtcbiAgVnVlLnByb3RvdHlwZS5fdCA9IHJlbmRlclNsb3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3EgPSBsb29zZUVxdWFsO1xuICBWdWUucHJvdG90eXBlLl9pID0gbG9vc2VJbmRleE9mO1xuICBWdWUucHJvdG90eXBlLl9tID0gcmVuZGVyU3RhdGljO1xuICBWdWUucHJvdG90eXBlLl9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgVnVlLnByb3RvdHlwZS5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIFZ1ZS5wcm90b3R5cGUuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIFZ1ZS5wcm90b3R5cGUuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIFZ1ZS5wcm90b3R5cGUuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICBWdWUucHJvdG90eXBlLl91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIHZhciBpbmplY3QgPSB2bS4kb3B0aW9ucy5pbmplY3Q7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIC8vIGlzQXJyYXkgaGVyZVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShpbmplY3QpO1xuICAgIHZhciBrZXlzID0gaXNBcnJheVxuICAgICAgPyBpbmplY3RcbiAgICAgIDogaGFzU3ltYm9sXG4gICAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaXNBcnJheSA/IGtleSA6IGluamVjdFtrZXldO1xuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBwcm92aWRlS2V5IGluIHNvdXJjZS5fcHJvdmlkZWQpIHtcbiAgICAgICAgICB2bVtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBtYXJrKCd2dWUtcGVyZi1pbml0Jyk7XG4gICAgfVxuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQrKztcbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyaygndnVlLXBlcmYtaW5pdC1lbmQnKTtcbiAgICAgIG1lYXN1cmUoKCh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCAndnVlLXBlcmYtaW5pdCcsICd2dWUtcGVyZi1pbml0LWVuZCcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMucHJvcHNEYXRhID0gb3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSBvcHRpb25zLl9yZW5kZXJDaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICBvcHRzLl9wYXJlbnRFbG0gPSBvcHRpb25zLl9wYXJlbnRFbG07XG4gIG9wdHMuX3JlZkVsbSA9IG9wdGlvbnMuX3JlZkVsbTtcbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBzZWFsZWRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgc2VhbGVkKSB7XG4gIC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXG4gIC8vIGJldHdlZW4gbWVyZ2VzXG4gIGlmIChBcnJheS5pc0FycmF5KGxhdGVzdCkpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzZWFsZWQuaW5kZXhPZihsYXRlc3RbaV0pIDwgMCkge1xuICAgICAgICByZXMucHVzaChsYXRlc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhdGVzdFxuICB9XG59XG5cbmZ1bmN0aW9uIFZ1ZSQzIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlJDMpKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUkMyk7XG5zdGF0ZU1peGluKFZ1ZSQzKTtcbmV2ZW50c01peGluKFZ1ZSQzKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSQzKTtcbnJlbmRlck1peGluKFZ1ZSQzKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwbHVnaW4uaW5zdGFsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAgICAgJ2FuZCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgY29uZmlnLmlzUmVzZXJ2ZWRUYWcoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAgICAgJ2lkOiAnICsgaWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cF07XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoY2FjaGUsIGZpbHRlcikge1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGVkTm9kZSk7XG4gICAgICAgIGNhY2hlW2tleV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKHZub2RlKSB7XG4gIGlmICh2bm9kZSkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2luYWN0aXZlKSB7XG4gICAgICBjYWxsSG9vayh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSwgJ2RlYWN0aXZhdGVkJyk7XG4gICAgfVxuICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbn1cblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXNcbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlW2tleV0pO1xuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGluY2x1ZGU6IGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9LFxuICAgIGV4Y2x1ZGU6IGZ1bmN0aW9uIGV4Y2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgKFxuICAgICAgICAodGhpcy5pbmNsdWRlICYmICFtYXRjaGVzKHRoaXMuaW5jbHVkZSwgbmFtZSkpIHx8XG4gICAgICAgICh0aGlzLmV4Y2x1ZGUgJiYgbWF0Y2hlcyh0aGlzLmV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmICh0aGlzLmNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLmNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgIH1cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUkMyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5WdWUkMy52ZXJzaW9uID0gJzIuMi40JztcblxuLyogICovXG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ2VuQ2xhc3NGcm9tRGF0YShkYXRhKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGNoaWxkLmNsYXNzXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5DbGFzc0Zyb21EYXRhIChkYXRhKSB7XG4gIHZhciBkeW5hbWljQ2xhc3MgPSBkYXRhLmNsYXNzO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBkYXRhLnN0YXRpY0NsYXNzO1xuICBpZiAoc3RhdGljQ2xhc3MgfHwgZHluYW1pY0NsYXNzKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgc3RyaW5naWZpZWQ7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZVtpXSkge1xuICAgICAgICBpZiAoKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSkge1xuICAgICAgICAgIHJlcyArPSBzdHJpbmdpZmllZCArICcgJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtrZXldKSB7IHJlcyArPSBrZXkgKyAnICc7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG52YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcgPT09ICdwcmUnOyB9O1xuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5vZGUsIGtleSwgdmFsKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbn1cblxuXG52YXIgbm9kZU9wcyA9IE9iamVjdC5mcmVlemUoe1xuXHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG5cdGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG5cdGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG5cdGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuXHRyZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG5cdGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcblx0cGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcblx0bmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuXHR0YWdOYW1lOiB0YWdOYW1lLFxuXHRzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG5cdHNldEF0dHJpYnV0ZTogc2V0QXR0cmlidXRlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICgha2V5KSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSAmJiByZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuXG4vKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIGlzVW5kZWYgKHMpIHtcbiAgcmV0dXJuIHMgPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAocykge1xuICByZXR1cm4gcyAhPSBudWxsXG59XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAodm5vZGUxLCB2bm9kZTIpIHtcbiAgcmV0dXJuIChcbiAgICB2bm9kZTEua2V5ID09PSB2bm9kZTIua2V5ICYmXG4gICAgdm5vZGUxLnRhZyA9PT0gdm5vZGUyLnRhZyAmJlxuICAgIHZub2RlMS5pc0NvbW1lbnQgPT09IHZub2RlMi5pc0NvbW1lbnQgJiZcbiAgICAhdm5vZGUxLmRhdGEgPT09ICF2bm9kZTIuZGF0YVxuICApXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICB2YXIgaSwga2V5O1xuICB2YXIgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICB2YXIgaSwgajtcbiAgdmFyIGNicyA9IHt9O1xuXG4gIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChtb2R1bGVzW2pdW2hvb2tzW2ldXSAhPT0gdW5kZWZpbmVkKSB7IGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZSQkMSAoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUkJDEubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmUkJDFcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5QcmUgPSAwO1xuICBmdW5jdGlvbiBjcmVhdGVFbG0gKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQpIHtcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBpblByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaW5QcmUgJiZcbiAgICAgICAgICAhdm5vZGUubnMgJiZcbiAgICAgICAgICAhKGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuaW5kZXhPZih0YWcpID4gLTEpICYmXG4gICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodGFnKVxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgaW5QcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZub2RlLmlzQ29tbWVudCkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzUmVhY3RpdmF0ZWQpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYpIHtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpLmNyZWF0ZSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGkuaW5zZXJ0KSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICAgIH1cbiAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgIH1cbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChybSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmICghcm0pIHtcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgZWxtVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldIDogbnVsbDtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsbVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhZWxtVG9Nb3ZlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnSXQgc2VlbXMgdGhlcmUgYXJlIGR1cGxpY2F0ZSBrZXlzIHRoYXQgaXMgY2F1c2luZyBhbiB1cGRhdGUgZXJyb3IuICcgK1xuICAgICAgICAgICAgICAnTWFrZSBzdXJlIGVhY2ggdi1mb3IgaXRlbSBoYXMgYSB1bmlxdWUga2V5LidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzYW1lVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgbmV3U3RhcnRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKHZub2RlLmlzU3RhdGljICYmXG4gICAgICAgIG9sZFZub2RlLmlzU3RhdGljICYmXG4gICAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAgICh2bm9kZS5pc0Nsb25lZCB8fCB2bm9kZS5pc09uY2UpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgaGFzRGF0YSA9IGlzRGVmKGRhdGEpO1xuICAgIGlmIChoYXNEYXRhICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChoYXNEYXRhICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaGFzRGF0YSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaW5pdGlhbCAmJiB2bm9kZS5wYXJlbnQpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsc3R5bGUsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cbiAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cbiAgZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICB2bm9kZS5lbG0gPSBlbG07XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWJhaWxlZCkge1xuICAgICAgICAgICAgICBiYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHxcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoIXZub2RlKSB7XG4gICAgICBpZiAob2xkVm5vZGUpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoIW9sZFZub2RlKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoJ3NlcnZlci1yZW5kZXJlZCcpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3NlcnZlci1yZW5kZXJlZCcpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGh5ZHJhdGluZykge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodm5vZGUucGFyZW50KSB7XG4gICAgICAgICAgLy8gY29tcG9uZW50IHJvb3QgZWxlbWVudCByZXBsYWNlZC5cbiAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZS5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJlbnRFbG0kMSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0kMSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKCFvbGRWbm9kZS5kYXRhLmF0dHJzICYmICF2bm9kZS5kYXRhLmF0dHJzKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoYXR0cnMuX19vYl9fKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRTkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChhdHRyc1trZXldID09IG51bGwpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwga2V5KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoIWRhdGEuc3RhdGljQ2xhc3MgJiYgIWRhdGEuY2xhc3MgJiZcbiAgICAgICghb2xkRGF0YSB8fCAoIW9sZERhdGEuc3RhdGljQ2xhc3MgJiYgIW9sZERhdGEuY2xhc3MpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKHRyYW5zaXRpb25DbGFzcykge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIFwiLFwiICsgYXJncylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZykge1xuICBjb25zb2xlLmVycm9yKChcIltWdWUgY29tcGlsZXJdOiBcIiArIG1zZykpO1xufVxuXG5mdW5jdGlvbiBwbHVja01vZHVsZUZ1bmN0aW9uIChcbiAgbW9kdWxlcyxcbiAga2V5XG4pIHtcbiAgcmV0dXJuIG1vZHVsZXNcbiAgICA/IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtW2tleV07IH0pLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfSlcbiAgICA6IFtdXG59XG5cbmZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwucHJvcHMgfHwgKGVsLnByb3BzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgcmF3TmFtZTogcmF3TmFtZSwgdmFsdWU6IHZhbHVlLCBhcmc6IGFyZywgbW9kaWZpZXJzOiBtb2RpZmllcnMgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICBlbCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIG1vZGlmaWVycyxcbiAgaW1wb3J0YW50XG4pIHtcbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSAnIScgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxuICB9XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9ICd+JyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIG9uY2VcbiAgfVxuICB2YXIgZXZlbnRzO1xuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcbiAgfVxuICB2YXIgbmV3SGFuZGxlciA9IHsgdmFsdWU6IHZhbHVlLCBtb2RpZmllcnM6IG1vZGlmaWVycyB9O1xuICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgZ2V0U3RhdGljXG4pIHtcbiAgdmFyIGR5bmFtaWNWYWx1ZSA9XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHxcbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1iaW5kOicgKyBuYW1lKTtcbiAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpXG4gIH0gZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xuICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIgKGVsLCBuYW1lKSB7XG4gIHZhciB2YWw7XG4gIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcbiAgICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAobGlzdFtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9XG4gICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgICBcIj8gXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIudHJpbSgpXCIgK1xuICAgICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICB2YXIgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG4gIGVsLm1vZGVsID0ge1xuICAgIHZhbHVlOiAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSxcbiAgICBleHByZXNzaW9uOiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSxcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG4gIH07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcbiAgdmFsdWUsXG4gIGFzc2lnbm1lbnRcbikge1xuICB2YXIgbW9kZWxScyA9IHBhcnNlTW9kZWwodmFsdWUpO1xuICBpZiAobW9kZWxScy5pZHggPT09IG51bGwpIHtcbiAgICByZXR1cm4gKHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcInZhciAkJGV4cCA9IFwiICsgKG1vZGVsUnMuZXhwKSArIFwiLCAkJGlkeCA9IFwiICsgKG1vZGVsUnMuaWR4KSArIFwiO1wiICtcbiAgICAgIFwiaWYgKCFBcnJheS5pc0FycmF5KCQkZXhwKSl7XCIgK1xuICAgICAgICB2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudCArIFwifVwiICtcbiAgICAgIFwiZWxzZXskJGV4cC5zcGxpY2UoJCRpZHgsIDEsIFwiICsgYXNzaWdubWVudCArIFwiKX1cIlxuICB9XG59XG5cbi8qKlxuICogcGFyc2UgZGlyZWN0aXZlIG1vZGVsIHRvIGRvIHRoZSBhcnJheSB1cGRhdGUgdHJhbnNmb3JtLiBhW2lkeF0gPSB2YWwgPT4gJCRhLnNwbGljZSgkJGlkeCwgMSwgdmFsKVxuICpcbiAqIGZvciBsb29wIHBvc3NpYmxlIGNhc2VzOlxuICpcbiAqIC0gdGVzdFxuICogLSB0ZXN0W2lkeF1cbiAqIC0gdGVzdFt0ZXN0MVtpZHhdXVxuICogLSB0ZXN0W1wiYVwiXVtpZHhdXG4gKiAtIHh4eC50ZXN0W2FbYV0udGVzdDFbaWR4XV1cbiAqIC0gdGVzdC54eHguYVtcImFzYVwiXVt0ZXN0MVtpZHhdXVxuICpcbiAqL1xuXG52YXIgbGVuO1xudmFyIHN0cjtcbnZhciBjaHI7XG52YXIgaW5kZXgkMTtcbnZhciBleHByZXNzaW9uUG9zO1xudmFyIGV4cHJlc3Npb25FbmRQb3M7XG5cbmZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuICBzdHIgPSB2YWw7XG4gIGxlbiA9IHN0ci5sZW5ndGg7XG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgaWYgKHZhbC5pbmRleE9mKCdbJykgPCAwIHx8IHZhbC5sYXN0SW5kZXhPZignXScpIDwgbGVuIC0gMSkge1xuICAgIHJldHVybiB7XG4gICAgICBleHA6IHZhbCxcbiAgICAgIGlkeDogbnVsbFxuICAgIH1cbiAgfVxuXG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICB9IGVsc2UgaWYgKGNociA9PT0gMHg1Qikge1xuICAgICAgcGFyc2VCcmFja2V0KGNocik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHA6IHZhbC5zdWJzdHJpbmcoMCwgZXhwcmVzc2lvblBvcyksXG4gICAgaWR4OiB2YWwuc3Vic3RyaW5nKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHQgKCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxufVxuXG5mdW5jdGlvbiBlb2YgKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIHZhciBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cbiAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcbiAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbmZ1bmN0aW9uIG1vZGVsIChcbiAgZWwsXG4gIGRpcixcbiAgX3dhcm5cbikge1xuICB3YXJuJDEgPSBfd2FybjtcbiAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgdmFyIHRhZyA9IGVsLnRhZztcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGR5bmFtaWNUeXBlID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiBkeW5hbWljVHlwZSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxpbnB1dCA6dHlwZT1cXFwiXCIgKyBkeW5hbWljVHlwZSArIFwiXFxcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjpcXG5cIiArXG4gICAgICAgIFwidi1tb2RlbCBkb2VzIG5vdCBzdXBwb3J0IGR5bmFtaWMgaW5wdXQgdHlwZXMuIFVzZSB2LWlmIGJyYW5jaGVzIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuICAgIC8vIHZhbHVlIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnZmlsZScpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgdHlwZT1cXFwiZmlsZVxcXCI+OlxcblwiICtcbiAgICAgICAgXCJGaWxlIGlucHV0cyBhcmUgcmVhZCBvbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAoIWNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQxKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICBcInYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gXCIgK1xuICAgICAgJ0lmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXRcXCdzIHJlY29tbWVuZGVkIHRvICcgK1xuICAgICAgJ3dyYXAgYSBsaWJyYXJ5IGRlZGljYXRlZCBmb3IgdGhhdCBwdXJwb3NlIGluc2lkZSBhIGN1c3RvbSBjb21wb25lbnQuJ1xuICAgICk7XG4gIH1cblxuICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gIHZhciBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG4gICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXG4gICAgICApXG4gICk7XG4gIGFkZEhhbmRsZXIoZWwsIENIRUNLQk9YX1JBRElPX1RPS0VOLFxuICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xuICAgICAgICAnJCRlbD0kZXZlbnQudGFyZ2V0LCcgK1xuICAgICAgICBcIiQkYz0kJGVsLmNoZWNrZWQ/KFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKTooXCIgKyBmYWxzZVZhbHVlQmluZGluZyArIFwiKTtcIiArXG4gICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG4gICAgICBcInZhciAkJHY9XCIgKyAobnVtYmVyID8gJ19uKCcgKyB2YWx1ZUJpbmRpbmcgKyAnKScgOiB2YWx1ZUJpbmRpbmcpICsgXCIsXCIgK1xuICAgICAgICAgICckJGk9X2koJCRhLCQkdik7JyArXG4gICAgICBcImlmKCQkYyl7JCRpPDAmJihcIiArIHZhbHVlICsgXCI9JCRhLmNvbmNhdCgkJHYpKX1cIiArXG4gICAgICBcImVsc2V7JCRpPi0xJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpKX1cIiArXG4gICAgXCJ9ZWxzZXtcIiArIHZhbHVlICsgXCI9JCRjfVwiLFxuICAgIG51bGwsIHRydWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2VuUmFkaW9Nb2RlbCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gKFwiX24oXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikgOiB2YWx1ZUJpbmRpbmc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgQ0hFQ0tCT1hfUkFESU9fVE9LRU4sIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICBcIi5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pXCIgK1xuICAgIFwiLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXFxcIl92YWx1ZVxcXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gIHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XG4gIHZhciBjb2RlID0gXCJ2YXIgJCRzZWxlY3RlZFZhbCA9IFwiICsgc2VsZWN0ZWRWYWwgKyBcIjtcIjtcbiAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbGF6eSA9IHJlZi5sYXp5O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcbiAgdmFyIG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcbiAgdmFyIGV2ZW50ID0gbGF6eVxuICAgID8gJ2NoYW5nZSdcbiAgICA6IHR5cGUgPT09ICdyYW5nZSdcbiAgICAgID8gUkFOR0VfVE9LRU5cbiAgICAgIDogJ2lucHV0JztcblxuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gJyRldmVudC50YXJnZXQudmFsdWUnO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG5cbiAgdmFyIGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcbiAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgY29kZSA9IFwiaWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpcmV0dXJuO1wiICsgY29kZTtcbiAgfVxuXG4gIGFkZFByb3AoZWwsICd2YWx1ZScsIChcIihcIiArIHZhbHVlICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xuICBpZiAodHJpbSB8fCBudW1iZXIgfHwgdHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICB9XG59XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICB2YXIgZXZlbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAob25bUkFOR0VfVE9LRU5dKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gIH1cbiAgaWYgKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkge1xuICAgIC8vIENocm9tZSBmaXJlcyBtaWNyb3Rhc2tzIGluIGJldHdlZW4gY2xpY2svY2hhbmdlLCBsZWFkcyB0byAjNDUyMVxuICAgIGV2ZW50ID0gaXNDaHJvbWUgPyAnY2xpY2snIDogJ2NoYW5nZSc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gYWRkJDEgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgb25jZSxcbiAgY2FwdHVyZVxuKSB7XG4gIGlmIChvbmNlKSB7XG4gICAgdmFyIG9sZEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gICAgaGFuZGxlciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICAgICAgPyBvbGRIYW5kbGVyKGV2KVxuICAgICAgICA6IG9sZEhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlJDIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmICghb2xkVm5vZGUuZGF0YS5vbiAmJiAhdm5vZGUuZGF0YS5vbikge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIHZub2RlLmNvbnRleHQpO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmICghb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyAmJiAhdm5vZGUuZGF0YS5kb21Qcm9wcykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChwcm9wcy5fX29iX18pIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKHByb3BzW2tleV0gPT0gbnVsbCkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGN1ciA9PSBudWxsID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHZub2RlLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChcbiAgZWxtLFxuICB2bm9kZSxcbiAgY2hlY2tWYWxcbikge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICB2bm9kZS50YWcgPT09ICdvcHRpb24nIHx8XG4gICAgaXNEaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzSW5wdXRDaGFuZ2VkKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpcyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbSAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzSW5wdXRDaGFuZ2VkIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoKG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyKSB8fCBlbG0udHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gIH1cbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMudHJpbSkge1xuICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn07XG5cbi8qICAqL1xuXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICA6IHN0eWxlXG59XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChjaGlsZE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSkpIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5zdHlsZVtub3JtYWxpemUobmFtZSldID0gdmFsO1xuICB9XG59O1xuXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIHRlc3RFbDtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgdGVzdEVsID0gdGVzdEVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiB0ZXN0RWwuc3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgdXBwZXIgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgdXBwZXI7XG4gICAgaWYgKHByZWZpeGVkIGluIHRlc3RFbC5zdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVkXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoIWRhdGEuc3RhdGljU3R5bGUgJiYgIWRhdGEuc3R5bGUgJiZcbiAgICAgICFvbGREYXRhLnN0YXRpY1N0eWxlICYmICFvbGREYXRhLnN0eWxlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZFZub2RlLmRhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGRWbm9kZS5kYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgdm5vZGUuZGF0YS5zdHlsZSA9IHN0eWxlLl9fb2JfXyA/IGV4dGVuZCh7fSwgc3R5bGUpIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChuZXdTdHlsZVtuYW1lXSA9PSBudWxsKSB7XG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBzdHlsZSA9IHtcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxufTtcblxuLyogICovXG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyLnRyaW0oKSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICB9XG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICA6IHNldFRpbWVvdXQ7XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKSkucHVzaChjbHMpO1xuICBhZGRDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICBlbCxcbiAgZXhwZWN0ZWRUeXBlLFxuICBjYlxuKSB7XG4gIHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcbiAgdmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgdmFyIGVuZGVkID0gMDtcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoZWwuX2xlYXZlQ2IpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbC5fZW50ZXJDYiB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gIH1cblxuICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzXG4gICAgPyBhcHBlYXJUb0NsYXNzXG4gICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcbiAgICA6IGVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG4gICAgOiBhZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYikge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoZWwuX2VudGVyQ2IpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsLl9sZWF2ZUNiIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpW3Zub2RlLmtleV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgaWYgKCFmbikgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGludm9rZXJGbnMpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufSA6IHt9O1xuXG52YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICBhdHRycyxcbiAga2xhc3MsXG4gIGV2ZW50cyxcbiAgZG9tUHJvcHMsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uXG5dO1xuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxudmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgbW9kZWwkMSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgY2IoKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoY2IsIDApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGVsLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBpZiAoIWlzQW5kcm9pZCkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgZWwub3B0aW9ucyk7IH0pXG4gICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGVsLm9wdGlvbnMpO1xuICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBvcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbnNbaV0pLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiAmJiAhaXNJRTkpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBtb2RlbCQxLFxuICBzaG93OiBzaG93XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cbi8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgcmV0dXJuIC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKVxuICAgID8gaCgna2VlcC1hbGl2ZScpXG4gICAgOiBudWxsXG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWc7IH0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9sZENoaWxkICYmIG9sZENoaWxkLmRhdGEgJiYgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkpIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZCAmJiAob2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcbi8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXG4vLyBpbnRvIHRoZSBmaW5hbCBkZXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgdGhpcy5fdm5vZGUsXG4gICAgICB0aGlzLmtlcHQsXG4gICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgdmFyIGYgPSBib2R5Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZSQzLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlJDMuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZSQzLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlJDMub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlJDMucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUkMyk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzQ2hyb21lKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgIGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICk7XG4gIH1cbn0sIDApO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbmZ1bmN0aW9uIHNob3VsZERlY29kZSAoY29udGVudCwgZW5jb2RlZCkge1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgYT1cXFwiXCIgKyBjb250ZW50ICsgXCJcXFwiPlwiO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKGVuY29kZWQpID4gMFxufVxuXG4vLyAjMzY2M1xuLy8gSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gc2hvdWxkRGVjb2RlKCdcXG4nLCAnJiMxMDsnKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qICAqL1xuXG52YXIgZGVjb2RlcjtcblxuZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG59XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLyohXG4gKiBIVE1MIFBhcnNlciBCeSBKb2huIFJlc2lnIChlam9obi5vcmcpXG4gKiBNb2RpZmllZCBieSBKdXJpeSBcImthbmdheFwiIFpheXRzZXZcbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgc2luZ2xlQXR0cklkZW50aWZpZXIgPSAvKFteXFxzXCInPD4vPV0rKS87XG52YXIgc2luZ2xlQXR0ckFzc2lnbiA9IC8oPzo9KS87XG52YXIgc2luZ2xlQXR0clZhbHVlcyA9IFtcbiAgLy8gYXR0ciB2YWx1ZSBkb3VibGUgcXVvdGVzXG4gIC9cIihbXlwiXSopXCIrLy5zb3VyY2UsXG4gIC8vIGF0dHIgdmFsdWUsIHNpbmdsZSBxdW90ZXNcbiAgLycoW14nXSopJysvLnNvdXJjZSxcbiAgLy8gYXR0ciB2YWx1ZSwgbm8gcXVvdGVzXG4gIC8oW15cXHNcIic9PD5gXSspLy5zb3VyY2Vcbl07XG52YXIgYXR0cmlidXRlID0gbmV3IFJlZ0V4cChcbiAgJ15cXFxccyonICsgc2luZ2xlQXR0cklkZW50aWZpZXIuc291cmNlICtcbiAgJyg/OlxcXFxzKignICsgc2luZ2xlQXR0ckFzc2lnbi5zb3VyY2UgKyAnKScgK1xuICAnXFxcXHMqKD86JyArIHNpbmdsZUF0dHJWYWx1ZXMuam9pbignfCcpICsgJykpPydcbik7XG5cbi8vIGNvdWxkIHVzZSBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9SRUMteG1sLW5hbWVzLTE5OTkwMTE0LyNOVC1RTmFtZVxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcbnZhciBuY25hbWUgPSAnW2EtekEtWl9dW1xcXFx3XFxcXC1cXFxcLl0qJztcbnZhciBxbmFtZUNhcHR1cmUgPSAnKCg/OicgKyBuY25hbWUgKyAnXFxcXDopPycgKyBuY25hbWUgKyAnKSc7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgnXjwnICsgcW5hbWVDYXB0dXJlKTtcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgnXjxcXFxcLycgKyBxbmFtZUNhcHR1cmUgKyAnW14+XSo+Jyk7XG52YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xudmFyIGNvbW1lbnQgPSAvXjwhLS0vO1xudmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG52YXIgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGZhbHNlO1xuJ3gnLnJlcGxhY2UoL3goLik/L2csIGZ1bmN0aW9uIChtLCBnKSB7XG4gIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBnID09PSAnJztcbn0pO1xuXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbnZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciByZUNhY2hlID0ge307XG5cbnZhciBkZWNvZGluZ01hcCA9IHtcbiAgJyZsdDsnOiAnPCcsXG4gICcmZ3Q7JzogJz4nLFxuICAnJnF1b3Q7JzogJ1wiJyxcbiAgJyZhbXA7JzogJyYnLFxuICAnJiMxMDsnOiAnXFxuJ1xufTtcbnZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXApOy9nO1xudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMTApOy9nO1xuXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcbiAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBkZWNvZGluZ01hcFttYXRjaF07IH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbmRpdGlvbmFsRW5kID0gaHRtbC5pbmRleE9mKCddPicpO1xuXG4gICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcbiAgICAgICAgICAgIGFkdmFuY2UoY29uZGl0aW9uYWxFbmQgKyAyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9jdHlwZTpcbiAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgIGlmIChkb2N0eXBlTWF0Y2gpIHtcbiAgICAgICAgICBhZHZhbmNlKGRvY3R5cGVNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmQgdGFnOlxuICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xuICAgICAgICAgIHZhciBjdXJJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFsxXSwgY3VySW5kZXgsIGluZGV4KTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgdGFnOlxuICAgICAgICB2YXIgc3RhcnRUYWdNYXRjaCA9IHBhcnNlU3RhcnRUYWcoKTtcbiAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICBoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QkMSA9ICh2b2lkIDApLCBuZXh0ID0gKHZvaWQgMCk7XG4gICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgIHJlc3QkMSA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCQxKSAmJlxuICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0JDEpICYmXG4gICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0JDEpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QkMSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICBuZXh0ID0gcmVzdCQxLmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICBpZiAobmV4dCA8IDApIHsgYnJlYWsgfVxuICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcbiAgICAgICAgICByZXN0JDEgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgICAgYWR2YW5jZSh0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgICBodG1sID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fCAocmVDYWNoZVtzdGFja2VkVGFnXSA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZyArICdbXj5dKj4pJywgJ2knKSk7XG4gICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgIHZhciByZXN0ID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XG4gICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH0pO1xuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0Lmxlbmd0aDtcbiAgICAgIGh0bWwgPSByZXN0O1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgb3B0aW9ucy53YXJuKChcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiICsgaHRtbCArIFwiXFxcIlwiKSk7XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICBwYXJzZUVuZFRhZygpO1xuXG4gIGZ1bmN0aW9uIGFkdmFuY2UgKG4pIHtcbiAgICBpbmRleCArPSBuO1xuICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcgKCkge1xuICAgIHZhciBzdGFydCA9IGh0bWwubWF0Y2goc3RhcnRUYWdPcGVuKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHZhciBtYXRjaCA9IHtcbiAgICAgICAgdGFnTmFtZTogc3RhcnRbMV0sXG4gICAgICAgIGF0dHJzOiBbXSxcbiAgICAgICAgc3RhcnQ6IGluZGV4XG4gICAgICB9O1xuICAgICAgYWR2YW5jZShzdGFydFswXS5sZW5ndGgpO1xuICAgICAgdmFyIGVuZCwgYXR0cjtcbiAgICAgIHdoaWxlICghKGVuZCA9IGh0bWwubWF0Y2goc3RhcnRUYWdDbG9zZSkpICYmIChhdHRyID0gaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcbiAgICB2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cbiAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWcodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICBwYXJzZUVuZFRhZyh0YWdOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8IHRhZ05hbWUgPT09ICdodG1sJyAmJiBsYXN0VGFnID09PSAnaGVhZCcgfHwgISF1bmFyeVNsYXNoO1xuXG4gICAgdmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgLy8gaGFja2lzaCB3b3JrIGFyb3VuZCBGRiBidWcgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MzY5Nzc4XG4gICAgICBpZiAoSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiAmJiBhcmdzWzBdLmluZGV4T2YoJ1wiXCInKSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKGFyZ3NbM10gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzNdOyB9XG4gICAgICAgIGlmIChhcmdzWzRdID09PSAnJykgeyBkZWxldGUgYXJnc1s0XTsgfVxuICAgICAgICBpZiAoYXJnc1s1XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNV07IH1cbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMV0sXG4gICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNcbiAgICAgICAgKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICBzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzOiBhdHRycyB9KTtcbiAgICAgIGxhc3RUYWcgPSB0YWdOYW1lO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbmRUYWcgKHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBzdGFydCA9IGluZGV4OyB9XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7IGVuZCA9IGluZGV4OyB9XG5cbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgZm9yIChwb3MgPSBzdGFjay5sZW5ndGggLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vIHRhZyBuYW1lIGlzIHByb3ZpZGVkLCBjbGVhbiBzaG9wXG4gICAgICBwb3MgPSAwO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAoaSA+IHBvcyB8fCAhdGFnTmFtZSkgJiZcbiAgICAgICAgICAgIG9wdGlvbnMud2Fybikge1xuICAgICAgICAgIG9wdGlvbnMud2FybihcbiAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAncCcpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkZWZhdWx0VGFnUkUgPSAvXFx7XFx7KCg/Oi58XFxuKSs/KVxcfVxcfS9nO1xudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuXG52YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xuICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgdGV4dCxcbiAgZGVsaW1pdGVyc1xuKSB7XG4gIHZhciB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICB2YXIgbWF0Y2gsIGluZGV4O1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgdG9rZW5zLnB1c2goKFwiX3MoXCIgKyBleHAgKyBcIilcIikpO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4KSkpO1xuICB9XG4gIHJldHVybiB0b2tlbnMuam9pbignKycpXG59XG5cbi8qICAqL1xuXG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xudmFyIGRpclJFID0gL152LXxeQHxeOi87XG52YXIgZm9yQWxpYXNSRSA9IC8oLio/KVxccysoPzppbnxvZilcXHMrKC4qKS87XG52YXIgZm9ySXRlcmF0b3JSRSA9IC9cXCgoXFx7W159XSpcXH18W14sXSopLChbXixdKikoPzosKFteLF0qKSk/XFwpLztcblxudmFyIGFyZ1JFID0gLzooLiopJC87XG52YXIgYmluZFJFID0gL146fF52LWJpbmQ6LztcbnZhciBtb2RpZmllclJFID0gL1xcLlteLl0rL2c7XG5cbnZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGRlY29kZSk7XG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMjtcbnZhciBkZWxpbWl0ZXJzO1xudmFyIHRyYW5zZm9ybXM7XG52YXIgcHJlVHJhbnNmb3JtcztcbnZhciBwb3N0VHJhbnNmb3JtcztcbnZhciBwbGF0Zm9ybUlzUHJlVGFnO1xudmFyIHBsYXRmb3JtTXVzdFVzZVByb3A7XG52YXIgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XG5cbi8qKlxuICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG4gIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICB0cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Ob2RlJyk7XG4gIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICB2YXIgcm9vdDtcbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XG4gIHZhciBpblZQcmUgPSBmYWxzZTtcbiAgdmFyIGluUHJlID0gZmFsc2U7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3YXJuT25jZSAobXNnKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB3YXJuJDIobXNnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmRQcmUgKGVsZW1lbnQpIHtcbiAgICAvLyBjaGVjayBwcmUgc3RhdGVcbiAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgIGluUHJlID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgd2Fybjogd2FybiQyLFxuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcbiAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIHRhZzogdGFnLFxuICAgICAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgICAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcbiAgICAgICAgcGFyZW50OiBjdXJyZW50UGFyZW50LFxuICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgIH07XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xuXG4gICAgICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IGFmdGVyXG4gICAgICAgIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xuICAgICAgICBlbGVtZW50LnBsYWluID0gIWVsZW1lbnQua2V5ICYmICFhdHRycy5sZW5ndGg7XG5cbiAgICAgICAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc1Nsb3QoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NDb21wb25lbnQoZWxlbWVudCk7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgIHRyYW5zZm9ybXNbaSQxXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICBcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXG4gICAgICAgICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgfSBlbHNlIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxuICAgICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgICBibG9jazogZWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcbiAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHsgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnBsYWluID0gZmFsc2U7XG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJzsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmRQcmUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgcG9zdFRyYW5zZm9ybXNbaSQyXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQgKCkge1xuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICB2YXIgbGFzdE5vZGUgPSBlbGVtZW50LmNoaWxkcmVuW2VsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdE5vZGUgJiYgbGFzdE5vZGUudHlwZSA9PT0gMyAmJiBsYXN0Tm9kZS50ZXh0ID09PSAnICcgJiYgIWluUHJlKSB7XG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgICAvLyBwb3Agc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgZW5kUHJlKGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBjaGFyczogZnVuY3Rpb24gY2hhcnMgKHRleHQpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuICAgICAgdGV4dCA9IGluUHJlIHx8IHRleHQudHJpbSgpXG4gICAgICAgID8gZGVjb2RlSFRNTENhY2hlZCh0ZXh0KVxuICAgICAgICAvLyBvbmx5IHByZXNlcnZlIHdoaXRlc3BhY2UgaWYgaXRzIG5vdCByaWdodCBhZnRlciBhIHN0YXJ0aW5nIHRhZ1xuICAgICAgICA6IHByZXNlcnZlV2hpdGVzcGFjZSAmJiBjaGlsZHJlbi5sZW5ndGggPyAnICcgOiAnJztcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uO1xuICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKGV4cHJlc3Npb24gPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICB2YXIgbCA9IGVsLmF0dHJzTGlzdC5sZW5ndGg7XG4gIGlmIChsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBlbC5hdHRyc0xpc3RbaV0ubmFtZSxcbiAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGVsLmF0dHJzTGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuJDIoXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICB2YXIgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICAgIGlmICghaW5NYXRjaCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgIChcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApXG4gICAgICApO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVsLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICAgIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpO1xuICAgIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICAgIGVsLmFsaWFzID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgICBlbC5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIGlmIChpdGVyYXRvck1hdGNoWzNdKSB7XG4gICAgICAgIGVsLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbM10udHJpbSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5hbGlhcyA9IGFsaWFzO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMihcbiAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiICsgKGVsLnRhZykgKyBcIj4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuXCJcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcbiAgdmFyIGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0ZXh0IFxcXCJcIiArIChjaGlsZHJlbltpXS50ZXh0LnRyaW0oKSkgKyBcIlxcXCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBcIiArXG4gICAgICAgICAgXCJ3aWxsIGJlIGlnbm9yZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xuICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xuICB9XG4gIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NPbmNlIChlbCkge1xuICB2YXIgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xuICAgIGVsLm9uY2UgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90IChlbCkge1xuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmtleSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xuICAgICAgICBcImFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIFwiICtcbiAgICAgICAgXCJVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgICBpZiAoc2xvdFRhcmdldCkge1xuICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgIH1cbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICBlbC5zbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgdmFyIGJpbmRpbmc7XG4gIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICB9XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgaXNQcm9wO1xuICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICB2YWx1ZSA9IGxpc3RbaV0udmFsdWU7XG4gICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAvLyBtb2RpZmllcnNcbiAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpO1xuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc1Byb3AgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCkge1xuICAgICAgICAgICAgaXNQcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaW5uZXJIdG1sJykgeyBuYW1lID0gJ2lubmVySFRNTCc7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5jYW1lbCkge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcm9wIHx8IHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7IC8vIHYtb25cbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XG4gICAgICAgIGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgdmFyIHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSkge1xuICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gaXNGb3JiaWRkZW5UYWcgKGVsKSB7XG4gIHJldHVybiAoXG4gICAgZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgKGVsLnRhZyA9PT0gJ3NjcmlwdCcgJiYgKFxuICAgICAgIWVsLmF0dHJzTWFwLnR5cGUgfHxcbiAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgKSlcbiAgKVxufVxuXG52YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcbnZhciBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgaWYgKCFpZU5TQnVnLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgcmVzLnB1c2goYXR0cik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgdmFyIF9lbCA9IGVsO1xuICB3aGlsZSAoX2VsKSB7XG4gICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xuICAgICAgICBcIlRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIFwiICtcbiAgICAgICAgXCJ3cml0aW5nIHRvIHRoZSBhbGlhcyBpcyBsaWtlIG1vZGlmeWluZyBhIGZ1bmN0aW9uIGxvY2FsIHZhcmlhYmxlLiBcIiArXG4gICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIF9lbCA9IF9lbC5wYXJlbnQ7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBpc1N0YXRpY0tleTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbnZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzJyArXG4gICAgKGtleXMgPyAnLCcgKyBrZXlzIDogJycpXG4gIClcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyQxIChub2RlKSB7XG4gIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAvLyBkbyBub3QgbWFrZSBjb21wb25lbnQgc2xvdCBjb250ZW50IHN0YXRpYy4gdGhpcyBhdm9pZHNcbiAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXG4gICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgIGlmIChcbiAgICAgICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXG4gICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgICBub2RlLmF0dHJzTWFwWydpbmxpbmUtdGVtcGxhdGUnXSA9PSBudWxsXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIG1hcmtTdGF0aWMkMShjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xuICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIHdhbGtUaHJvdWdoQ29uZGl0aW9uc0Jsb2Nrcyhub2RlLmlmQ29uZGl0aW9ucywgaXNJbkZvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhbGtUaHJvdWdoQ29uZGl0aW9uc0Jsb2NrcyAoY29uZGl0aW9uQmxvY2tzLCBpc0luRm9yKSB7XG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBjb25kaXRpb25CbG9ja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBtYXJrU3RhdGljUm9vdHMoY29uZGl0aW9uQmxvY2tzW2ldLmJsb2NrLCBpc0luRm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0YXRpYyAobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSAyKSB7IC8vIGV4cHJlc3Npb25cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAzKSB7IC8vIHRleHRcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiAhIShub2RlLnByZSB8fCAoXG4gICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xuICAgICFub2RlLmlmICYmICFub2RlLmZvciAmJiAvLyBub3Qgdi1pZiBvciB2LWZvciBvciB2LWVsc2VcbiAgICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XG4gICAgIWlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yKG5vZGUpICYmXG4gICAgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XG4gIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICBpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobm9kZS5mb3IpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxudmFyIGZuRXhwUkUgPSAvXlxccyooW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqXFwoLztcbnZhciBzaW1wbGVQYXRoUkUgPSAvXlxccypbQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWycuKj8nXXxcXFtcIi4qP1wiXXxcXFtcXGQrXXxcXFtbQS1aYS16XyRdW1xcdyRdKl0pKlxccyokLztcblxuLy8ga2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gICdkZWxldGUnOiBbOCwgNDZdXG59O1xuXG4vLyAjNDg2ODogbW9kaWZpZXJzIHRoYXQgcHJldmVudCB0aGUgZXhlY3V0aW9uIG9mIHRoZSBsaXN0ZW5lclxuLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxuLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxudmFyIGdlbkd1YXJkID0gZnVuY3Rpb24gKGNvbmRpdGlvbikgeyByZXR1cm4gKFwiaWYoXCIgKyBjb25kaXRpb24gKyBcIilyZXR1cm4gbnVsbDtcIik7IH07XG5cbnZhciBtb2RpZmllckNvZGUgPSB7XG4gIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgcHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXG4gIHNlbGY6IGdlbkd1YXJkKFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcIiksXG4gIGN0cmw6IGdlbkd1YXJkKFwiISRldmVudC5jdHJsS2V5XCIpLFxuICBzaGlmdDogZ2VuR3VhcmQoXCIhJGV2ZW50LnNoaWZ0S2V5XCIpLFxuICBhbHQ6IGdlbkd1YXJkKFwiISRldmVudC5hbHRLZXlcIiksXG4gIG1ldGE6IGdlbkd1YXJkKFwiISRldmVudC5tZXRhS2V5XCIpLFxuICBsZWZ0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwXCIpLFxuICBtaWRkbGU6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcIiksXG4gIHJpZ2h0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpXG59O1xuXG5mdW5jdGlvbiBnZW5IYW5kbGVycyAoZXZlbnRzLCBuYXRpdmUpIHtcbiAgdmFyIHJlcyA9IG5hdGl2ZSA/ICduYXRpdmVPbjp7JyA6ICdvbjp7JztcbiAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICByZXMgKz0gXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiOlwiICsgKGdlbkhhbmRsZXIobmFtZSwgZXZlbnRzW25hbWVdKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICd9J1xufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChcbiAgbmFtZSxcbiAgaGFuZGxlclxuKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH1cblxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcblxuICBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgcmV0dXJuIGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgPyBoYW5kbGVyLnZhbHVlXG4gICAgICA6IChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxuICB9IGVsc2Uge1xuICAgIHZhciBjb2RlID0gJyc7XG4gICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgID8gaGFuZGxlci52YWx1ZSArICcoJGV2ZW50KSdcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCIoXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIikoJGV2ZW50KVwiKVxuICAgICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgcmV0dXJuIChcImlmKCEoJ2J1dHRvbicgaW4gJGV2ZW50KSYmXCIgKyAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIilcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICB9XG4gIHZhciBhbGlhcyA9IGtleUNvZGVzW2tleV07XG4gIHJldHVybiAoXCJfaygkZXZlbnQua2V5Q29kZSxcIiArIChKU09OLnN0cmluZ2lmeShrZXkpKSArIChhbGlhcyA/ICcsJyArIEpTT04uc3RyaW5naWZ5KGFsaWFzKSA6ICcnKSArIFwiKVwiKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZCQxIChlbCwgZGlyKSB7XG4gIGVsLndyYXBEYXRhID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gKFwiX2IoXCIgKyBjb2RlICsgXCIsJ1wiICsgKGVsLnRhZykgKyBcIicsXCIgKyAoZGlyLnZhbHVlKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgYmluZDogYmluZCQxLFxuICBjbG9hazogbm9vcFxufTtcblxuLyogICovXG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMztcbnZhciB0cmFuc2Zvcm1zJDE7XG52YXIgZGF0YUdlbkZucztcbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMkMTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMTtcbnZhciBzdGF0aWNSZW5kZXJGbnM7XG52YXIgb25jZUNvdW50O1xudmFyIGN1cnJlbnRPcHRpb25zO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZSAoXG4gIGFzdCxcbiAgb3B0aW9uc1xuKSB7XG4gIC8vIHNhdmUgcHJldmlvdXMgc3RhdGljUmVuZGVyRm5zIHNvIGdlbmVyYXRlIGNhbGxzIGNhbiBiZSBuZXN0ZWRcbiAgdmFyIHByZXZTdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG4gIHZhciBjdXJyZW50U3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zID0gW107XG4gIHZhciBwcmV2T25jZUNvdW50ID0gb25jZUNvdW50O1xuICBvbmNlQ291bnQgPSAwO1xuICBjdXJyZW50T3B0aW9ucyA9IG9wdGlvbnM7XG4gIHdhcm4kMyA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdHJhbnNmb3JtcyQxID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gIGRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgcGxhdGZvcm1EaXJlY3RpdmVzJDEgPSBvcHRpb25zLmRpcmVjdGl2ZXMgfHwge307XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyQxID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0KSA6ICdfYyhcImRpdlwiKSc7XG4gIHN0YXRpY1JlbmRlckZucyA9IHByZXZTdGF0aWNSZW5kZXJGbnM7XG4gIG9uY2VDb3VudCA9IHByZXZPbmNlQ291bnQ7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXG4gICAgc3RhdGljUmVuZGVyRm5zOiBjdXJyZW50U3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwpIHtcbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwpXG4gIH0gZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5PbmNlKGVsKVxuICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbClcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwpXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0KSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsKSB8fCAndm9pZCAwJ1xuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgcmV0dXJuIGdlblNsb3QoZWwpXG4gIH0gZWxzZSB7XG4gICAgLy8gY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICB2YXIgY29kZTtcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YSA9IGVsLnBsYWluID8gdW5kZWZpbmVkIDogZ2VuRGF0YShlbCk7XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zJDEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvZGUgPSB0cmFuc2Zvcm1zJDFbaV0oZWwsIGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG5cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIHN0YXRpY1JlbmRlckZucy5wdXNoKChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwpKSArIFwifVwiKSk7XG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwpIHtcbiAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwpXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcbiAgICB2YXIga2V5ID0gJyc7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQzKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsKVxuICAgIH1cbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCkpICsgXCIsXCIgKyAob25jZUNvdW50KyspICsgKGtleSA/IChcIixcIiArIGtleSkgOiBcIlwiKSArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKGVsKSB7XG4gIGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCkpXG59XG5cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoY29uZGl0aW9ucykge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICdfZSgpJ1xuICB9XG5cbiAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucykpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpKVxuICB9XG5cbiAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xuICAgIHJldHVybiBlbC5vbmNlID8gZ2VuT25jZShlbCkgOiBnZW5FbGVtZW50KGVsKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkZvciAoZWwpIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgbWF5YmVDb21wb25lbnQoZWwpICYmIGVsLnRhZyAhPT0gJ3Nsb3QnICYmIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJiAhZWwua2V5XG4gICkge1xuICAgIHdhcm4kMyhcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LWZvcj1cXFwiXCIgKyBhbGlhcyArIFwiIGluIFwiICsgZXhwICsgXCJcXFwiPjogY29tcG9uZW50IGxpc3RzIHJlbmRlcmVkIHdpdGggXCIgK1xuICAgICAgXCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcIiArXG4gICAgICBcIlNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uXCIsXG4gICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICk7XG4gIH1cblxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIFwiX2woKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEgKGVsKSB7XG4gIHZhciBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCk7XG4gIGlmIChkaXJzKSB7IGRhdGEgKz0gZGlycyArICcsJzsgfVxuXG4gIC8vIGtleVxuICBpZiAoZWwua2V5KSB7XG4gICAgZGF0YSArPSBcImtleTpcIiArIChlbC5rZXkpICsgXCIsXCI7XG4gIH1cbiAgLy8gcmVmXG4gIGlmIChlbC5yZWYpIHtcbiAgICBkYXRhICs9IFwicmVmOlwiICsgKGVsLnJlZikgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgfVxuICAvLyBwcmVcbiAgaWYgKGVsLnByZSkge1xuICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZGF0YSArPSBcInRhZzpcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIjtcbiAgfVxuICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcbiAgICBkYXRhICs9IGRhdGFHZW5GbnNbaV0oZWwpO1xuICB9XG4gIC8vIGF0dHJpYnV0ZXNcbiAgaWYgKGVsLmF0dHJzKSB7XG4gICAgZGF0YSArPSBcImF0dHJzOntcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIERPTSBwcm9wc1xuICBpZiAoZWwucHJvcHMpIHtcbiAgICBkYXRhICs9IFwiZG9tUHJvcHM6e1wiICsgKGdlblByb3BzKGVsLnByb3BzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cykpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLm5hdGl2ZUV2ZW50cywgdHJ1ZSkpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2xvdCB0YXJnZXRcbiAgaWYgKGVsLnNsb3RUYXJnZXQpIHtcbiAgICBkYXRhICs9IFwic2xvdDpcIiArIChlbC5zbG90VGFyZ2V0KSArIFwiLFwiO1xuICB9XG4gIC8vIHNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICBkYXRhICs9IChnZW5TY29wZWRTbG90cyhlbC5zY29wZWRTbG90cykpICsgXCIsXCI7XG4gIH1cbiAgLy8gY29tcG9uZW50IHYtbW9kZWxcbiAgaWYgKGVsLm1vZGVsKSB7XG4gICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCk7XG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgICBkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCkge1xuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICB2YXIgZ2VuID0gcGxhdGZvcm1EaXJlY3RpdmVzJDFbZGlyLm5hbWVdIHx8IGJhc2VEaXJlY3RpdmVzW2Rpci5uYW1lXTtcbiAgICBpZiAoZ2VuKSB7XG4gICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCB3YXJuJDMpO1xuICAgIH1cbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiICsgKGRpci5uYW1lKSArIFwiXFxcIixyYXdOYW1lOlxcXCJcIiArIChkaXIucmF3TmFtZSkgKyBcIlxcXCJcIiArIChkaXIudmFsdWUgPyAoXCIsdmFsdWU6KFwiICsgKGRpci52YWx1ZSkgKyBcIiksZXhwcmVzc2lvbjpcIiArIChKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpKSkgOiAnJykgKyAoZGlyLmFyZyA/IChcIixhcmc6XFxcIlwiICsgKGRpci5hcmcpICsgXCJcXFwiXCIpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwpIHtcbiAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoXG4gICAgZWwuY2hpbGRyZW4ubGVuZ3RoID4gMSB8fCBhc3QudHlwZSAhPT0gMVxuICApKSB7XG4gICAgd2FybiQzKCdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nKTtcbiAgfVxuICBpZiAoYXN0LnR5cGUgPT09IDEpIHtcbiAgICB2YXIgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBjdXJyZW50T3B0aW9ucyk7XG4gICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoc2xvdHMpIHtcbiAgcmV0dXJuIChcInNjb3BlZFNsb3RzOl91KFtcIiArIChPYmplY3Qua2V5cyhzbG90cykubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGdlblNjb3BlZFNsb3Qoa2V5LCBzbG90c1trZXldKTsgfSkuam9pbignLCcpKSArIFwiXSlcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoa2V5LCBlbCkge1xuICByZXR1cm4gXCJbXCIgKyBrZXkgKyBcIixmdW5jdGlvbihcIiArIChTdHJpbmcoZWwuYXR0cnNNYXAuc2NvcGUpKSArIFwiKXtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGdlbkNoaWxkcmVuKGVsKSB8fCAndm9pZCAwJ1xuICAgICAgOiBnZW5FbGVtZW50KGVsKSkgKyBcIn1dXCJcbn1cblxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKGVsLCBjaGVja1NraXApIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgZWwkMS5mb3IgJiZcbiAgICAgICAgZWwkMS50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgICAgZWwkMS50YWcgIT09ICdzbG90Jykge1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwkMSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4pIDogMDtcbiAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChnZW5Ob2RlKS5qb2luKCcsJykpICsgXCJdXCIgKyAobm9ybWFsaXphdGlvblR5cGUgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChjaGlsZHJlbikge1xuICB2YXIgcmVzID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChlbC50eXBlICE9PSAxKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbWF5YmVDb21wb25lbnQoYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24gKGVsKSB7XG4gIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcbn1cblxuZnVuY3Rpb24gbWF5YmVDb21wb25lbnQgKGVsKSB7XG4gIHJldHVybiAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDEoZWwudGFnKVxufVxuXG5mdW5jdGlvbiBnZW5Ob2RlIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCkge1xuICB2YXIgc2xvdE5hbWUgPSBlbC5zbG90TmFtZSB8fCAnXCJkZWZhdWx0XCInO1xuICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCk7XG4gIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XG4gIHZhciBhdHRycyA9IGVsLmF0dHJzICYmIChcIntcIiArIChlbC5hdHRycy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgoY2FtZWxpemUoYS5uYW1lKSkgKyBcIjpcIiArIChhLnZhbHVlKSk7IH0pLmpvaW4oJywnKSkgKyBcIn1cIik7XG4gIHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBcIixudWxsXCI7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gIH1cbiAgaWYgKGJpbmQkJDEpIHtcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoY29tcG9uZW50TmFtZSwgZWwpIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHRydWUpO1xuICByZXR1cm4gKFwiX2MoXCIgKyBjb21wb25lbnROYW1lICsgXCIsXCIgKyAoZ2VuRGF0YShlbCkpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIHJlcyArPSBcIlxcXCJcIiArIChwcm9wLm5hbWUpICsgXCJcXFwiOlwiICsgKHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxufVxuXG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxufVxuXG4vKiAgKi9cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gY2hlY2sgdmFsaWQgaWRlbnRpZmllciBmb3Igdi1mb3JcbnZhciBpZGVudFJFID0gL1tBLVphLXpfJF1bXFx3JF0qLztcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0KSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYgKGFzdCkge1xuICAgIGNoZWNrTm9kZShhc3QsIGVycm9ycyk7XG4gIH1cbiAgcmV0dXJuIGVycm9yc1xufVxuXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIGVycm9ycykge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XG4gICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgZXJyb3JzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCBlcnJvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICBlcnJvcnMucHVzaChcbiAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpXG4gICAgKTtcbiAgfVxuICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgZXJyb3JzKSB7XG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKGlkZW50LCB0eXBlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycgJiYgIWlkZW50UkUudGVzdChpZGVudCkpIHtcbiAgICBlcnJvcnMucHVzaCgoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIFwiICsgZXhwKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG4gIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3Q6IGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICB2YXIgZnVuY3Rpb25Db21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgdGlwcyA9IFtdO1xuICAgIGZpbmFsT3B0aW9ucy53YXJuID0gZnVuY3Rpb24gKG1zZywgdGlwJCQxKSB7XG4gICAgICAodGlwJCQxID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPSAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICB9XG4gICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zLmRpcmVjdGl2ZXMpLFxuICAgICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8gY29weSBvdGhlciBvcHRpb25zXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLCBmaW5hbE9wdGlvbnMpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QpKTtcbiAgICB9XG4gICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgIHJldHVybiBjb21waWxlZFxuICB9XG5cbiAgZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xuICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuICAgICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcbiAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FjaGVcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgIDogdGVtcGxhdGU7XG4gICAgaWYgKGZ1bmN0aW9uQ29tcGlsZUNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbkNvbXBpbGVDYWNoZVtrZXldXG4gICAgfVxuXG4gICAgLy8gY29tcGlsZVxuICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNvbXBpbGVkLmVycm9ycyAmJiBjb21waWxlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyB0ZW1wbGF0ZSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChcIi0gXCIgKyBlKTsgfSkuam9pbignXFxuJykgKyAnXFxuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcbiAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBmbkdlbkVycm9ycyA9IFtdO1xuICAgIHJlcy5yZW5kZXIgPSBtYWtlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgdmFyIGwgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJlcy5zdGF0aWNSZW5kZXJGbnNbaV0gPSBtYWtlRnVuY3Rpb24oY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zW2ldLCBmbkdlbkVycm9ycyk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXG4gICAgLy8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUgaXMgYSBidWcgaW4gdGhlIGNvbXBpbGVyIGl0c2VsZi5cbiAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmVuZGVyIGZ1bmN0aW9uOlxcblxcblwiICtcbiAgICAgICAgICBmbkdlbkVycm9ycy5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIGVyciA9IHJlZi5lcnI7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHJlZi5jb2RlO1xuXG4gICAgICAgICAgICByZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xuICAgICAgICB9KS5qb2luKCdcXG4nKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoZnVuY3Rpb25Db21waWxlQ2FjaGVba2V5XSA9IHJlcylcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tcGlsZTogY29tcGlsZSxcbiAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNvbXBpbGVUb0Z1bmN0aW9uc1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRpY0NsYXNzKSB7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiY2xhc3M9XFxcIlwiICsgc3RhdGljQ2xhc3MgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgdmFyIGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBrbGFzcyQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMlxufTtcblxudmFyIG1vZHVsZXMkMSA9IFtcbiAga2xhc3MkMSxcbiAgc3R5bGUkMVxuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWw6IG1vZGVsLFxuICB0ZXh0OiB0ZXh0LFxuICBodG1sOiBodG1sXG59O1xuXG4vKiAgKi9cblxudmFyIGJhc2VPcHRpb25zID0ge1xuICBleHBlY3RIVE1MOiB0cnVlLFxuICBtb2R1bGVzOiBtb2R1bGVzJDEsXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcbiAgaXNQcmVUYWc6IGlzUHJlVGFnLFxuICBpc1VuYXJ5VGFnOiBpc1VuYXJ5VGFnLFxuICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXG4gIGlzUmVzZXJ2ZWRUYWc6IGlzUmVzZXJ2ZWRUYWcsXG4gIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxuICBzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSlcbn07XG5cbnZhciByZWYkMSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcbnZhciBjb21waWxlVG9GdW5jdGlvbnMgPSByZWYkMS5jb21waWxlVG9GdW5jdGlvbnM7XG5cbi8qICAqL1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG52YXIgbW91bnQgPSBWdWUkMy5wcm90b3R5cGUuJG1vdW50O1xuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZSgoKHRoaXMuX25hbWUpICsgXCIgY29tcGlsZVwiKSwgJ2NvbXBpbGUnLCAnY29tcGlsZSBlbmQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8qKlxuICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcbiAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICovXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwgKGVsKSB7XG4gIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXG4gIH1cbn1cblxuVnVlJDMuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuZXhwb3J0IGRlZmF1bHQgVnVlJDM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3Z1ZS9kaXN0L3Z1ZS5lc20uanMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwicmVxdWlyZSgnLi4vLi4vc3JjL3N0eWxlcy9tYWluLnNjc3MnKTtcblxuLy8gTG9hZCBsaWJyYXJ5XG5INVAuRmVlZGJhY2sgPSByZXF1aXJlKCcuLi9zY3JpcHRzL2ZlZWRiYWNrJykuZGVmYXVsdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZW50cmllcy9kaXN0LmpzIiwidmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vRmluYWwudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi01YzJiYjExMVxcXCIsXFxcInByZXNlcnZlV2hpdGVzcGFjZVxcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9GaW5hbC52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIi9ob21lL3RvbWFqL2NvZGUvam91YmVsL2NvbnRlbnQtdHlwZXMvaDVwLWZlZWRiYWNrL3NyYy9zY3JpcHRzL3ZpZXdzL0ZpbmFsLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5ICE9PSBcIl9fZXNNb2R1bGVcIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIEZpbmFsLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi01YzJiYjExMVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTVjMmJiMTExXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zY3JpcHRzL3ZpZXdzL0ZpbmFsLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vU2NvcmVJbnB1dC52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTQ5MDNkY2NkXFxcIixcXFwicHJlc2VydmVXaGl0ZXNwYWNlXFxcIjpmYWxzZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL1Njb3JlSW5wdXQudnVlXCIpLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIGNzc01vZHVsZXMgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCIvaG9tZS90b21hai9jb2RlL2pvdWJlbC9jb250ZW50LXR5cGVzL2g1cC1mZWVkYmFjay9zcmMvc2NyaXB0cy92aWV3cy9TY29yZUlucHV0LnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5ICE9PSBcIl9fZXNNb2R1bGVcIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIFNjb3JlSW5wdXQudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTQ5MDNkY2NkXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNDkwM2RjY2RcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NjcmlwdHMvdmlld3MvU2NvcmVJbnB1dC52dWVcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL1RleHRJbnB1dC52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTYzMTVhMTM4XFxcIixcXFwicHJlc2VydmVXaGl0ZXNwYWNlXFxcIjpmYWxzZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL1RleHRJbnB1dC52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIi9ob21lL3RvbWFqL2NvZGUvam91YmVsL2NvbnRlbnQtdHlwZXMvaDVwLWZlZWRiYWNrL3NyYy9zY3JpcHRzL3ZpZXdzL1RleHRJbnB1dC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleSAhPT0gXCJfX2VzTW9kdWxlXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBUZXh0SW5wdXQudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTYzMTVhMTM4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNjMxNWExMzhcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NjcmlwdHMvdmlld3MvVGV4dElucHV0LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiaDVwLWZlZWRiYWNrLXNjb3JlXCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwicm9sZVwiOiBcInJlZ2lvblwiXG4gICAgfVxuICB9LCBbX2MoJ2gzJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZlZWRiYWNrLXRpdGxlXCIsXG4gICAgZG9tUHJvcHM6IHtcbiAgICAgIFwiaW5uZXJIVE1MXCI6IF92bS5fcyhfdm0ubWVzc2FnZSlcbiAgICB9XG4gIH0pLCBfYygndWwnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZmVlZGJhY2stc2NvcmUtaW5wdXRcIlxuICB9LCBfdm0uX2woKF92bS5hbHRlcm5hdGl2ZXMpLCBmdW5jdGlvbihhbHRlcm5hdGl2ZSkge1xuICAgIHJldHVybiBfYygnbGknLCBbX2MoJ2RpdicsIHtcbiAgICAgIGNsYXNzOiBhbHRlcm5hdGl2ZS5jbHMsXG4gICAgICBhdHRyczoge1xuICAgICAgICBcInJvbGVcIjogXCJidXR0b25cIlxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgX3ZtLnNlbmRTY29yZShhbHRlcm5hdGl2ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtfYygnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwiZmVlZGJhY2stc2NvcmUtdGl0bGVcIlxuICAgIH0sIFtfdm0uX3YoX3ZtLl9zKGFsdGVybmF0aXZlLnRpdGxlKSldKV0pXSlcbiAgfSkpXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtNDkwM2RjY2RcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00OTAzZGNjZFwiLFwicHJlc2VydmVXaGl0ZXNwYWNlXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvc2NyaXB0cy92aWV3cy9TY29yZUlucHV0LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF92bS5fbSgwKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiaDVwLWZlZWRiYWNrLWZpbmFsXCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwicm9sZVwiOiBcInJlZ2lvblwiXG4gICAgfVxuICB9LCBbX2MoJ3AnLCBbX3ZtLl92KFwiV2UgcHV0IGEgbG90IG9mIGVmZm9ydCBpbnRvIG1ha2luZyBINVAgZWFzeSB0byB1c2UgZm9yIGFsbCFcIildKSwgX2MoJ2gyJywgW192bS5fdihcIllvdXIgZmVlZGJhY2sgaXMgaGlnaGx5IGFwcHJlY2lhdGVkIVwiKV0pXSlcbn1dfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi01YzJiYjExMVwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTVjMmJiMTExXCIsXCJwcmVzZXJ2ZVdoaXRlc3BhY2VcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9zY3JpcHRzL3ZpZXdzL0ZpbmFsLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZmVlZGJhY2stdGV4dC1pbnB1dFwiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcInJvbGVcIjogXCJyZWdpb25cIlxuICAgIH1cbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZnJvbS1zY29yZS1pbnB1dFwiXG4gIH0sIFtfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJmZWVkYmFjay1zY29yZVwiLFxuICAgIGNsYXNzOiBfdm0uYWx0ZXJuYXRpdmUuY2xzXG4gIH0pLCBfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJmZWVkYmFjay1zY29yZS10aXRsZVwiXG4gIH0sIFtfdm0uX3YoX3ZtLl9zKHRoaXMuYWx0ZXJuYXRpdmUudGl0bGUpKV0pLCBfYygncm91dGVyLWxpbmsnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwidG9cIjogXCIvc2NvcmUtaW5wdXRcIlxuICAgIH1cbiAgfSwgW192bS5fdihcIkNoYW5nZVwiKV0pXSwgMSksIF9jKCdoMicsIFtfdm0uX3YoXCJUaGFua3MgZm9yIHRoZSByYXRpbmchXCIpXSksIF92bS5fbSgwKSwgX2MoJ3RleHRhcmVhJywge1xuICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgIHZhbHVlOiAoX3ZtLnRleHQpLFxuICAgICAgZXhwcmVzc2lvbjogXCJ0ZXh0XCJcbiAgICB9XSxcbiAgICBhdHRyczoge1xuICAgICAgXCJyb3dzXCI6IFwiNFwiLFxuICAgICAgXCJwbGFjZWhvbGRlclwiOiBcIllvdXIgRmVlZGJhY2tcIlxuICAgIH0sXG4gICAgZG9tUHJvcHM6IHtcbiAgICAgIFwidmFsdWVcIjogKF92bS50ZXh0KVxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwiaW5wdXRcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIGlmICgkZXZlbnQudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm47IH1cbiAgICAgICAgX3ZtLnRleHQgPSAkZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9KSwgX2MoJ2J1dHRvbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJidXR0b24gYnV0dG9uLXByaW1hcnlcIixcbiAgICBhdHRyczoge1xuICAgICAgXCJkaXNhYmxlZFwiOiBfdm0udGV4dC5sZW5ndGggPCAxXG4gICAgfSxcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgX3ZtLnNlbmRUZXh0KF92bS50ZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfSwgW192bS5fdihcIlNlbmRcIildKV0pXG59LHN0YXRpY1JlbmRlckZuczogW2Z1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ3AnLCBbX3ZtLl92KFwiTGV0IHVzIGtub3cgaG93IHdlIGNhbiBpbXByb3ZlIHlvdXIgZXhwZXJpZW5jZSB3aXRoIHRoZSBcIiksIF9jKCdzdHJvbmcnLCBbX3ZtLl92KFwiRHJhZyBUZXh0XCIpXSksIF92bS5fdihcIiBhdXRob3JpbmcgdG9vbC5cIildKVxufV19XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTYzMTVhMTM4XCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNjMxNWExMzhcIixcInByZXNlcnZlV2hpdGVzcGFjZVwiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL3NjcmlwdHMvdmlld3MvVGV4dElucHV0LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==